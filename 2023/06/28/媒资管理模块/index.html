<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>媒资管理模块 | 光明</title><meta name="author" content="ADAN"><meta name="copyright" content="ADAN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="模块需求分析模块介绍 媒资管理系统是每个在线教育平台所必须具备的，百度百科对其定义如下   媒体资源管理(Media Asset Management，MAM)系统是建立在多媒体、网络、数据库和数字存储等先进技术基础上的一个对各种媒体及内容(如视&#x2F;音频资料、文本文件、图表等)进行数字化存储、管理以及应用的总体解决方案，包括数字媒体的采集、编目、管理、传输和编码转换等所有环节。其主要是满足">
<meta property="og:type" content="article">
<meta property="og:title" content="媒资管理模块">
<meta property="og:url" content="http://example.com/2023/06/28/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/index.html">
<meta property="og:site_name" content="光明">
<meta property="og:description" content="模块需求分析模块介绍 媒资管理系统是每个在线教育平台所必须具备的，百度百科对其定义如下   媒体资源管理(Media Asset Management，MAM)系统是建立在多媒体、网络、数据库和数字存储等先进技术基础上的一个对各种媒体及内容(如视&#x2F;音频资料、文本文件、图表等)进行数字化存储、管理以及应用的总体解决方案，包括数字媒体的采集、编目、管理、传输和编码转换等所有环节。其主要是满足">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/4.jpg">
<meta property="article:published_time" content="2023-06-27T17:09:00.608Z">
<meta property="article:modified_time" content="2023-06-27T17:35:00.826Z">
<meta property="article:author" content="ADAN">
<meta property="article:tag" content="java实战">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/4.jpg"><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="http://example.com/2023/06/28/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '媒资管理模块',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-28 01:35:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/js/custom.js"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/king.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/4.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="光明"><span class="site-name">光明</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> myself</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">媒资管理模块</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-27T17:09:00.608Z" title="发表于 2023-06-28 01:09:00">2023-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-27T17:35:00.826Z" title="更新于 2023-06-28 01:35:00">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/xcplus/">xcplus</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="媒资管理模块"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="模块需求分析"><a href="#模块需求分析" class="headerlink" title="模块需求分析"></a>模块需求分析</h1><h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><ul>
<li>媒资管理系统是每个在线教育平台所必须具备的，百度百科对其定义如下</li>
</ul>
<blockquote>
<p>媒体资源管理(Media Asset Management，MAM)系统是建立在多媒体、网络、数据库和数字存储等先进技术基础上的一个对各种媒体及内容(如视&#x2F;音频资料、文本文件、图表等)进行数字化存储、管理以及应用的总体解决方案，包括数字媒体的采集、编目、管理、传输和编码转换等所有环节。其主要是满足媒体资源拥有者收集、保存、查找、编辑、发布各种信息的要求，为媒体资源的使用者提供访问内容的便捷方法，实现对媒体资源的高效管理，大幅度提高媒体资源的价值。</p>
</blockquote>
<ul>
<li>每个教学机构都可以在媒资管理系统管理自己的教学资源，包括：视频、教案等文件</li>
<li>目前媒资管理的主要管理对象是视频、图片、文档等，包括：媒资文件的查询、文件上传、视频处理等</li>
<li>主要的几个功能如下：<ul>
<li>媒资查询：教学机构查询自己所拥有的的媒资信息</li>
<li>文件上传：包括上传图片、上传文档、上传视频</li>
<li>视频处理：视频上传成功，系统自动对视频进行编码处理</li>
<li>文件删除：教学机构删除自己上传的媒资文件</li>
</ul>
</li>
<li>下图是课程编辑与发布的全流程，可以通过下图看到媒资在整体流程的位置<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160042201.png" alt="img"></li>
</ul>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><ul>
<li>教学机构人员在课程信息编辑页面上传课程图片，课程图片统一记录在媒资管理系统</li>
</ul>
<h3 id="上传视频"><a href="#上传视频" class="headerlink" title="上传视频"></a>上传视频</h3><ol>
<li>教学机构人员进入媒资管理列表查询自己上传的媒资文件</li>
<li>教育机构用户在<code>媒资管理</code>页面中点击<code>上传视频</code>按钮</li>
<li>选择要上传的文件，自动执行文件上传</li>
<li>视频上传成功会自动处理，处理完成后可以预览视频</li>
</ol>
<h3 id="处理视频"><a href="#处理视频" class="headerlink" title="处理视频"></a>处理视频</h3><ul>
<li>对需要转码处理的视频，系统会自动对齐处理，处理后生成视频的URL</li>
</ul>
<h3 id="审核媒资"><a href="#审核媒资" class="headerlink" title="审核媒资"></a>审核媒资</h3><ol>
<li>运营用户登入运营平台，并进入媒资管理界面，查找待审核媒资</li>
<li>点击列表中媒资名称连接，可以预览该媒资，若是视频，则播放视频</li>
<li>点击列表中某媒资后的<code>审核按钮</code>，即完成媒资的审批过程</li>
</ol>
<h3 id="绑定媒资"><a href="#绑定媒资" class="headerlink" title="绑定媒资"></a>绑定媒资</h3><ul>
<li>课程计划创建好后需要绑定媒资文件，比如：如果课程计划绑定了视频文件，进入课程在线学习界面后，点课程计划名称则在线播放视频</li>
<li>如何将课程计划绑定媒资呢？<ol>
<li>教育机构用户进入课程管理页面编辑某一课程，在<code>课程大纲</code>编辑页的某一小节后，可以添加<code>媒资信息</code></li>
<li>点击<code>添加视频</code>，会弹出对话框，可通过输入视频关键字搜索已审核通过的视频媒资</li>
<li>选择视频媒资，点击提交安努，完成课程计划绑定媒资流程</li>
</ol>
</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul>
<li>本模块妹子恩建相关数据表如下<ol>
<li>media_files：存储文件信息，包括图片、视频、文档等<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160042130.png" alt="img"></li>
<li>media_process：待处理视频表<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160042674.png" alt="img"></li>
<li>media_process_history：视频处理历史表，记录已经处理成功的视频信息<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160123199.png" alt="img"></li>
</ol>
</li>
</ul>
<h1 id="搭建模块环境"><a href="#搭建模块环境" class="headerlink" title="搭建模块环境"></a>搭建模块环境</h1><h2 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h2><ul>
<li><p>当前要开发的是媒资管理服务，目前为止共三个微服务：内容管理、系统管理、媒资管理</p>
</li>
<li><p>后期还会添加更多的微服务，目前这种由前端直接请求微服务的方式存在弊端</p>
</li>
<li><p>如果在前端对每个请求地址都配置绝对路径，非常不利于系统维护，例如下面这种</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//</span> <span class="string">列表</span></span><br><span class="line"><span class="attr">export</span> <span class="string">async function dictionaryAll(params: any = undefined, body: any = undefined): Promise&lt;ISystemDictionary[]&gt; &#123;</span></span><br><span class="line">	<span class="attr">//const</span> <span class="string">&#123; data &#125; = await createAPI(&#x27;/system/dictionary/all&#x27;, &#x27;get&#x27;, params, body)</span></span><br><span class="line">	<span class="attr">const</span> <span class="string">&#123; data &#125; = await createAPI(&#x27;http://localhost:53110/system/dictionary/all&#x27;, &#x27;get&#x27;, params, body)</span></span><br><span class="line">	<span class="attr">return</span> <span class="string">data</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当系统上限后，需要将localhost改为公网域名，如果这种地址非常多，那么修改会很麻烦</p>
</li>
<li><p>基于这个问题，可以采用网关来解决<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038170.png" alt="img"></p>
</li>
<li><p>这样在前端代码中只需要指定每个接口的相对路径</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//</span> <span class="string">列表</span></span><br><span class="line"><span class="attr">export</span> <span class="string">async function dictionaryAll(params: any = undefined, body: any = undefined): Promise&lt;ISystemDictionary[]&gt; &#123;</span></span><br><span class="line">	<span class="attr">//const</span> <span class="string">&#123; data &#125; = await createAPI(&#x27;/system/dictionary/all&#x27;, &#x27;get&#x27;, params, body)</span></span><br><span class="line">	<span class="attr">const</span> <span class="string">&#123; data &#125; = await createAPI(&#x27;/system/dictionary/all&#x27;, &#x27;get&#x27;, params, body)</span></span><br><span class="line">	<span class="attr">return</span> <span class="string">data</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在前端代码的一个固定的地方在接口地址前统一添加网关地址，每个请求统一到网关，由网关将请求转发到具体的微服务</p>
</li>
<li><p>有了网关就可以对请求进行路由，例如：可以根据请求路径路由、根据host地址路由等。当微服务有多个实例时，还可以通过负载均衡算法进行路由</p>
</li>
<li><p>此外，网关还可以实现权限控制、限流等功能</p>
</li>
<li><p>本项目采用SpringCloudGateway作为网关，网关在请求路由时，需要知道每个微服务实例的地址。</p>
</li>
<li><p>项目使用Nacos作为服务发现中心和配置中心，整体架构如下<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038249.jpeg" alt="img"></p>
</li>
<li><p>流程如下</p>
<ol>
<li>微服务启动，将自己注册到Nacos，Nacos记录了个微服务实例的地址</li>
<li>网关从Nacos读取服务列表，包括服务名称、服务地址等</li>
<li>请求到达网关，网关将请求路由到具体的微服务</li>
</ol>
</li>
<li><p>要使用网关首先搭建Nacos、Nacos有两个作用</p>
<ol>
<li>服务发现中心<ul>
<li>微服务将自身注册到Nacos，网关从Nacos获取微服务列表</li>
</ul>
</li>
<li>配置中心<ul>
<li>微服务众多，它们的配置信息也非常复杂，为了提供系统的可维护性，微服务的配置信息统一在Nacos配置</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="搭建Nacos"><a href="#搭建Nacos" class="headerlink" title="搭建Nacos"></a>搭建Nacos</h2><ul>
<li><p>在此之前我们先下载安装并启动</p>
<ul>
<li><p>拉取镜像</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">pull nacos/nacos-server:1.4.1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并运行一个容器</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run --name nacos -e MODE=standalone -p 8849:8848 -d nacos/nacos-server:1.4.1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<code>虚拟机ip:8848/nacos</code>登录，默认的账号密码均为nacos</p>
</li>
</ul>
</li>
</ul>
<h3 id="服务发现中心"><a href="#服务发现中心" class="headerlink" title="服务发现中心"></a>服务发现中心</h3><ul>
<li><p>搭建Nacos服务发现中心之前，需要搞清楚两个概念</p>
<ol>
<li>namespace：用于区分环境，例如：开发环境dev、测试环境test、生产环境prod</li>
<li>group：用于区分项目，例如xuecheng-plus、reggie项目</li>
</ol>
</li>
<li><p>首先，在Nacos配置namespace</p>
<ul>
<li>新增开发环境命名空间<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038930.png" alt="img"></li>
<li>用同样的方法新增生产环境和测试环境的命名空间</li>
</ul>
</li>
<li><p>随后将各微服务注册到Nacos</p>
<ol>
<li><p>在xuecheng-plus-parent中添加依赖管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud-alibaba.version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud-alibaba.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在xuecheng-content-api、xuecheng-plus-system中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置nacos地址</p>
<ul>
<li><p>在content-service的application.yml中配置如下信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-service</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">dev</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在system-service的application.yml中配置如下信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">system-service</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">dev</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重启这两个服务，进入Nacos中查看服务列表<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038429.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><h4 id="配置三要素"><a href="#配置三要素" class="headerlink" title="配置三要素"></a>配置三要素</h4><ul>
<li><p>搭建完Nacos服务发现中心，现在我们来搭建Nacos配置中心，其目的就是通过Nacos去管理项目中的所有配置</p>
</li>
<li><p>那么先将项目中的配置文件进行分类</p>
<ol>
<li>每个项目特有的配置<ul>
<li>是指该配置只有在某些项目中需要配置，或者该配置在每个项目中配置的值不同</li>
<li>例如spring.application.name</li>
</ul>
</li>
<li>项目所公用的配置<ul>
<li>是指一些在若干项目中配置内容相同的配置，例如redis的配置，很多项目用的同一套redis服务，所以配置也一样</li>
</ul>
</li>
</ol>
</li>
<li><p>另外，还需要知道Nacos如何去定位一个具体的配置文件，即配置三要素</p>
<ul>
<li>namespace</li>
<li>group</li>
<li>dataid</li>
</ul>
</li>
<li><p>通过namespace、group找到具体的环境和具体的项目</p>
</li>
<li><p>通过dataid找到具体的配置文件，dataid由三部分组成</p>
<ul>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-service-dev.yml</span><br></pre></td></tr></table></figure>

<p>，由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-service</span><br></pre></td></tr></table></figure>

<p>、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev</span><br></pre></td></tr></table></figure>

<p>、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yml</span><br></pre></td></tr></table></figure>

<p>三部分组成</p>
<ul>
<li><code>content-service</code>：它是在application.yml中配置的应用名，即<code>spring.application.name</code>的值</li>
<li><code>dev</code>：它是环境名，由spring.profile.active指定</li>
<li><code>yml</code>：它是配置文件的后缀</li>
</ul>
</li>
</ul>
</li>
<li><p>所以，如果我们要配置content-service工程的配置文件</p>
<ul>
<li>在开发环境中配置content-service-dev.yml</li>
<li>在生产环境中配置content-service-prod.yml</li>
<li>在测试环境中配置content-service-test.yml</li>
</ul>
</li>
</ul>
<h4 id="配置content-service"><a href="#配置content-service" class="headerlink" title="配置content-service"></a>配置content-service</h4><ul>
<li><p>下面以配置content-service为例，在开发环境下添加<code>content-service-dev.yaml</code>配置<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160043410.png" alt="img"></p>
</li>
<li><p>为什么不在nacos中配置如下内容？</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-service</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为Nacos是先根据spring.cloud.nacos.server-addr获取Nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p>
</li>
<li><p>而读取配置文件的顺序如下</p>
<ol>
<li>bootstrap.yml</li>
<li>nacos中的配置文件</li>
<li>本地application.yml</li>
</ol>
</li>
<li><p>所以我们要先在bootstrap.yml中配置文件id，然后nacos才知道怎么读取配置文件。</p>
</li>
<li><p>那么我们现在在content-service下创建bootstrap.yml</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-service</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除原本的application.yml，在content-service工程中添加依赖</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>随后运行测试方法，看看能否正产读取数据库的配置信息，并读取数据</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">@Test</span></span><br><span class="line"><span class="attr">void</span> <span class="string">contextQueryCourseTest() &#123;</span></span><br><span class="line">    <span class="attr">PageResult&lt;CourseBase&gt;</span> <span class="string">result = courseBaseInfoService.queryCourseBaseList(new PageParams(1L, 10L), new QueryCourseParamDto());</span></span><br><span class="line">    <span class="attr">log.info(&quot;查询到数据：&#123;&#125;&quot;,</span> <span class="string">result);</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="配置content-api"><a href="#配置content-api" class="headerlink" title="配置content-api"></a>配置content-api</h4><ul>
<li><p>以相同的方法配置content-api，在nacos的开发环境下新建配置<code>content-api-dev.yaml</code></p>
<ul>
<li><p>application.yml</p>
</li>
<li><p>content-api-dev.yaml</p>
</li>
<li><p>我们先来看看哪些配置可以交给Nacos管理</p>
<ul>
<li><p>原本content-api的配置如下，除了服务名，都可以交给</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-api-dev.yaml</span><br></pre></td></tr></table></figure>

<p>管理</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">servlet</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">context-path</span>: <span class="string">/content</span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">53040</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-api</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"># 日志文件配置路径</span></span><br><span class="line"><span class="attr">logging</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">config</span>: <span class="string">classpath:log4j2-dev.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># swagger 文档配置</span></span><br><span class="line"><span class="attr">swagger</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;学成在线内容管理系统&quot;</span></span><br><span class="line">  <span class="attr">description</span>: <span class="string">&quot;内容系统管理系统对课程相关信息进行业务管理数据&quot;</span></span><br><span class="line">  <span class="attr">base-package</span>: <span class="string">com.xuecheng.content</span></span><br><span class="line">  <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">version</span>: <span class="string">1.0.0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>那么我们现在就需要配置<code>content-api</code>的<code>bootstrap.yml</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#微服务配置</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-api</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">extension-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: content-service-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：因为content-api接口工程依赖了content-service工程的jar，而content-service的配置也交由nacos管理了（主要是数据库配置），所以我们现在需要extension-configs扩展配置文件的方式引用service工程的配置文件</p>
</li>
<li><p>如果需要添加多个扩展文件，继续在下面添加即可</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">extension-configs</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">-</span> <span class="string">data-id: content-service-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">    <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">    <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">    <span class="attr">-</span> <span class="string">data-id: 填写文件 dataid</span></span><br><span class="line">    <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">    <span class="attr">refresh</span>: <span class="string">true           </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="公用配置"><a href="#公用配置" class="headerlink" title="公用配置"></a>公用配置</h3><ul>
<li><p>nacos还提供了shared-configs，可以引用公用配置</p>
</li>
<li><p>我们之前在content-api中配置了swagger，并且所有接口工程都需要配置swagger</p>
</li>
<li><p>那么我们这里就可以将swagger的配置定义为一个公用配置，哪个项目需要，哪个项目就引用</p>
</li>
<li><p>接下来，我们就着手创建xuecheng-plus的公用配置，进入nacos的开发环境，添加<code>swagger-dev.yaml</code>公用配置，这里的group可以设置为<code>xuecheng-plus-common</code>，该组下的内容都作为<code>xuecheng-plus</code>的公用配置<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160044405.png" alt="img"></p>
</li>
<li><p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-api-dev.yaml</span><br></pre></td></tr></table></figure>

<p>中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swagger</span><br></pre></td></tr></table></figure>

<p>配置，在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-api</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootstrap.yml</span><br></pre></td></tr></table></figure>

<p>中使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared-config</span><br></pre></td></tr></table></figure>

<p>添加公用配置</p>
<ul>
<li>content-api-dev.yaml</li>
<li>bootstrap.yml</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line">  <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">servlet</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">context-path</span>: <span class="string">/content</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">53040</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  # 日志文件配置路径</span></span><br><span class="line">  <span class="attr">logging</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>: <span class="string">classpath:log4j2-dev.xml</span></span><br><span class="line"><span class="comment">  # swagger 文档配置</span></span><br><span class="line"><span class="attr">-</span> <span class="string">swagger:</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">title: &quot;学成在线内容管理系统&quot;</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">description: &quot;内容系统管理系统对课程相关信息进行业务管理数据&quot;</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">base-package: com.xuecheng.content</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">enabled: true</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">version: 1.0.0</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>再以相同的方法配置日志的公用配置<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160044856.png" alt="img"></p>
</li>
<li><p>删除</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">content-api-dev.yaml</span></span><br></pre></td></tr></table></figure>

<p>中的</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging</span></span><br></pre></td></tr></table></figure>

<p>配置，在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-api</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootstrap.yml</span><br></pre></td></tr></table></figure>

<p>中使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared-config</span><br></pre></td></tr></table></figure>

<p>添加公用配置</p>
<ul>
<li>content-api-dev.yaml</li>
<li>bootstrap.yml</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line">  <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">servlet</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">context-path</span>: <span class="string">/content</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">53040</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">-</span> <span class="string"># 日志文件配置路径</span></span><br><span class="line"><span class="attr">-</span> <span class="string">logging:</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">config: classpath:log4j2-dev.xml</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>那么到此为止，配置完成，重启content-api，访问swagger页面，查看swagger接口文档是否可以正常显示，查看控制台log4j2日志是否正常输出</p>
</li>
</ul>
<h3 id="系统管理配置"><a href="#系统管理配置" class="headerlink" title="系统管理配置"></a>系统管理配置</h3><ul>
<li><p>按照上面的方法，将系统管理服务的配置信息在nacos上进行配置</p>
</li>
<li><p>在开发环境下添加<code>system-service-dev.yaml</code>配置<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160044240.png" alt="img"></p>
</li>
<li><p>在system-service下创建bootstrap.yml配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">system-service</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">shared-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: logging-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在开发环境下添加<code>system-api-dev.yaml</code>配置<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038047.png" alt="img"></p>
</li>
<li><p>在system-api下创建bootstrap.yml配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#微服务配置</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">system-api</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">extension-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: system-service-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">shared-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: swagger-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: logging-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><ul>
<li><p>到目前位置，已经将所有微服务的配置统一在nacos进行配置，用到的配置文件有本地的bootstrap.yaml和nacos上的配置文件</p>
</li>
<li><p>引入配置文件的形式有</p>
<ol>
<li>通过dataid方式引入</li>
<li>以扩展配置文件方式引入</li>
<li>以公用配置文件方式引入</li>
</ol>
</li>
<li><p>各配置文件的优先级：项目应用名配置文件(content-api-dev.yaml) &gt; 扩展配置文件(content-service-dev.html) &gt; 共享配置文件(swagger-dev.yaml) &gt; 本地配置文件(application.yml)</p>
</li>
<li><p>有时候我们在测试程序时，直接在本地加一个配置进行测试，这时候我们想让本地配置优先级最高，那么可以在nacos配置文件中配置如下内容</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>: <span class="string"></span></span><br><span class="line">      <span class="attr">override-none</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="搭建Gateway"><a href="#搭建Gateway" class="headerlink" title="搭建Gateway"></a>搭建Gateway</h2><ul>
<li><p>本项目使用SpringCloudGateway作为网关，下面创建网关工程<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038397.png" alt="img"></p>
</li>
<li><p>指定父工程，添加依赖</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;?xml</span> <span class="string">version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="attr">&lt;project</span> <span class="string">xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         <span class="attr">xsi</span>:<span class="string">schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span><br><span class="line">    <span class="attr">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span><br><span class="line">    <span class="attr">&lt;!--指定父工程为xuecheng-plus-parent--&gt;</span></span><br><span class="line">    <span class="attr">&lt;parent&gt;</span></span><br><span class="line">        <span class="attr">&lt;groupId&gt;com.xuecheng&lt;/groupId&gt;</span></span><br><span class="line">        <span class="attr">&lt;artifactId&gt;xuecheng-plus-parent&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line">        <span class="attr">&lt;relativePath&gt;../xuecheng-plus-parent&lt;/relativePath&gt;</span></span><br><span class="line">    <span class="attr">&lt;/parent&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;xuecheng-plus-gateway&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="attr">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line">    <span class="attr">&lt;name&gt;xuecheng-plus-gateway&lt;/name&gt;</span></span><br><span class="line">    <span class="attr">&lt;description&gt;xuecheng-plus-gateway&lt;/description&gt;</span></span><br><span class="line">    <span class="attr">&lt;properties&gt;</span></span><br><span class="line">        <span class="attr">&lt;java.version&gt;1.8&lt;/java.version&gt;</span></span><br><span class="line">    <span class="attr">&lt;/properties&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;dependencies&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--服务发现中心--&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&lt;!--</span> <span class="string">排除 Spring Boot 依赖的日志包冲突 --&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="attr">&lt;exclusions&gt;</span></span><br><span class="line">                <span class="attr">&lt;exclusion&gt;</span></span><br><span class="line">                    <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">                    <span class="attr">&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span></span><br><span class="line">                <span class="attr">&lt;/exclusion&gt;</span></span><br><span class="line">            <span class="attr">&lt;/exclusions&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--</span> <span class="string">Spring Boot 集成 log4j2 --&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;/dependencies&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&lt;/project&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置网关的bootstrap.yml配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#微服务配置</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">shared-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: logging-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在nacos的开发环境下创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gateway-dev.yaml</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">53010 # 网关端口</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">gateway</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">routes</span>: <span class="string"></span></span><br><span class="line">        <span class="attr">-</span> <span class="string">id: content-api # 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">lb://content-api # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates</span>: <span class="string"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="attr">-</span> <span class="string">Path=/content/** # 这个是按照路径匹配，只要以/content/开头就符合要求</span></span><br><span class="line">        <span class="attr">-</span> <span class="string">id: system-api</span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">lb://system-api</span></span><br><span class="line">          <span class="attr">predicates</span>:<span class="string"></span></span><br><span class="line">            <span class="attr">-</span> <span class="string">Path=/system/**</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在http-client.env.json中配置网关的地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;localhost:53010&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content_host&quot;</span>: <span class="string">&quot;localhost:53040&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_host&quot;</span>: <span class="string">&quot;localhost:53110&quot;</span>,</span><br><span class="line">    <span class="string">&quot;media_host&quot;</span>: <span class="string">&quot;localhost:53050&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cache_host&quot;</span>: <span class="string">&quot;localhost:53035&quot;</span>,</span><br><span class="line">+   <span class="string">&quot;gateway_host&quot;</span>: <span class="string">&quot;localhost:53010&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用HTTP Client测试课程查询接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">### 课程查询列表</span><br><span class="line"><span class="variable constant_">POST</span> &#123;&#123;gateway_host&#125;&#125;/content/course/list?pageNo=<span class="number">1</span>&amp;pageSize=<span class="number">2</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;auditStatus&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;courseName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;publishStatus&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行，得到正常请求数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> <span class="attr">http</span>:<span class="comment">//localhost:53010/content/course/list?pageNo=1&amp;pageSize=2</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line">transfer-<span class="attr">encoding</span>: chunked</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Tue</span>, <span class="number">14</span> <span class="title class_">Feb</span> <span class="number">2023</span> <span class="number">10</span>:<span class="number">25</span>:<span class="number">35</span> <span class="variable constant_">GMT</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;items&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;companyId&quot;</span>: <span class="number">22</span>,</span><br><span class="line">      <span class="string">&quot;companyName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;JAVA8/9/10新特性讲解啊&quot;</span>,</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="搭建媒资工程"><a href="#搭建媒资工程" class="headerlink" title="搭建媒资工程"></a>搭建媒资工程</h2><ul>
<li><p>从课程资料中获取媒资工程xuecheng-plus-media，拷贝到项目工程根目录，修改其bootstrap中的nacos连接信息</p>
</li>
<li><p>创建媒资数据库xc_media，并导入数据库脚本</p>
</li>
<li><p>在nacos的开发环境下创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-api-dev.yaml</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-service-dev.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>media-api-dev.yaml</li>
<li>media-service-dev.yaml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /media</span><br><span class="line">  port: 53050</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h1><h2 id="什么是分布式文件系统"><a href="#什么是分布式文件系统" class="headerlink" title="什么是分布式文件系统"></a>什么是分布式文件系统</h2><ul>
<li><p>我们先来看看文件系统的定义</p>
<blockquote>
<p>文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件系统由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p>
</blockquote>
</li>
<li><p>文件系统是负责管理和存储文件和系统软件，操作系统通过文件系统提供的借口去存取文件，用户通过操作系统访问磁盘上的文件</p>
</li>
<li><p>常见的文件系统：FAT16&#x2F;FAT32、NTFS、HFS、UFS、APFS、XFS、Ext4等</p>
</li>
<li><p>现在有个问题，一些短视频平台拥有大量的视频、图片，这些视频文件、图片文件该如何存储呢？如何存储可以满足互联网上海量用户的浏览</p>
<ul>
<li>这里说的分布式文件系统就是海量用户查阅海量文件的方案</li>
</ul>
</li>
<li><p>我们再来看看分布式文件系统的定义</p>
<blockquote>
<p>分布式文件系统（Distributed File System，DFS）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点（可简单的理解为一台计算机）相连；或是若干不同的逻辑磁盘分区或卷标组合在一起而形成的完整的有层次的文件系统。DFS为分布在网络上任意位置的资源提供一个逻辑上的树形文件系统结构，从而使用户访问分布在网络上的共享文件更加简便。单独的 DFS共享文件夹的作用是相对于通过网络上的其他共享文件夹的访问点</p>
</blockquote>
</li>
<li><p>可以简单的理解为：一个计算机无法存储海量的文件，通过网络将若干计算机组织起来共同去存储海量的文件，去接收海量用户的请求，这些组织起来的计算机通过计算机网络通信<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038246.png" alt="img"></p>
</li>
<li><p>这样做的好处</p>
<ol>
<li>一台计算机的文件系统处理能力扩充到多台计算机同时处理</li>
<li>一台计算机挂了， 还有另外副本计算机提供数据</li>
<li>每台计算机可以放在不同的地域，这样用户就可以就近访问，提高访问速度</li>
</ol>
</li>
<li><p>市面上有哪些分布式文件系统的产品呢？</p>
<ol>
<li><p>NFS（Linux里讲过）</p>
<blockquote>
<p>NFS是基于UDP&#x2F;IP协议的应用，其实现主要是采用远程过程调用RPC机制，RPC提供了一组与机器、操作系统以及低层传送协议无关的存取远程文件的操作。RPC采用了XDR的支持。XDR是一种与机器无关的数据描述编码的协议，他以独立与任意机器体系结构的格式对网上传送的数据进行编码和解码，支持在异构系统之间数据的传送。</p>
<ul>
<li>特点<ul>
<li>在客户端上映射NFS服务器的驱动器</li>
<li>客户端通过万国访问NFS服务器的硬盘完全透明</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>GFS</p>
<blockquote>
<p>GFS是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，并提供容错功能。它可以给大量的用户提供总体性能较高的服务。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038639.png" alt="img"></p>
<ul>
<li>GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成</li>
<li>master存储了数据文件的元数据，一个文件被分成了若干块存储在多个chunkserver中</li>
<li>用户从master中获取数据元信息，向chunkserver存储数据</li>
</ul>
</blockquote>
</li>
<li><p>HDFS</p>
<blockquote>
<p>Hadoop分布式文件系统(HDFS)是指被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统（Distributed File System）。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS放宽了一部分POSIX约束，来实现流式读取文件系统数据的目的。HDFS在最开始是作为Apache Nutch搜索引擎项目的基础架构而开发的。HDFS是Apache Hadoop Core项目的一部分。<br>HDFS有着高容错性（fault-tolerant）的特点，并且设计用来部署在低廉的（low-cost）硬件上。而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求（requirements）这样可以实现流的形式访问（streaming access）文件系统中的数据。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160045795.png" alt="img"></p>
<ul>
<li>HDFS采用主从结构，一个HDFS集群由一个名称节点和若干数据节点组成</li>
<li>名称节点存储数据的元信息，一个完整的数据文件分成若干块存储在数据节点</li>
<li>客户端从名称节点获取数据的元信息及数据分块的信息，得到信息客户端即可从数据块来存储数据</li>
</ul>
</blockquote>
</li>
<li><p>云计算厂家</p>
<ul>
<li>阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。其数据设计持久性不低于 99.9999999999%（12 个 9），服务设计可用性（或业务连续性）不低于 99.995%。<ul>
<li>官方网站：<a target="_blank" rel="noopener" href="https://www.aliyun.com/product/oss">https://www.aliyun.com/product/oss</a></li>
</ul>
</li>
<li>百度对象存储BOS提供稳定、安全、高效、高可扩展的云存储服务。您可以将任意数量和形式的非结构化数据存入BOS，并对数据进行管理和处理。BOS支持标准、低频、冷和归档存储等多种存储类型，满足多场景的存储需求。<ul>
<li>官方网站：<a target="_blank" rel="noopener" href="https://cloud.baidu.com/product/bos.html">https://cloud.baidu.com/product/bos.html</a></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>本项目采用MinIO构建分布式文件系统，MinIO是一个非常轻量的服务，可以很简单的和其他应用结合使用。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等</p>
</li>
<li><p>它的一大特点就是轻量，使用简单、功能强大，支持各种平台，单个文件最大5TB，兼容提供了Java、Python、GO等多版本SDK支持</p>
</li>
<li><p>官网：<a target="_blank" rel="noopener" href="https://min.io/%EF%BC%8C">https://min.io/，</a></p>
</li>
<li><p>中文：<a target="_blank" rel="noopener" href="https://www.minio.org.cn/%EF%BC%8C">https://www.minio.org.cn/，</a> <a target="_blank" rel="noopener" href="http://docs.minio.org.cn/docs/">http://docs.minio.org.cn/docs/</a></p>
</li>
<li><p>MinIO键采用去中心化共享架构，每个节点是对等关系，通过Nginx可对MinIO进行负载均衡访问</p>
</li>
<li><p>去中心化有什么好处？</p>
<ul>
<li>在大数据领域，通常的设计理念都是无中心和分布式。MinIO分布式模式可以帮助你搭建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真是物理位置</li>
</ul>
</li>
<li><p>它将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式MinIO避免了单点故障<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038629.png" alt="img"></p>
</li>
<li><p>MinIO使用纠删码技术来保护数据，它是一种恢复丢失和损坏数据的数学算法，它将数据分块，冗余地分散存储在各个节点的磁盘上，所有可用的磁盘组成一个集合，上图由8块硬盘组成一个集合，当上传一个文件时，会通过纠删码算法计算对文件进行分块存储，除了将文件本身分成4个数据块，还会生成4个校验块，数据块和校验开会分散的存储在这8块硬盘上</p>
</li>
<li><p>使用纠删码的好处是即便丢失一半数量(N&#x2F;2)的硬盘，仍可以恢复数据。例如上面集合中有4个以内的硬盘损害，仍可保证数据恢复，不影响上传和下载；但如果多余一半的硬盘损坏，则无法恢复。</p>
</li>
<li><p>MinIO下载地址：<a target="_blank" rel="noopener" href="https://dl.min.io/server/minio/release/">https://dl.min.io/server/minio/release/</a></p>
</li>
<li><p>安装完毕后，CMD进入minio.exe所在目录，执行下面的命令，会在D盘创建4个目录，模拟4个硬盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minio.exe server D:\develop\minio_data\data1  D:\develop\minio_data\data2  D:\develop\minio_data\data3  D:\develop\minio_data\data4</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动结果如下<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160046236.png" alt="img"></p>
</li>
<li><p>默认账号密码均为<code>minioadmin</code>，访问<code>localhost:9000</code>进行登录</p>
</li>
<li><p>不过我们这里由于条件有限，所以先不做分布式，修改启动命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minio.exe server d:\minio_data</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后创建两个buckets</p>
<ul>
<li><code>mediafiles</code>：普通文件</li>
<li><code>video</code>：视频文件<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038678.png" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><ul>
<li><p>MinIO听歌多个语言版本SDK的支持，Java版本的文档地址：<a target="_blank" rel="noopener" href="https://docs.min.io/docs/java-client-quickstart-guide.html">https://docs.min.io/docs/java-client-quickstart-guide.html</a></p>
</li>
<li><p>最低需求Java 1.8或更高版本</p>
</li>
<li><p>在media-service工程中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从官方文档中看到，需要三个参数才能连接到minio服务</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Parameters</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Endpoint</td>
<td align="center">URL to S3 service.</td>
</tr>
<tr>
<td align="center">Access Key</td>
<td align="center">Access key (aka user ID) of an account in the S3 service.</td>
</tr>
<tr>
<td align="center">Secret Key</td>
<td align="center">Secret key (aka password) of an account in the S3 service.</td>
</tr>
</tbody></table>
<ul>
<li><p>官方文档给出的示例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.minio.BucketExistsArgs;</span><br><span class="line"><span class="keyword">import</span> io.minio.MakeBucketArgs;</span><br><span class="line"><span class="keyword">import</span> io.minio.MinioClient;</span><br><span class="line"><span class="keyword">import</span> io.minio.UploadObjectArgs;</span><br><span class="line"><span class="keyword">import</span> io.minio.errors.MinioException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.InvalidKeyException;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, InvalidKeyException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Create a minioClient with the MinIO server playground, its access key and secret key.</span></span><br><span class="line">      <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span></span><br><span class="line">          MinioClient.builder()</span><br><span class="line">              .endpoint(<span class="string">&quot;https://play.min.io&quot;</span>)</span><br><span class="line">              .credentials(<span class="string">&quot;Q3AM3UQ867SPQQA43P2F&quot;</span>, <span class="string">&quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;</span>)</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make &#x27;asiatrip&#x27; bucket if not exist.</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span></span><br><span class="line">          minioClient.bucketExists(BucketExistsArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="comment">// Make a new bucket called &#x27;asiatrip&#x27;.</span></span><br><span class="line">        minioClient.makeBucket(MakeBucketArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bucket &#x27;asiatrip&#x27; already exists.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Upload &#x27;/home/user/Photos/asiaphotos.zip&#x27; as object name &#x27;asiaphotos-2015.zip&#x27; to bucket</span></span><br><span class="line">      <span class="comment">// &#x27;asiatrip&#x27;.</span></span><br><span class="line">      minioClient.uploadObject(</span><br><span class="line">          UploadObjectArgs.builder()</span><br><span class="line">              .bucket(<span class="string">&quot;asiatrip&quot;</span>)</span><br><span class="line">              .object(<span class="string">&quot;asiaphotos-2015.zip&quot;</span>)</span><br><span class="line">              .filename(<span class="string">&quot;/home/user/Photos/asiaphotos.zip&quot;</span>)</span><br><span class="line">              .build());</span><br><span class="line">      System.out.println(</span><br><span class="line">          <span class="string">&quot;&#x27;/home/user/Photos/asiaphotos.zip&#x27; is successfully uploaded as &quot;</span></span><br><span class="line">              + <span class="string">&quot;object &#x27;asiaphotos-2015.zip&#x27; to bucket &#x27;asiatrip&#x27;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MinioException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Error occurred: &quot;</span> + e);</span><br><span class="line">      System.out.println(<span class="string">&quot;HTTP trace: &quot;</span> + e.httpTrace());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>那么我们在其基础上进行修改，完成基本的上传、下载和删除功能</p>
<ul>
<li><p>分析</p>
</li>
<li><p>修改</p>
</li>
<li><p>我们先来分析一下示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, InvalidKeyException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Create a minioClient with the MinIO server playground, its access key and secret key.</span></span><br><span class="line">      <span class="comment">// 创建MinIO客户端，连接参数就是上述表格中的三个参数，127.0.0.1:9000、minioadmin、minioadmin</span></span><br><span class="line">      <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span></span><br><span class="line">          MinioClient.builder()</span><br><span class="line">              .endpoint(<span class="string">&quot;https://play.min.io&quot;</span>)</span><br><span class="line">              .credentials(<span class="string">&quot;Q3AM3UQ867SPQQA43P2F&quot;</span>, <span class="string">&quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;</span>)</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make &#x27;asiatrip&#x27; bucket if not exist.</span></span><br><span class="line">      <span class="comment">// 由于backet我们已经手动创建了，所以这段代码可以删掉</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span></span><br><span class="line">          minioClient.bucketExists(BucketExistsArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="comment">// Make a new bucket called &#x27;asiatrip&#x27;.</span></span><br><span class="line">        minioClient.makeBucket(MakeBucketArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bucket &#x27;asiatrip&#x27; already exists.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Upload &#x27;/home/user/Photos/asiaphotos.zip&#x27; as object name &#x27;asiaphotos-2015.zip&#x27; to bucket</span></span><br><span class="line">      <span class="comment">// &#x27;asiatrip&#x27;.</span></span><br><span class="line">      <span class="comment">// 将 &#x27;/home/user/Photos/asiaphotos.zip&#x27; 文件命名为 &#x27;asiaphotos-2015.zip&#x27;</span></span><br><span class="line">      <span class="comment">// 并上传到 &#x27;asiatrip&#x27; 里（示例代码创建的bucket）</span></span><br><span class="line">      minioClient.uploadObject(</span><br><span class="line">          UploadObjectArgs.builder()</span><br><span class="line">              .bucket(<span class="string">&quot;asiatrip&quot;</span>)</span><br><span class="line">              .object(<span class="string">&quot;asiaphotos-2015.zip&quot;</span>)</span><br><span class="line">              .filename(<span class="string">&quot;/home/user/Photos/asiaphotos.zip&quot;</span>)</span><br><span class="line">              .build());</span><br><span class="line">      <span class="comment">// 这段输出也没有用，可以直接删掉</span></span><br><span class="line">      System.out.println(</span><br><span class="line">          <span class="string">&quot;&#x27;/home/user/Photos/asiaphotos.zip&#x27; is successfully uploaded as &quot;</span></span><br><span class="line">              + <span class="string">&quot;object &#x27;asiaphotos-2015.zip&#x27; to bucket &#x27;asiatrip&#x27;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MinioException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Error occurred: &quot;</span> + e);</span><br><span class="line">      System.out.println(<span class="string">&quot;HTTP trace: &quot;</span> + e.httpTrace());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>上传文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">package</span> com.xuecheng.media;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试MinIO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span></span><br><span class="line">            MinioClient.builder()</span><br><span class="line">                    .endpoint(<span class="string">&quot;http://192.168.101.65:9000&quot;</span>)</span><br><span class="line">                    .credentials(<span class="string">&quot;minioadmin&quot;</span>, <span class="string">&quot;minioadmin&quot;</span>)    <span class="comment">//accessKey和secretKey</span></span><br><span class="line">                    .build();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//上传文件</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">upload</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">UploadObjectArgs</span> <span class="variable">testbucket</span> <span class="operator">=</span> UploadObjectArgs.builder()</span><br><span class="line">                    .bucket(<span class="string">&quot;testbucket&quot;</span>)<span class="comment">//桶名</span></span><br><span class="line"><span class="comment">//                    .object(&quot;test001.mp4&quot;)</span></span><br><span class="line">                    .object(<span class="string">&quot;test/001/1.mp4&quot;</span>)<span class="comment">//对象，上传后的文件名</span></span><br><span class="line">                    .filename(<span class="string">&quot;D:\\develop\\upload\\1.mp4&quot;</span>)    <span class="comment">//待上传的本地文件路径</span></span><br><span class="line">                    .contentType(<span class="string">&quot;video/mp4&quot;</span>)<span class="comment">//默认根据扩展名确定文件内容类型，也可以指定</span></span><br><span class="line">                    .build();</span><br><span class="line">            minioClient.uploadObject(testbucket);</span><br><span class="line">            System.out.println(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>由于我们已经将桶的权限修改为了public，所以我们直接访问<a target="_blank" rel="noopener" href="http://127.0.0.1:9000/testbucket/pic01.png%EF%BC%8C">http://127.0.0.1:9000/testbucket/pic01.png，</a> 也是可以直接看到上传的图片的</p>
<p><strong>启动测试</strong> </p>
<p><strong>执行upload方法</strong>，分别测试向桶的根目录上传文件以及子目录上传文件。</p>
<p>上传成功，通过web控制台刷新查看文件，并预览文件。</p>
<p><strong>说明：</strong></p>
<p><strong>设置contentType</strong>可以通过com.j256.simplemagic.ContentType枚举类查看常用的mimeType<strong>（媒体类型）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/e2665347120d4bf1a4eb2346b4f2469d.png" alt="img"></p>
<p> <strong>通过扩展名（如.mp4）得到媒体类型mimeType：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">//根据扩展名取出mimeType</span></span><br><span class="line"><span class="type">ContentInfo</span> <span class="variable">extensionMatch</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(<span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> MediaType.APPLICATION_OCTET_STREAM_VALUE;<span class="comment">//通用mimeType，字节流</span></span><br></pre></td></tr></table></figure>

<p>通过扩展名得到媒体类型mimeType，完善上边的代码 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">upload</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//根据扩展名取出mimeType</span></span><br><span class="line">        <span class="type">ContentInfo</span> <span class="variable">extensionMatch</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(<span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> MediaType.APPLICATION_OCTET_STREAM_VALUE;<span class="comment">//通用mimeType，字节流</span></span><br><span class="line">        <span class="keyword">if</span>(extensionMatch!=<span class="literal">null</span>)&#123;</span><br><span class="line">            mimeType = extensionMatch.getMimeType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">UploadObjectArgs</span> <span class="variable">testbucket</span> <span class="operator">=</span> UploadObjectArgs.builder()</span><br><span class="line">                    .bucket(<span class="string">&quot;testbucket&quot;</span>)</span><br><span class="line"><span class="comment">//                    .object(&quot;test001.mp4&quot;)</span></span><br><span class="line">                    .object(<span class="string">&quot;001/test001.mp4&quot;</span>)<span class="comment">//添加子目录</span></span><br><span class="line">                    .filename(<span class="string">&quot;D:\\develop\\upload\\1mp4.temp&quot;</span>)</span><br><span class="line">                    .contentType(mimeType)<span class="comment">//默认根据扩展名确定文件内容类型，也可以指定</span></span><br><span class="line">                    .build();</span><br><span class="line">            minioClient.uploadObject(testbucket);</span><br><span class="line">            System.out.println(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><ul>
<li><p>编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        minioClient.removeObject(RemoveObjectArgs</span><br><span class="line">                .builder()</span><br><span class="line">                .bucket(<span class="string">&quot;testbucket&quot;</span>)</span><br><span class="line">                .object(<span class="string">&quot;pic01.png&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="查询文件"><a href="#查询文件" class="headerlink" title="查询文件"></a>查询文件</h4><ul>
<li><p>编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFileTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;testbucket&quot;</span>)</span><br><span class="line">                .object(<span class="string">&quot;pic01.png&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\15863\\Desktop\\tmp.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;下载成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下载失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用IOUtils简化代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFileTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;testbucket&quot;</span>)</span><br><span class="line">                .object(<span class="string">&quot;pic01.png&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\15863\\Desktop\\tmp.png&quot;</span>);</span><br><span class="line">        IOUtils.copy(inputStream,fileOutputStream);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下载失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>校验文件的完整性：</strong></p>
<p>对文件计算出md5值，比较原始文件的md5和目标文件的md5，一致则说明完整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//校验文件的完整性对文件的内容进行md5</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\develop\\upload\\1.mp4&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">source_md5</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream1);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\develop\\upload\\1a.mp4&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">local_md5</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line"><span class="keyword">if</span>(source_md5.equals(local_md5))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;下载成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="上传图片-1"><a href="#上传图片-1" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="业务流程-1"><a href="#业务流程-1" class="headerlink" title="业务流程"></a>业务流程</h3><ul>
<li>我们在新增课程的时候，需要上传课程图片</li>
<li>课程图片上传至分布式文件系统，在课程信息中保存课程图片路径，流程如下</li>
</ul>
<ol>
<li>前端进入上传图片界面</li>
<li>上传图片，请求媒资管理服务</li>
<li>媒资管理服务将图片文件存储在MinIO</li>
<li>媒资管理记录文件信息到数据库</li>
<li>保存课程信息，在内容管理数据库保存图片地址</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038643.png" alt="img"></p>
<ul>
<li>媒资管理服务由接口层和业务层共同完成，具体分工如下<ul>
<li>用户上传图片请求至媒资管理的接口层，接口层解析文件信息，通过业务层将文件保存至minio和数据库</li>
</ul>
</li>
</ul>
<h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>涉及到的数据表主要是媒资信息<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/pSHc4bR.png" alt="img"></li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li><p>在minio中配置bucket，创建一个名为mediafiles的bucket，并将其权限设置为public</p>
</li>
<li><p>在nacos中配置minio的相关信息，在nacos的开发环境下新增配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-service-dev.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//127.0.0.1:3306/xc_media?serverTimezone=UTC&amp;userUnicode=true&amp;useSSL=false</span></span><br><span class="line">    username: root</span><br><span class="line">    password: A10ne,tillde<span class="meta">@th</span>.</span><br><span class="line">  cloud:</span><br><span class="line">   config:</span><br><span class="line">    override-none: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">minio:</span><br><span class="line">  endpoint: http:<span class="comment">//127.0.0.1:9000</span></span><br><span class="line">  accessKey: minioadmin</span><br><span class="line">  secretKey: minioadmin</span><br><span class="line">  bucket:</span><br><span class="line">    files: mediafiles</span><br><span class="line">    videofiles: video</span><br></pre></td></tr></table></figure>
</li>
<li><p>在media-service工程下配置bootstrap.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: media-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8848</span></span><br><span class="line">      discovery:</span><br><span class="line">        namespace: $&#123;spring.profiles.active&#125;</span><br><span class="line">        group: xuecheng-plus-project</span><br><span class="line">      config:</span><br><span class="line">        namespace: $&#123;spring.profiles.active&#125;</span><br><span class="line">        group: xuecheng-plus-project</span><br><span class="line">        file-extension: yaml</span><br><span class="line">        refresh-enabled: <span class="literal">true</span></span><br><span class="line">      shared-configs:</span><br><span class="line">        - data-id: logging-$&#123;spring.profiles.active&#125;.yaml</span><br><span class="line">          group: xuecheng-plus-common</span><br><span class="line">          refresh: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">#profiles默认为dev</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在media-service工程下编写minio的配置类</p>
<ul>
<li><p>该配置类中药根据yaml中的minio配置信息，创建一个MinioClient对象，并声明为bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.accessKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.secretKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MinioClient <span class="title function_">minioClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MinioClient.builder().</span><br><span class="line">                endpoint(endpoint).</span><br><span class="line">                credentials(accessKey, secretKey).</span><br><span class="line">                build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><ul>
<li><p>根据需求分析，下面进行接口定义。</p>
</li>
<li><p>此接口定义为一个通用的上传文件的接口，可以上传图片或其他文件</p>
</li>
<li><p>首先分析接口</p>
<ul>
<li><p>请求地址：&#x2F;media&#x2F;upload&#x2F;coursefile</p>
</li>
<li><p>请求参数：Content-Type: multipart&#x2F;form-data;boundary&#x3D;….. FormData: filedata&#x3D;??, folder&#x3D;?, objectName&#x3D;?</p>
</li>
<li><p>响应参数：文件信息，如下，其内容与media_files表中的字段完全一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>: <span class="string">&quot;a16da7a132559daf9e1193166b3e7f52&quot;</span>,</span><br><span class="line"><span class="string">&quot;companyId&quot;</span>: <span class="number">1232141425</span>,</span><br><span class="line"><span class="string">&quot;companyName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;filename&quot;</span>: <span class="string">&quot;1.jpg&quot;</span>,</span><br><span class="line"><span class="string">&quot;fileType&quot;</span>: <span class="string">&quot;001001&quot;</span>,</span><br><span class="line"><span class="string">&quot;tags&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;bucket&quot;</span>: <span class="string">&quot;/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg&quot;</span>,</span><br><span class="line"><span class="string">&quot;fileId&quot;</span>: <span class="string">&quot;a16da7a132559daf9e1193166b3e7f52&quot;</span>,</span><br><span class="line"><span class="string">&quot;url&quot;</span>: <span class="string">&quot;/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg&quot;</span>,</span><br><span class="line"><span class="string">&quot;timelength&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;createDate&quot;</span>: <span class="string">&quot;2022-09-12T21:57:18&quot;</span>,</span><br><span class="line"><span class="string">&quot;changeDate&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;status&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="string">&quot;remark&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;auditStatus&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;auditMind&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;fileSize&quot;</span>: <span class="number">248329</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>定义模型类，虽然响应结果与MediaFiles表中的字段完全一致，但最好不要直接用MediaFiles类。因为该类属于PO类，如果后期我们要对响应结果进行修改，那么模型类也需要进行修改，但是MediaFiles是PO类，我们不能动。所以可以直接用一个类继承MediaFiles，里面什么属性都不用加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadFileResultDto</span> <span class="keyword">extends</span> <span class="title class_">MediaFiles</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义接口，其中folder和objectName这两个参数不一定传，所以将其required设为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;上传文件&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/upload/coursefile&quot;,consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> UploadFileResultDto <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile upload,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;folder&quot;, required = false)</span> String folder,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;objectName&quot;, required = false)</span> String objectName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口开发"><a href="#接口开发" class="headerlink" title="接口开发"></a>接口开发</h2><h3 id="DAO开发"><a href="#DAO开发" class="headerlink" title="DAO开发"></a>DAO开发</h3><ul>
<li>根据需求分析，DAO层实现向media_file表中插入一条记录，使用media_files表生成的mapper即可</li>
</ul>
<h3 id="Service开发"><a href="#Service开发" class="headerlink" title="Service开发"></a>Service开发</h3><ul>
<li><p>Service方法需要听歌一个更加通用的保存文件的方法</p>
</li>
<li><p>定义请求参数类，上传文件，我们需要文件名称、文件的content-type、文件类型（文档、视频、图片等，对应数据字典表中的类型）、文件大小、标签、上传人、备注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Data</span></span><br><span class="line"> <span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadFileParamsDto</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件名称</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件content-type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> String contentType;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件类型（文档，图片，视频）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String fileType;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> Long fileSize;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 标签</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String tags;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 上传人</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 备注</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String remark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义service方法，MultipartFile是SpringMVC提供简化上传操作的工具类，不使用框架之前，都是使用原生的HttpServletRequest来接收上传的数据,文件是以二进制流传递到后端的。为了使接口更通用，我们可以用字节数组代替MultpartFile类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 上传文件的通用接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uploadFileParamsDto 文件信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes               文件字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> folder              桶下边的子目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.xuecheng.media.model.dto.UploadFileResultDto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UploadFileResultDto <span class="title function_">uploadFile</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, <span class="type">byte</span>[] bytes, String folder, String objectName)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现方法如下，主要分为两部分</p>
<ol>
<li>将文件上传到minio</li>
<li>将文件信息写入media_file表中</li>
</ol>
</li>
<li><p>完整方法</p>
</li>
<li><p>将文件上传到minio</p>
</li>
<li><p>前面我们上传文件是用的uploadObject方法，是从本地磁盘上传文件，为了使方法更通用，这里使用putObject</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">putObject和uploadObject方法都是上传文件至云存储的方法，但是有些许差别。</span><br><span class="line"></span><br><span class="line">putObject方法是直接把文件上传至云存储，具体操作为：</span><br><span class="line"></span><br><span class="line">1. 打开待存储文件；</span><br><span class="line">2. 建立连接；</span><br><span class="line">3. 上传文件；</span><br><span class="line">4. 关闭连接。</span><br><span class="line"></span><br><span class="line">putObject方法适合上传小文件，上传速度快，但如果要上传大文件，该方法会消耗较多的系统资源，可能会导致系统卡顿或崩溃。</span><br><span class="line"></span><br><span class="line">uploadObject方法是把文件拆成多个固定大小的分片进行上传，具体操作为：</span><br><span class="line"></span><br><span class="line">1. 打开待存储文件；</span><br><span class="line">2. 建立连接；</span><br><span class="line">3. 计算文件大小，将文件分成多个固定大小的分片；</span><br><span class="line">4. 依次上传每个分片，可同时上传多个分片，提高上传效率；</span><br><span class="line">5. 合并多个分片，形成完整的文件；</span><br><span class="line">6. 关闭连接。</span><br><span class="line"></span><br><span class="line">uploadObject方法适合上传大文件，可分片上传，上传速度较快，且可控制上传进度和暂停继续上传。但是该方法会增加代码复杂度，需要开发者自行处理分片上传和合并分片的逻辑。</span><br><span class="line"></span><br><span class="line">总的来说，如果要上传小文件，建议使用putObject方法进行上传；如果要上传大文件，建议使用uploadObject方法，提高上传效率。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MediaFilesMapper mediaFilesMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MinioClient minioClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;minio.bucket.files&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String bucket_files;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uploadFileParamsDto 文件信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes               文件字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> folder              桶下边的子目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> UploadFileResultDto <span class="title function_">uploadFile</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, <span class="type">byte</span>[] bytes, String folder, String objectName)</span> &#123;</span><br><span class="line">    <span class="comment">// 上传图片文件使用putObject</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileMD5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(bytes);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(folder)) &#123;</span><br><span class="line">        <span class="comment">// 文件目录不存在，自动生成目录</span></span><br><span class="line">        folder = getFileFolder(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!folder.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果目录末尾没有 / ,则添加/</span></span><br><span class="line">        folder = folder + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断文件名</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(objectName)) &#123;</span><br><span class="line">        <span class="comment">// 如果文件名为空，则设置其默认文件名为文件的md5码 + 文件后缀名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">        objectName = fileMD5 + filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件存储地址</span></span><br><span class="line">    objectName = folder + objectName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.上传到minio</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">                .bucket(bucket_files)</span><br><span class="line">                .object(objectName)     <span class="comment">// 存储桶里的对象名称。</span></span><br><span class="line">                .stream(inputStream, inputStream.available(), -<span class="number">1</span>) <span class="comment">// 要上传的流、大小</span></span><br><span class="line">                .contentType(uploadFileParamsDto.getContentType())</span><br><span class="line">                .build();</span><br><span class="line">        minioClient.putObject(putObjectArgs);</span><br><span class="line">        <span class="comment">// 2.保持到数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(fileMD5);</span><br><span class="line">        <span class="keyword">if</span> (mediaFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            mediaFile = <span class="keyword">new</span> <span class="title class_">MediaFiles</span>();</span><br><span class="line">            BeanUtils.copyProperties(uploadFileParamsDto, mediaFile);</span><br><span class="line">            mediaFile.setId(fileMD5);</span><br><span class="line">            mediaFile.setFileId(fileMD5);</span><br><span class="line">            mediaFile.setCompanyId(companyId);</span><br><span class="line">            mediaFile.setBucket(bucket_files);</span><br><span class="line">            mediaFile.setCreateDate(LocalDateTime.now());</span><br><span class="line">            mediaFile.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            mediaFile.setFilePath(objectName);</span><br><span class="line">            mediaFile.setUrl(<span class="string">&quot;/&quot;</span> + bucket_files + <span class="string">&quot;/&quot;</span> + objectName);</span><br><span class="line">            <span class="comment">// 查阅数据字典，002003表示审核通过</span></span><br><span class="line">            mediaFile.setAuditStatus(<span class="string">&quot;002003&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> <span class="built_in">this</span>.save(mediaFile);</span><br><span class="line">        <span class="keyword">if</span> (!save) &#123;</span><br><span class="line">            XcPlusException.cast(<span class="string">&quot;保存文件信息失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UploadFileResultDto</span> <span class="variable">resultDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileResultDto</span>();</span><br><span class="line">        BeanUtils.copyProperties(mediaFile, resultDto);</span><br><span class="line">        <span class="keyword">return</span> resultDto;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;上传过程中出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动生成目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> year  是否包含年</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> month 是否包含月</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> day   是否包含日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFileFolder</span><span class="params">(<span class="type">boolean</span> year, <span class="type">boolean</span> month, <span class="type">boolean</span> day)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    String[] split = dateString.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (year) &#123;</span><br><span class="line">        stringBuffer.append(split[<span class="number">0</span>]).append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (month) &#123;</span><br><span class="line">        stringBuffer.append(split[<span class="number">1</span>]).append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (day) &#123;</span><br><span class="line">        stringBuffer.append(split[<span class="number">2</span>]).append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件默认存储目录路径 年/月/日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFileFolder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()).replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="完善Controller"><a href="#完善Controller" class="headerlink" title="完善Controller"></a>完善Controller</h3><ul>
<li><p>完善接口层代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;上传文件&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/upload/coursefile&quot;,consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> UploadFileResultDto <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile upload,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@RequestParam(value = &quot;folder&quot;, required = false)</span> String folder,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@RequestParam(value = &quot;objectName&quot;, required = false)</span> String objectName)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> <span class="number">1232141425L</span>;</span><br><span class="line">        <span class="comment">// 构建接受请求类</span></span><br><span class="line">        <span class="type">UploadFileParamsDto</span> <span class="variable">uploadFileParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileParamsDto</span>();</span><br><span class="line">        <span class="comment">//文件大小</span></span><br><span class="line">        uploadFileParams.setFileSize(upload.getSize());</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> upload.getContentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType.contains(<span class="string">&quot;image&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//图片</span></span><br><span class="line">            uploadFileParams.setFileType(<span class="string">&quot;001001&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他</span></span><br><span class="line">            uploadFileParams.setFileType(<span class="string">&quot;001003&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件名称</span></span><br><span class="line">        uploadFileParams.setFilename(upload.getOriginalFilename());</span><br><span class="line">        <span class="comment">//文件类型</span></span><br><span class="line">        uploadFileParams.setContentType(upload.getContentType());</span><br><span class="line">        <span class="comment">//文件字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bytes = upload.getBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            XcPlusException.cast(<span class="string">&quot;获取文件字节数组失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.uploadFile(companyId, uploadFileParams, bytes, folder, objectName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用HTTP Client测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">### 上传文件</span><br><span class="line">POST &#123;&#123;media_host&#125;&#125;/media/upload/coursefile</span><br><span class="line">Content-Type: multipart/form-data; boundary=WebAppBoundary</span><br><span class="line"></span><br><span class="line">--WebAppBoundary</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;filedata&quot;</span>; filename=<span class="string">&quot;test01.jpg&quot;</span></span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt; C:\Users\kyle\Desktop\Picture\photo\bg01.jpg</span><br><span class="line"></span><br><span class="line"># 响应结果如下</span><br><span class="line">POST http:<span class="comment">//localhost:53050/media/upload/coursefile</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> </span><br><span class="line">Content-Type: application/json</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, <span class="number">16</span> Feb <span class="number">2023</span> 09:<span class="number">57</span>:<span class="number">48</span> GMT</span><br><span class="line">Keep-Alive: timeout=<span class="number">60</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;632fb34166d91865da576032b9330ced&quot;</span>,</span><br><span class="line">  <span class="string">&quot;companyId&quot;</span>: <span class="number">1232141425</span>,</span><br><span class="line">  <span class="string">&quot;companyName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;test01.jpg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fileType&quot;</span>: <span class="string">&quot;001003&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;bucket&quot;</span>: <span class="string">&quot;mediafiles&quot;</span>,</span><br><span class="line">  <span class="string">&quot;filePath&quot;</span>: <span class="string">&quot;2023/57/16/632fb34166d91865da576032b9330ced.jpg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fileId&quot;</span>: <span class="string">&quot;632fb34166d91865da576032b9330ced&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/mediafiles/2023/57/16/632fb34166d91865da576032b9330ced.jpg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;createDate&quot;</span>: <span class="string">&quot;2023-02-16 17:57:48&quot;</span>,</span><br><span class="line">  <span class="string">&quot;changeDate&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remark&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;auditStatus&quot;</span>: <span class="string">&quot;002003&quot;</span>,</span><br><span class="line">  <span class="string">&quot;auditMind&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;fileSize&quot;</span>: <span class="number">22543</span></span><br><span class="line">&#125;</span><br><span class="line">响应文件已保存。</span><br><span class="line">&gt; <span class="number">2023</span>-<span class="number">02</span>-16T175748<span class="number">.200</span>.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>在对应的bucket中也可以查看到上传的图片</p>
</li>
</ul>
<h3 id="Service代码优化"><a href="#Service代码优化" class="headerlink" title="Service代码优化"></a>Service代码优化</h3><ul>
<li><p>在上传文件的方法中包括两部分</p>
<ol>
<li>向MinIO存储文件</li>
<li>向数据库存储文件信息</li>
</ol>
</li>
<li><p>下面将这两部分抽取出来，后期可供其他Service方法调用</p>
</li>
<li><p>为了跟方便的获取content-type，我们可以添加simplemagic依赖，它提供的方法可以根据文件扩展名，得到资源的content-type</p>
</li>
<li><p>在base工程中添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.j256.simplemagic&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;simplemagic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.17</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可通过如下代码得到资源的content-type</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ContentInfo</span> <span class="variable">extensionMatch</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(扩展名);</span><br><span class="line"><span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> extensionMatch.getMimeType();</span><br></pre></td></tr></table></figure>
</li>
<li><p>IDEA中使用</p>
<p>Ctrl+Alt+M</p>
<p>可以快速重构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> UploadFileResultDto <span class="title function_">uploadFile</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, <span class="type">byte</span>[] bytes, String folder, String objectName)</span> &#123;</span><br><span class="line">    <span class="comment">// 上传图片文件使用putObject</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileMD5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(bytes);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(folder)) &#123;</span><br><span class="line">        <span class="comment">// 文件目录不存在，自动生成目录</span></span><br><span class="line">        folder = getFileFolder(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!folder.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果目录末尾没有 / ,则添加/</span></span><br><span class="line">        folder = folder + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断文件名</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(objectName)) &#123;</span><br><span class="line">        <span class="comment">// 如果文件名为空，则设置其默认文件名为文件的md5码 + 文件后缀名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">        objectName = fileMD5 + filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件存储地址</span></span><br><span class="line">    objectName = folder + objectName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.上传文件到minio</span></span><br><span class="line">        uploadFileToMinio(bytes, objectName, bucket_files);</span><br><span class="line">        <span class="comment">// 2.保持到数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> saveFileToDB(companyId, uploadFileParamsDto, objectName, fileMD5, bucket_files);</span><br><span class="line">        <span class="comment">// 3.封装返回数据</span></span><br><span class="line">        <span class="type">UploadFileResultDto</span> <span class="variable">resultDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileResultDto</span>();</span><br><span class="line">        BeanUtils.copyProperties(mediaFile, resultDto);</span><br><span class="line">        <span class="keyword">return</span> resultDto;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;上传过程中出错&quot;</span>, e.getMessage());</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;上传过程中出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>上传文件到minio方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传文件到minio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 文件字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName 存储桶里的对象名称。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket 桶对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">uploadFileToMinio</span><span class="params">(<span class="type">byte</span>[] bytes, String objectName, String bucket)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认contentType为未知二进制流</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> MediaType.APPLICATION_OCTET_STREAM_VALUE;</span><br><span class="line">    <span class="comment">// 判断对象名是否包含 .</span></span><br><span class="line">    <span class="keyword">if</span> (objectName.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 有,则划分出扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> objectName.substring(objectName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">// 根据扩展名得到contentType，如果为未知扩展名，例如 .abc之类的东西，则会返回null</span></span><br><span class="line">        <span class="type">ContentInfo</span> <span class="variable">extensionInfo</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(extension);</span><br><span class="line">        <span class="keyword">if</span> (extensionInfo!= <span class="literal">null</span>) &#123;</span><br><span class="line">            contentType = extensionInfo.getMimeType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.上传到minio</span></span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">    <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">            .bucket(bucket)</span><br><span class="line">            .object(objectName)     <span class="comment">// 存储桶里的对象名称。</span></span><br><span class="line">            .stream(inputStream, inputStream.available(), -<span class="number">1</span>) <span class="comment">// 要上传的流、大小</span></span><br><span class="line">            .contentType(contentType)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        minioClient.putObject(putObjectArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;上传到文件系统出错:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;上传到文件系统出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>保存到数据库方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	</p>
<ul>
<li><p>优化后使用HTTP Client进行测试</p>
</li>
<li><p>同时，根据文件扩展名获取content-type的方法可以进一步抽取，可以在base工程中创建一个工具类，供其他微服务使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getContentType</span><span class="params">(String objectName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> MediaType.APPLICATION_OCTET_STREAM_VALUE; <span class="comment">// 默认content-type为未知二进制流</span></span><br><span class="line">    <span class="keyword">if</span> (objectName.indexOf(<span class="string">&quot;.&quot;</span>) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 判断对象名是否包含 .</span></span><br><span class="line">        <span class="comment">// 有 .  则划分出扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> objectName.substring(objectName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">// 根据扩展名得到content-type，如果为未知扩展名，例如 .abc之类的东西，则会返回null</span></span><br><span class="line">        <span class="type">ContentInfo</span> <span class="variable">extensionMatch</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(extension);</span><br><span class="line">        <span class="comment">// 如果得到了正常的content-type，则重新赋值，覆盖默认类型</span></span><br><span class="line">        <span class="keyword">if</span> (extensionMatch != <span class="literal">null</span>) &#123;</span><br><span class="line">            contentType = extensionMatch.getMimeType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contentType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Service事务优化"><a href="#Service事务优化" class="headerlink" title="Service事务优化"></a>Service事务优化</h3><ul>
<li><p>我们现在思考一下，updateFile方法是否应该开启事务</p>
</li>
<li><p>目前如果在updateFile方法上添加<code>@Transactional</code>，当调用updateFile方法前会开启数据库事务，如果上传文件过程时间较长（例如用户在上传超大视频文件），那么数据库的食物持续时间也会变长（因为在updateFile方法中，我们即要将文件上传到minio，又要将文件信息写入数据库），这样数据库连接释放就慢，最终导致数据库链接不够用</p>
</li>
<li><p>那么解决办法也显而易见，那就是只在<code>addMediaFilesToDB</code>方法上添加事务控制即可，同时将uploadFile方法上的<code>@Transactional</code>注解去掉</p>
</li>
<li><p>但事情并不是那么简单，首先我们来看一下Spring的事务控制</p>
</li>
<li><p>判断方法能否被事务控制</p>
<ol>
<li>是不是通过代理对象调用的方法</li>
<li>该方法上是否添加了<code>@Transactional</code>注解</li>
</ol>
</li>
<li><p>现在只满足了添加事务注解，那么如何判断是不是通过代理对象调用的方法呢？</p>
<ul>
<li>我们可以打个断点看一下</li>
</ul>
</li>
<li><p>当我们在一个不能被事务控制的方法里（uploadFile），调用一个被事务控制的方法（addMediaFilesToDB），那么该方法（addMediaFilesToDB）也不会被事务控制</p>
</li>
<li><p>那么如何解决呢？</p>
<ul>
<li>我们需要通过代理对象去调用addMediaFilesToDB方法</li>
</ul>
</li>
<li><p>在MediaFileService的实现类中注入MediaFileService的代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">MediaFileService currentProxy;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将addMediaFilesToDB方法提取成接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将文件信息添加到文件表</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> uploadFileParamsDto 上传文件的信息</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> fileMD5             文件md5码</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> bucket              桶</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> MediaFiles <span class="title function_">addMediaFilesToDB</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过代理对象调用addMediaFilesToDB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> currentProxy.addMediaFilesToDB(companyId, uploadFileParamsDto, objectName, fileMD5, bucket_files);</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次测试事务是否可以正常控制</p>
<ul>
<li>打断点看到这次是代理对象调用的方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038179.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h2><ul>
<li><p>修改前段的图片服务器地址为自己的minio地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 图片服务器地址</span><br><span class="line">VUE_APP_SERVER_PICSERVER_URL=http://127.0.0.1:9000</span><br></pre></td></tr></table></figure>
</li>
<li><p>在新增课程、编辑课程界面上传图片，保存课程信息后再次进入编辑课程界面，查看是否可以正常保存图片信息<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038599.png" alt="img"></p>
</li>
<li><p>上传图片完成后，进入媒资管理，查看文件列表中是否有刚刚上传的图片信息<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038690.png" alt="img"></p>
</li>
</ul>
<h2 id="bug修复"><a href="#bug修复" class="headerlink" title="bug修复"></a>bug修复</h2><ul>
<li><p>在媒资列表可以查看到刚刚上传的图片信息，但是通过条件查询不起作用</p>
</li>
<li><p>原因：没有使用查询条件</p>
</li>
<li><p>解决：修改MediaFileServiceImpl中的queryMediaFiles方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PageResult&lt;MediaFiles&gt; <span class="title function_">queryMediaFiles</span><span class="params">(Long companyId, PageParams pageParams, QueryMediaParamsDto queryMediaParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建查询条件对象</span></span><br><span class="line">        LambdaQueryWrapper&lt;MediaFiles&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">+       queryWrapper.like(!StringUtils.isEmpty(queryMediaParamsDto.getFilename()), MediaFiles::getFilename, queryMediaParamsDto.getFilename());</span><br><span class="line">+       queryWrapper.eq(!StringUtils.isEmpty(queryMediaParamsDto.getFileType()), MediaFiles::getFileType, queryMediaParamsDto.getFileType());</span><br><span class="line">        <span class="comment">//分页对象</span></span><br><span class="line">        Page&lt;MediaFiles&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">        <span class="comment">// 查询数据内容获得结果</span></span><br><span class="line">        Page&lt;MediaFiles&gt; pageResult = mediaFilesMapper.selectPage(page, queryWrapper);</span><br><span class="line">        <span class="comment">// 获取数据列表</span></span><br><span class="line">        List&lt;MediaFiles&gt; list = pageResult.getRecords();</span><br><span class="line">        <span class="comment">// 获取数据总数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> pageResult.getTotal();</span><br><span class="line">        <span class="comment">// 构建结果集</span></span><br><span class="line">        PageResult&lt;MediaFiles&gt; mediaListResult = <span class="keyword">new</span> <span class="title class_">PageResult</span>&lt;&gt;(list, total, pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">        <span class="keyword">return</span> mediaListResult;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启服务，测试是否能正常查询<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038415.png" alt="img"></p>
</li>
</ul>
<h1 id="上传视频-1"><a href="#上传视频-1" class="headerlink" title="上传视频"></a>上传视频</h1><h2 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>教学机构人员进入媒资管理列表查询自己上传的媒资文件</li>
<li>教育机构人员在<code>媒资管理</code>页面中点击<code>上传视频</code>按钮，打开上传界面</li>
<li>选择要上传的文件，自动执行文件上传</li>
<li>视频上传成功会自动处理，处理完成后可以预览视频</li>
</ol>
<h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><h3 id="什么是断点续传"><a href="#什么是断点续传" class="headerlink" title="什么是断点续传"></a>什么是断点续传</h3><ul>
<li>通常视频文件都比较大，所以对于媒资系统上传文件的需求要满足大文件的上传需求。HTTP协议本身对上传文件大小没有限制，但是客户的网络环境之类、电脑硬件环境等参差不齐，如果一个大文件快上传完了，但是突然断网了，没有上传完成，需要客户重新上传，那么用户体验就非常差。所以对于大文件上传的最基本要求就是断点续传</li>
<li>流程如下<ol>
<li>前端上传前先把文件分成块</li>
<li>一块一块的上传，上传中断后重新上传。已上传的分块则不用再上传</li>
<li>各分块上传完成后，在服务端合并文件</li>
</ol>
</li>
</ul>
<h3 id="分块与合并测试"><a href="#分块与合并测试" class="headerlink" title="分块与合并测试"></a>分块与合并测试</h3><ul>
<li><p>为了更好的理解文件分块上传的原理，下面用Java代码测试文件的分块与合并</p>
</li>
<li><p>文件分块的流程如下</p>
<ol>
<li>获取源文件长度</li>
<li>根据设定的分块文件大小，计算出块数（向上取整，例如33.4M的文件，块大小为1M，则需要34块）</li>
<li>从源文件读取数据，并依次向每一个块文件写数据</li>
</ol>
</li>
<li><p>文件分块测试代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大文件断点续传  objectUpload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bigFileUploadTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 源文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\adan\\Videos\\lb2.MP4&quot;</span>);</span><br><span class="line">    <span class="comment">// 块文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\projects\\xc-plus-font-end\\testFile\\chunk\\&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">chunkFolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(chunkPath);</span><br><span class="line">    <span class="keyword">if</span> (!chunkFolder.exists()) &#123;</span><br><span class="line">        <span class="comment">// 如果文件夹不存在，则创建文件夹</span></span><br><span class="line">        chunkFolder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置分块大小（分块文件个数。Math.ceil是向上取整）5M</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">chunkSize</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 计算块数，向上取整</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">chunkNum</span> <span class="operator">=</span> (<span class="type">long</span>) Math.ceil(sourceFile.length() * <span class="number">1.0</span> / chunkSize);</span><br><span class="line">    <span class="comment">// 缓冲区大小</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 使用RandomAccessFile访问文件</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf_read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(sourceFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历分块，依次向每一个分块写入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chunkNum; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建分块文件，默认文件名 path + i，例如chunk\1  chunk\2</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(chunkPath + i);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">        <span class="keyword">if</span> (newFile) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">raf_write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            <span class="comment">// 向分块文件写入数据，每次写满一个字节数组</span></span><br><span class="line">            <span class="keyword">while</span> ((len = raf_read.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                raf_write.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                <span class="comment">// 当分块大小超过5m时停止在这一块写数据。不加这句的话会出现第一块大小和源文件一样，其余块大小都为0</span></span><br><span class="line">                <span class="keyword">if</span> (file.length() &gt;= chunkSize)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            raf_write.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raf_read.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;写入分块完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件合并流程</p>
<ol>
<li>找到要合并的文件并按文件分块的先后顺序排序</li>
<li>创建合并文件</li>
<li>依次从合并的文件中读取数据冰箱合并文件写入数据</li>
</ol>
</li>
<li><p>文件合并的测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大文件合并测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bigFileMergeTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 块文件目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">chunkFolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\projects\\xc-plus-font-end\\testFile\\chunk&quot;</span>);</span><br><span class="line">    <span class="comment">// 源文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\adan\\Videos\\lb2.MP4&quot;</span>);</span><br><span class="line">    <span class="comment">// 合并后的文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">mergeFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\adan\\Videos\\lb2-1.MP4&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.取出所有分块文件</span></span><br><span class="line">    File[] files = chunkFolder.listFiles();</span><br><span class="line">    <span class="comment">//2.将数组转成list，以便于排序</span></span><br><span class="line">    List&lt;File&gt; fileList = Arrays.asList(files);</span><br><span class="line">    <span class="comment">//3.对分块文件排序</span></span><br><span class="line">    fileList.sort(Comparator.comparingInt(o -&gt; Integer.parseInt(o.getName())));</span><br><span class="line">    <span class="comment">//向合并文件写的流</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf_rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(mergeFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">//缓存区</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span> (File file : fileList) &#123;</span><br><span class="line">        <span class="comment">//读分块的流</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf_r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf_r.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf_rw.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        raf_r.close();</span><br><span class="line">    &#125;</span><br><span class="line">    raf_rw.close();</span><br><span class="line">    <span class="comment">// 判断合并后的文件是否与源文件相同</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">mergeFileStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mergeFile);</span><br><span class="line">    <span class="comment">//取出原始文件的md5</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalMd5</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line">    <span class="comment">//取出合并文件的md5进行比较</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergeFileMd5</span> <span class="operator">=</span> DigestUtils.md5Hex(mergeFileStream);</span><br><span class="line">    <span class="keyword">if</span> (originalMd5.equals(mergeFileMd5)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;合并文件成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;合并文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="上传视频流程"><a href="#上传视频流程" class="headerlink" title="上传视频流程"></a>上传视频流程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038642.png" alt="img"></p>
<ol>
<li><p>前端上传文件前，请求媒资接口层检查文件是否存在</p>
<ul>
<li>若存在，则不再上传</li>
<li>若不存在，则开始上传，首先对视频文件进行分块</li>
</ul>
</li>
<li><p>前端分块进行上传，上传前首先检查分块是否已经存在</p>
<ul>
<li>若分块已存在，则不再上传</li>
<li>若分块不存在，则开始上传分块</li>
</ul>
</li>
<li><p>前端请求媒资管理接口层，请求上传分块</p>
</li>
<li><p>接口层请求服务层上传分块</p>
</li>
<li><p>服务端将分块信息上传到MinIO</p>
<p><strong>注意：</strong>minio文件和文件的分块存储路径都应该尽量<strong>避免存在根目录</strong>下，这里将文件名前两位设成路径。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/914f34cbb90b46b59ffbe7014713d2b2.png" alt="img"></p>
</li>
<li><p>前端将分块上传完毕，请求接口层合并分块</p>
</li>
<li><p>接口层请求服务层合并分块</p>
</li>
<li><p>服务层根据文件信息找到MinIO中的分块文件，下载到本地临时目录，将所有分块下载完毕后开始合并</p>
</li>
<li><p>合并完成后，将合并后的文件上传至MinIO</p>
</li>
<li><p>合并完成<strong>校验合并后的文件是否完整</strong>，如果完整则<strong>上传完成并删除分块</strong>，否则删除文件。</p>
</li>
</ol>
<h2 id="接口定义-1"><a href="#接口定义-1" class="headerlink" title="接口定义"></a>接口定义</h2><ul>
<li><p>根据上传视频流程，定义接口</p>
</li>
<li><p>与前端的约定是</p>
<ul>
<li><p>操作成功返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作失败返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在base工程的model包下新建RestResponse类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestResponse</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相应编码 0为正常 -1为错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应提示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RestResponse</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RestResponse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误信息的封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">validfail</span><span class="params">()</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">validfail</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(-<span class="number">1</span>);</span><br><span class="line">        response.setMsg(msg);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">validfail</span><span class="params">(String msg, T result)</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(-<span class="number">1</span>);</span><br><span class="line">        response.setMsg(msg);</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常信息的封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T result)</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(String msg, T result)</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setMsg(msg);</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义接口如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;大文件上传接口&quot;, tags = &quot;大文件上传接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigFilesController</span> &#123;</span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;文件上传前检查文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/checkfile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;分块文件上传前检查分块&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/checkchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;上传分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/uploadchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, <span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;合并分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/mergechunks&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;fileName&quot;)</span> String fileName, <span class="meta">@RequestParam(&quot;chunkTotal&quot;)</span> <span class="type">int</span> chunkTotal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口开发-1"><a href="#接口开发-1" class="headerlink" title="接口开发"></a>接口开发</h2><h3 id="DAO开发-1"><a href="#DAO开发-1" class="headerlink" title="DAO开发"></a>DAO开发</h3><ul>
<li>向媒资数据库的文件表插入记录，使用自动生成的Mapper接口即可满足要求</li>
</ul>
<h3 id="Service开发-1"><a href="#Service开发-1" class="headerlink" title="Service开发"></a>Service开发</h3><h4 id="检查文件和分块"><a href="#检查文件和分块" class="headerlink" title="检查文件和分块"></a>检查文件和分块</h4><ul>
<li><p>首先实现检查文件方法和检查分块方法</p>
</li>
<li><p>定义Service接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查文件是否存在</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5 文件的md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(String fileMd5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查分块是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5       文件的MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkIndex    分块序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunkIndex)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断文件是否存在</p>
<ul>
<li><p>首先判断数据库中是否存在该文件</p>
</li>
<li><p>其次判断minio的bucket中是否存在该文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(String fileMd5)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.首先判断数据库中是否存在该文件</span></span><br><span class="line">    <span class="comment">// 查询文件信息</span></span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(fileMd5);</span><br><span class="line">    <span class="keyword">if</span> (mediaFile == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若数据库中存在，根据数据库中的文件信息，则继续判断minio中是否存在</span></span><br><span class="line">    <span class="comment">// 2.其次判断minio的bucket中是否存在该文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> mediaFile.getBucket();  <span class="comment">// 桶</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> mediaFile.getFilePath();  <span class="comment">// 存储目录</span></span><br><span class="line">    <span class="comment">// 文件流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 查询minio, 调用statObject()来判断对象是否存在。</span></span><br><span class="line">        stream = minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(filePath)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="keyword">if</span> (stream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 文件已存在</span></span><br><span class="line">            <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在, statObject()抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件不存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>判断分块是否存在</p>
<ul>
<li><p>分块是否存在，只需要判断minio对应的目录下是否存在分块文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunkIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//得到分块文件目录</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="comment">//得到分块文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> chunkFileFolderPath + chunkIndex;</span><br><span class="line">    <span class="comment">//文件流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = minioClient.getObject(</span><br><span class="line">                GetObjectArgs.builder()</span><br><span class="line">                        .bucket(bucket_videoFiles)</span><br><span class="line">                        .object(chunkFilePath)</span><br><span class="line">                        .build());</span><br><span class="line">        <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//分块已存在</span></span><br><span class="line">            <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">//分块未存在</span></span><br><span class="line">    	<span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分块未存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//得到分块文件的目录</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getChunkFileFolderPath</span><span class="params">(String fileMd5)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fileMd5.substring(<span class="number">0</span>, <span class="number">1</span>) + <span class="string">&quot;/&quot;</span> + fileMd5.substring(<span class="number">1</span>, <span class="number">2</span>) + <span class="string">&quot;/&quot;</span> + fileMd5 + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;chunk&quot;</span> + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>优化代码</p>
</li>
<li><p>检查文件和分块文件在minio是否存在提取方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断文件在minio是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket 桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkFilePath 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存在 true； 不存在false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkMinioFile</span><span class="params">(String bucket, String chunkFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">//文件流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(chunkFilePath)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//分块已存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化检查文件和分块文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(String fileMd5)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.首先判断数据库中是否存在该文件</span></span><br><span class="line">    <span class="comment">// 查询文件信息</span></span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(fileMd5);</span><br><span class="line">    <span class="keyword">if</span> (mediaFile == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若数据库中存在，根据数据库中的文件信息，则继续判断minio中是否存在</span></span><br><span class="line">    <span class="comment">// 2.其次判断minio的bucket中是否存在该文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> mediaFile.getBucket();  <span class="comment">// 桶</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> mediaFile.getFilePath();  <span class="comment">// 存储目录</span></span><br><span class="line">    <span class="comment">// 判断文件是否在minio存在</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> checkMinioFile(bucket, filePath);</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunkIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 分块是否存在，只需要判断minio对应的目录下是否存在分块文件</span></span><br><span class="line">    <span class="comment">// 获取得到分块文件所在目录。“abcde”-&gt;“a/b/abcde”</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="comment">// 得到分块文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> chunkFileFolderPath + chunkIndex;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> checkMinioFile(bucket_video, chunkFilePath);</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="上传分块"><a href="#上传分块" class="headerlink" title="上传分块"></a>上传分块</h4><ul>
<li><p>定义Service接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传分块(putObjectArgs)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5   文件MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunk     分块序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes     文件字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5,<span class="type">int</span> chunk,<span class="type">byte</span>[] bytes)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传分块(UploadObjectArgs)	推荐使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5   文件MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunk     分块序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localChunkFilePath    本地文件绝对路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5,<span class="type">int</span> chunk, String localChunkFilePath)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunk, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">    <span class="comment">// 分块文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5) + chunk;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        addMediaFilesToMinIO(bytes, video_files, chunkFilePath);</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;上传分块文件：&#123;&#125;失败：&#123;&#125;&quot;</span>, chunkFilePath, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;上传文件失败&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>使用UploadObjectArgs方法上传mino（<strong>推荐</strong>）</p>
</li>
<li><p>uploadChunk方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5   文件MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunk     分块序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localChunkFilePath    本地文件绝对路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunk, String localChunkFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">//获取文件扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> localChunkFilePath.substring(localChunkFilePath.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取文件类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> getMimeType(extension);</span><br><span class="line">    <span class="comment">// 获取文件在minio的存储路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="comment">// 上传文件到minio</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> uploadFileToMinio(bucket_video, mimeType, chunkFileFolderPath, localChunkFilePath);</span><br><span class="line">    <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;上传分块文件失败:&#123;&#125;&quot;</span>, chunkFileFolderPath);</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;上传分块失败&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;上传分块文件成功:&#123;&#125;&quot;</span>,chunkFileFolderPath);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>uploadFileToMinio方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传分块文件到minio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket 桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mimeType 文件类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkFileFolderPath 上传对象名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localChunkFilePath 本地文件地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 上传成功true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">uploadFileToMinio</span><span class="params">(String bucket, String mimeType, String chunkFileFolderPath, String localChunkFilePath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">UploadObjectArgs</span> <span class="variable">uploadObjectArgs</span> <span class="operator">=</span> UploadObjectArgs.builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(chunkFileFolderPath)</span><br><span class="line">                .filename(localChunkFilePath)</span><br><span class="line">                .contentType(mimeType)</span><br><span class="line">                .build();</span><br><span class="line">        minioClient.uploadObject(uploadObjectArgs);</span><br><span class="line">        log.debug(<span class="string">&quot;上传文件到 minio 成功,bucket:&#123;&#125;,objectName:&#123;&#125;&quot;</span>,bucket,chunkFileFolderPath);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;上传文件到 minio 出错,bucket:&#123;&#125;,objectName:&#123;&#125;,错误原因:&#123;&#125;&quot;</span>,bucket,chunkFileFolderPath,e.getMessage(),e);</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;上传文件到文件系统失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="上传分块测试"><a href="#上传分块测试" class="headerlink" title="上传分块测试"></a>上传分块测试</h4><ul>
<li><p>完善Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;文件上传前检查文件&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/checkfile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mediaFileService.checkFile(fileMd5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;分块文件上传前检查分块&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/checkchunk&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mediaFileService.checkChunk(fileMd5, chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;上传分块文件&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/uploadchunk&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, <span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line">    <span class="comment">// return mediaFileService.uploadChunk(fileMd5, chunk, file.getBytes());</span></span><br><span class="line">    <span class="comment">// 方法二</span></span><br><span class="line">    <span class="comment">// 创建临时文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">tempFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        tempFile = File.createTempFile(<span class="string">&quot;minio&quot;</span>, <span class="string">&quot;temp&quot;</span>);</span><br><span class="line">        <span class="comment">// 拷贝文件到临时文件</span></span><br><span class="line">        file.transferTo(tempFile);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;创建临时文件失败&quot;</span>);</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;创建临时文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取文件绝对路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> tempFile.getAbsolutePath();</span><br><span class="line">    <span class="keyword">return</span> mediaFileService.uploadChunk(fileMd5, chunk, absolutePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="合并前下载分块"><a href="#合并前下载分块" class="headerlink" title="合并前下载分块"></a>合并前下载分块</h4><p><strong>service 接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>在合并分块前，我们需要先下载分块，在ServiceImpl中定义下载分块方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5       文件的MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal    总块数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分块文件数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> File[] checkChunkStatus(String fileMd5, <span class="type">int</span> chunkTotal) &#123;</span><br><span class="line">    <span class="comment">// 作为结果返回</span></span><br><span class="line">    File[] files = <span class="keyword">new</span> <span class="title class_">File</span>[chunkTotal];</span><br><span class="line">    <span class="comment">// 获取分块文件目录</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolder</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chunkTotal; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取分块文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> chunkFileFolder + i;</span><br><span class="line">        <span class="type">File</span> <span class="variable">chunkFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建临时的分块文件</span></span><br><span class="line">            chunkFile = File.createTempFile(<span class="string">&quot;chunk&quot;</span> + i, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;创建临时分块文件出错：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下载分块文件</span></span><br><span class="line">        chunkFile = downloadFileFromMinio(chunkFile, video_files, chunkFilePath);</span><br><span class="line">        <span class="comment">// 组成结果</span></span><br><span class="line">        files[i] = chunkFile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Minio中下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file          目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket        桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName    桶内文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> File <span class="title function_">downloadFileFromMinio</span><span class="params">(File file, String bucket, String objectName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">         <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs</span><br><span class="line">                 .builder()</span><br><span class="line">                 .bucket(bucket)</span><br><span class="line">                 .object(objectName)</span><br><span class="line">                 .build())) &#123;</span><br><span class="line">        IOUtils.copy(inputStream, fileOutputStream);</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;查询文件分块出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="合并分块"><a href="#合并分块" class="headerlink" title="合并分块"></a>合并分块</h4><ul>
<li><p>合并分块的实现代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(Long companyId, String fileMd5, <span class="type">int</span> chunkTotal, UploadFileParamsDto uploadFileParamsDto)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 下载分块文件</span></span><br><span class="line">    File[] chunkFiles = checkChunkStatus(fileMd5, chunkTotal);</span><br><span class="line">    <span class="comment">// 获取源文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">    <span class="comment">// 获取源文件扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建出临时文件，准备合并</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">mergeFile</span> <span class="operator">=</span> File.createTempFile(fileName, extension);</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 写入流，向临时文件写入</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf_write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(mergeFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历分块文件数组</span></span><br><span class="line">    <span class="keyword">for</span> (File chunkFile : chunkFiles) &#123;</span><br><span class="line">        <span class="comment">// 读取流，读分块文件</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf_read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(chunkFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf_read.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            raf_write.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uploadFileParamsDto.setFileSize(mergeFile.length());</span><br><span class="line">    <span class="comment">// 对文件进行校验，通过MD5值比较</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">mergeInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mergeFile);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mergeMd5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(mergeInputStream);</span><br><span class="line">    <span class="keyword">if</span> (!fileMd5.equals(mergeMd5)) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;合并文件校验失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接合并文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergeFilePath</span> <span class="operator">=</span> getFilePathByMd5(fileMd5, extension);</span><br><span class="line">    <span class="comment">// 将本地合并好的文件，上传到minio中，这里重载了一个方法</span></span><br><span class="line">    addMediaFilesToMinIO(mergeFile.getAbsolutePath(), video_files, mergeFilePath);</span><br><span class="line">    <span class="comment">// 将文件信息写入数据库</span></span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> addMediaFilesToDB(companyId, uploadFileParamsDto, mergeFilePath, mergeMd5, video_files);</span><br><span class="line">    <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span>) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;媒资文件入库出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将本地文件上传到minio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath      本地文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket        桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName    对象名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addMediaFilesToMinIO</span><span class="params">(String filePath, String bucket, String objectName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> getContentType(objectName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        minioClient.uploadObject(UploadObjectArgs</span><br><span class="line">                .builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(objectName)</span><br><span class="line">                .filename(filePath)</span><br><span class="line">                .contentType(contentType)</span><br><span class="line">                .build());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;上传到文件系统出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据MD5和文件扩展名，生成文件路径，例 /2/f/2f6451sdg/2f6451sdg.mp4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5       文件MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> extension     文件扩展名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFilePathByMd5</span><span class="params">(String fileMd5, String extension)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fileMd5.substring(<span class="number">0</span>, <span class="number">1</span>) + <span class="string">&quot;/&quot;</span> + fileMd5.substring(<span class="number">1</span>, <span class="number">2</span>) + <span class="string">&quot;/&quot;</span> + fileMd5 + <span class="string">&quot;/&quot;</span> + fileMd5 + extension;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本的业务逻辑就是这些，但是现在还少了点东西，我们没有做异常处理，简单的throw出去而已，并且创建的临时文件，也需要删除，完善后的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(Long companyId, String fileMd5, <span class="type">int</span> chunkTotal, UploadFileParamsDto uploadFileParamsDto)</span> &#123;</span><br><span class="line">    <span class="comment">// 下载分块文件</span></span><br><span class="line">    File[] chunkFiles = checkChunkStatus(fileMd5, chunkTotal);</span><br><span class="line">    <span class="comment">// 获取源文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">    <span class="comment">// 获取源文件扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建出临时文件，准备合并</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">mergeFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mergeFile = File.createTempFile(fileName, extension);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;创建合并临时文件出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 缓冲区</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写入流，向临时文件写入</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">raf_write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(mergeFile, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历分块文件数组</span></span><br><span class="line">            <span class="keyword">for</span> (File chunkFile : chunkFiles) &#123;</span><br><span class="line">                <span class="comment">// 读取流，读分块文件</span></span><br><span class="line">                <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">raf_read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(chunkFile, <span class="string">&quot;r&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = raf_read.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        raf_write.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;合并文件过程中出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        uploadFileParamsDto.setFileSize(mergeFile.length());</span><br><span class="line">        <span class="comment">// 对文件进行校验，通过MD5值比较</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">mergeInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mergeFile)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">mergeMd5</span> <span class="operator">=</span> org.apache.commons.codec.digest.DigestUtils.md5Hex(mergeInputStream);</span><br><span class="line">            <span class="keyword">if</span> (!fileMd5.equals(mergeMd5)) &#123;</span><br><span class="line">                XueChengPlusException.cast(<span class="string">&quot;合并文件校验失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;合并文件校验通过：&#123;&#125;&quot;</span>, mergeFile.getAbsolutePath());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;合并文件校验异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mergeFilePath</span> <span class="operator">=</span> getFilePathByMd5(fileMd5, extension);</span><br><span class="line">        <span class="comment">// 将本地合并好的文件，上传到minio中，这里重载了一个方法</span></span><br><span class="line">        addMediaFilesToMinIO(mergeFile.getAbsolutePath(), video_files, mergeFilePath);</span><br><span class="line">        log.debug(<span class="string">&quot;合并文件上传至MinIO完成&#123;&#125;&quot;</span>, mergeFile.getAbsolutePath());</span><br><span class="line">        <span class="comment">// 将文件信息写入数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> addMediaFilesToDB(companyId, uploadFileParamsDto, mergeFilePath, fileMd5, video_files);</span><br><span class="line">        <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span>) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;媒资文件入库出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;媒资文件入库完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (File chunkFile : chunkFiles) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                chunkFile.delete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;临时分块文件删除错误：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mergeFile.delete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;临时合并文件删除错误：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="合并分块（新）"><a href="#合并分块（新）" class="headerlink" title="合并分块（新）"></a>合并分块（新）</h3><h4 id="定义-service-接口"><a href="#定义-service-接口" class="headerlink" title="定义 service 接口"></a>定义 service 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> companyId 机构 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5 文件 md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal 分块总和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uploadFileParamsDto 文件信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse <span class="title function_">mergeChunks</span><span class="params">(Long companyId,String fileMd5,<span class="type">int</span> chunkTotal,UploadFileParamsDto uploadFileParamsDto)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="service-实现："><a href="#service-实现：" class="headerlink" title="service 实现："></a>service 实现：</h4><p><strong>业务流程</strong></p>
<ul>
<li>合并最后一个文件操作</li>
<li>合并整个文件操作</li>
<li>验证文件</li>
<li>保存文件信息</li>
<li>删除分块文件</li>
</ul>
<h5 id="合并最后一个文件操作"><a href="#合并最后一个文件操作" class="headerlink" title="合并最后一个文件操作"></a>合并最后一个文件操作</h5><p>目前，<code>composeObject</code>方法合并的分块文件大小必须大于等于5242880字节，否则会出现上述报错信息<strong>source testbucket&#x2F;chunk&#x2F;4: size 3819300 must be greater than 5242880</strong>。为了解决这个问题，您可以按以下步骤进行操作：</p>
<ol>
<li>找出最后一个分块文件，获取它的大小。假设您的分块总数为n，最后一个分块文件名称为<code>part-n</code>，则可以使用以下代码获取最后一个分块文件的大小：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">partSize</span> <span class="operator">=</span> client.statObject(StatObjectArgs.builder().bucket(<span class="string">&quot;testbucket&quot;</span>).object(<span class="string">&quot;chunk/part-&quot;</span> + n).build()).size();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将最后一个分块文件合并到上一个分块文件中。如果最后一个分块文件大小小于5242880字节，则可以将最后一个分块文件和前一个分块文件合并为一个文件，使得合并后的文件大小大于等于5242880字节。可以使用以下代码将最后一个分块文件合并到前一个分块文件中：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将最后一个分块文件合并到上一个分块文件中</span></span><br><span class="line"><span class="comment"> * 使得合并后的文件大小大于等于5MB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buket 桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileFolderPath 文件所在目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> contentType 文件类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunk 分块数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 合并失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeLastChunkFile</span><span class="params">(String buket, String fileFolderPath, String contentType, <span class="type">int</span> chunk)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 最后一个文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lastFilePath</span> <span class="operator">=</span> fileFolderPath.concat(Integer.toString(chunk));</span><br><span class="line">    <span class="comment">// 上一个文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">preFilePath</span> <span class="operator">=</span> fileFolderPath.concat(Integer.toString(chunk - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 1.获取最后一个分块文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">lastFilesize</span> <span class="operator">=</span> minioClient.statObject(StatObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(lastFilePath)</span><br><span class="line">            .build()).size();</span><br><span class="line">    <span class="comment">// 1.1 获取上一个分块文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">preFilesize</span> <span class="operator">=</span> minioClient.statObject(StatObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(preFilePath)</span><br><span class="line">            .build()).size();</span><br><span class="line">    <span class="comment">// 2.获取合并后的分块文件大小，使得合并后的文件大小大于等于5242880字节</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> lastFilesize + preFilesize;</span><br><span class="line">    <span class="comment">// 3.获取到最后一个分块文件的内容流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">lastInputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(lastFilePath)</span><br><span class="line">            .build());</span><br><span class="line">    <span class="comment">// 4.获取到前一个分块文件的内容流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">preInputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(preFilePath)</span><br><span class="line">            .build());</span><br><span class="line">    <span class="comment">// 5.合并文件流生成新的输入流</span></span><br><span class="line">    <span class="type">SequenceInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceInputStream</span>(preInputStream, lastInputStream);</span><br><span class="line">    <span class="comment">// 6.上传新的文件到上一个分块文件</span></span><br><span class="line">    <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(preFilePath)</span><br><span class="line">            .stream(inputStream, fileSize, -<span class="number">1</span>)</span><br><span class="line">            .contentType(contentType)</span><br><span class="line">            .build();</span><br><span class="line">    minioClient.putObject(putObjectArgs);</span><br><span class="line">    <span class="comment">/*File tempFile = File.createTempFile(&quot;minio&quot;, &quot;lastChunk&quot;);</span></span><br><span class="line"><span class="comment">    FileOutputStream outputStream = new FileOutputStream(tempFile);</span></span><br><span class="line"><span class="comment">    IoUtils.copy(inputStream, outputStream);</span></span><br><span class="line"><span class="comment">    // 使用uploadObject方法</span></span><br><span class="line"><span class="comment">    minioClient.uploadObject(UploadObjectArgs.builder()</span></span><br><span class="line"><span class="comment">            .bucket(buket)</span></span><br><span class="line"><span class="comment">            .object(preFilePath)</span></span><br><span class="line"><span class="comment">            .filename(tempFile.getAbsolutePath())</span></span><br><span class="line"><span class="comment">            .build());</span></span><br><span class="line"><span class="comment">    tempFile.delete();*/</span></span><br><span class="line">    <span class="comment">// 7. 删除最后一个分块文件</span></span><br><span class="line">    minioClient.removeObject(RemoveObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(lastFilePath)</span><br><span class="line">            .build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="合并整个文件操作"><a href="#合并整个文件操作" class="headerlink" title="合并整个文件操作"></a>合并整个文件操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buket 桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileFolderPath 分块文件所在目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mergeFilePath 合并文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal 分块总数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 合并成功true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeChunkFile</span><span class="params">(String buket, String fileFolderPath, String mergeFilePath, <span class="type">int</span> chunkTotal)</span>&#123;</span><br><span class="line">    <span class="comment">// Stream.iterate 是 Java 8 中的一个方法，用于创建一个无限流</span></span><br><span class="line">    <span class="comment">// 第一个元素是初始值，后续每个元素都是前一个元素加1</span></span><br><span class="line">    <span class="comment">// 需要注意的是，由于 Stream.iterate 创建的是无限流，因此需要通过 limit() 或其他终止操作来限制流的大小</span></span><br><span class="line">    List&lt;ComposeSource&gt; sources = Stream.iterate(<span class="number">0</span>, i -&gt; ++i).limit(chunkTotal)</span><br><span class="line">            .map(i -&gt; ComposeSource.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(fileFolderPath.concat(Integer.toString(i)))</span><br><span class="line">            .build()</span><br><span class="line">    ).collect(Collectors.toList());</span><br><span class="line">    <span class="type">ComposeObjectArgs</span> <span class="variable">composeObject</span> <span class="operator">=</span> ComposeObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(mergeFilePath)</span><br><span class="line">            .sources(sources)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        minioClient.composeObject(composeObject);</span><br><span class="line">        log.info(<span class="string">&quot;合并文件成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;合并文件失败&quot;</span>);</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;合并文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="验证文件"><a href="#验证文件" class="headerlink" title="验证文件"></a>验证文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  =================3. 验证文件===============</span></span><br><span class="line"><span class="comment">// 验证md5合并后的文件和源文件是否一致，从而判断是否上传成功</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> downloadFileFromMinIO(bucket_video, mergeFilePath);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">null</span>)&#123;</span><br><span class="line">    log.error(<span class="string">&quot;下载合并后文件失败,mergeFilePath:&#123;&#125;&quot;</span>,mergeFilePath);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;下载合并后文件失败。&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 校验文件md5</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">// minio上文件的md5值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">md5Hex</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line">    <span class="comment">//比较md5值，不一致则说明文件不完整</span></span><br><span class="line">    <span class="keyword">if</span> (!fileMd5.equals(md5Hex))&#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;文件合并校验失败&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置文件大小</span></span><br><span class="line">    uploadFileParamsDto.setFileSize(file.length());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>)&#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="保存文件信息"><a href="#保存文件信息" class="headerlink" title="保存文件信息"></a>保存文件信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 保持文件到数据库</span><br><span class="line"> *</span><br><span class="line"> * @param companyId           机构id</span><br><span class="line"> * @param uploadFileParamsDto 上传文件的信息</span><br><span class="line"> * @param objectName          对象名称</span><br><span class="line"> * @param fileMD5             文件的md5码</span><br><span class="line"> * @param bucket              桶</span><br><span class="line"> * @return MediaFiles</span><br><span class="line"> */</span><br><span class="line">@Transactional</span><br><span class="line">public MediaFiles saveFileToDB(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket) &#123;</span><br><span class="line">    MediaFiles mediaFile = this.getById(fileMD5);</span><br><span class="line">    if (mediaFile == null) &#123;</span><br><span class="line">        mediaFile = new MediaFiles();</span><br><span class="line">        BeanUtils.copyProperties(uploadFileParamsDto, mediaFile);</span><br><span class="line">        mediaFile.setId(fileMD5);</span><br><span class="line">        mediaFile.setFileId(fileMD5);</span><br><span class="line">        mediaFile.setCompanyId(companyId);</span><br><span class="line">        mediaFile.setBucket(bucket);</span><br><span class="line">        mediaFile.setCreateDate(LocalDateTime.now());</span><br><span class="line">        mediaFile.setStatus(&quot;1&quot;);</span><br><span class="line">        mediaFile.setFilePath(objectName);</span><br><span class="line">        mediaFile.setUrl(&quot;/&quot; + bucket + &quot;/&quot; + objectName);</span><br><span class="line">        // 查阅数据字典，002003表示审核通过</span><br><span class="line">        mediaFile.setAuditStatus(&quot;002003&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean save = this.save(mediaFile);</span><br><span class="line">    if (!save) &#123;</span><br><span class="line">        XcPlusException.cast(&quot;保存文件信息失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return mediaFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除分块文件"><a href="#删除分块文件" class="headerlink" title="删除分块文件"></a>删除分块文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkFilePath 分块文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal 分块数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearChunkFiles</span><span class="params">(String bucket, String chunkFilePath, <span class="type">int</span> chunkTotal)</span> &#123;</span><br><span class="line">    Iterable&lt;DeleteObject&gt; object = Stream.iterate(<span class="number">0</span>, i -&gt; ++i).limit(chunkTotal)</span><br><span class="line">            .map(i -&gt; <span class="keyword">new</span> <span class="title class_">DeleteObject</span>(chunkFilePath.concat(Integer.toString(i))))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="type">RemoveObjectsArgs</span> <span class="variable">args</span> <span class="operator">=</span> RemoveObjectsArgs.builder()</span><br><span class="line">            .bucket(bucket)</span><br><span class="line">            .objects(object)</span><br><span class="line">            .build();</span><br><span class="line">    Iterable&lt;Result&lt;DeleteError&gt;&gt; results = minioClient.removeObjects(args);</span><br><span class="line">    <span class="keyword">for</span> (Result&lt;DeleteError&gt; result : results) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeleteError</span> <span class="variable">error</span> <span class="operator">=</span> result.get();</span><br><span class="line">            log.error( <span class="string">&quot;清楚分块文件出错&quot;</span> + error.objectName() + <span class="string">&quot;; &quot;</span> + error.message());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并分块接口实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> companyId           机构 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5             文件 md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal          分块总和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uploadFileParamsDto 文件信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(Long companyId, String fileMd5, <span class="type">int</span> chunkTotal, UploadFileParamsDto uploadFileParamsDto)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.下载分块文件</span></span><br><span class="line">    <span class="comment">// 获取minio分块文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="comment">//获取文件类型mimeType</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> getMimeType(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// =================1. 合并最后一个文件操作===============</span></span><br><span class="line">    <span class="comment">// 将最后一个分块文件合并到上一个分块文件中</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mergeLastChunkFile(bucket_video, chunkFilePath, mimeType, chunkTotal - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;合并最后一个分块文件失败&quot;</span>);</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;合并最后一个分块文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =================2. 合并整个文件操作===============</span></span><br><span class="line">    <span class="comment">// 文件名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">    <span class="comment">// 文件扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">//合并文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergeFilePath</span> <span class="operator">=</span> getFilePathByMd5(fileMd5, extension);</span><br><span class="line">    <span class="comment">// 合并分块文件</span></span><br><span class="line">    mergeChunkFile(bucket_video, chunkFilePath, mergeFilePath, chunkTotal-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//  =================3. 验证文件===============</span></span><br><span class="line">    <span class="comment">// 验证md5合并后的文件和源文件是否一致，从而判断是否上传成功</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> downloadFileFromMinIO(bucket_video, mergeFilePath);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">null</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;下载合并后文件失败,mergeFilePath:&#123;&#125;&quot;</span>,mergeFilePath);</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;下载合并后文件失败。&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 校验文件md5</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// minio上文件的md5值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">md5Hex</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line">        <span class="comment">//比较md5值，不一致则说明文件不完整</span></span><br><span class="line">        <span class="keyword">if</span> (!fileMd5.equals(md5Hex))&#123;</span><br><span class="line">            <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;文件合并校验失败&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置文件大小</span></span><br><span class="line">        uploadFileParamsDto.setFileSize(file.length());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">null</span>)&#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  =================4.保存文件信息===============</span></span><br><span class="line">    mediaFileService.saveFileToDB(companyId, uploadFileParamsDto, mergeFilePath, fileMd5, bucket_video);</span><br><span class="line">    <span class="comment">//  =================5. 删除分块文件===============</span></span><br><span class="line">    clearChunkFiles(bucket_video,chunkFilePath,chunkTotal);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="接口层完善"><a href="#接口层完善" class="headerlink" title="接口层完善"></a>接口层完善</h3><ul>
<li><p>下面完善接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;大文件上传接口&quot;, tags = &quot;大文件上传接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigFilesController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaFileService mediaFileService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;文件上传前检查文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/checkfile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.checkFile(fileMd5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;分块文件上传前检查分块&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/checkchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.checkChunk(fileMd5, chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用putObject方法上传分块文件</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;上传分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/uploadchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, <span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.uploadChunk(fileMd5, chunk, file.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用uploadObject方法上传分块文件</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;上传分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/uploadchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建临时文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">tempFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tempFile = File.createTempFile(<span class="string">&quot;minio&quot;</span>, <span class="string">&quot;temp&quot;</span>);</span><br><span class="line">            <span class="comment">// 拷贝文件到临时文件</span></span><br><span class="line">            file.transferTo(tempFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">&quot;创建临时文件失败&quot;</span>);</span><br><span class="line">            XcPlusException.cast(<span class="string">&quot;创建临时文件失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取文件绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> tempFile.getAbsolutePath();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> mediaFileService.uploadChunk(fileMd5, chunk, absolutePath);</span><br><span class="line">        tempFile.delete();</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;上传分块失败&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;合并分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/mergechunks&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;fileName&quot;)</span> String fileName, <span class="meta">@RequestParam(&quot;chunkTotal&quot;)</span> <span class="type">int</span> chunkTotal)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> <span class="number">1232141425L</span>;</span><br><span class="line">        <span class="type">UploadFileParamsDto</span> <span class="variable">uploadFileParamsDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileParamsDto</span>();</span><br><span class="line">        uploadFileParamsDto.setFileType(<span class="string">&quot;001002&quot;</span>);</span><br><span class="line">        uploadFileParamsDto.setTags(<span class="string">&quot;课程视频&quot;</span>);</span><br><span class="line">        uploadFileParamsDto.setRemark(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        uploadFileParamsDto.setFilename(fileName);</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.mergeChunks(companyId, fileMd5, chunkTotal, uploadFileParamsDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><ul>
<li>前后端联调，上传视频进行测试<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160048701.png" alt="img"></li>
<li>数据库和MinIO中均能看到对应的数据<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038552.png" alt="img"></li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="文件预览"><a href="#文件预览" class="headerlink" title="文件预览"></a>文件预览</h1><h2 id="需求分析-2"><a href="#需求分析-2" class="headerlink" title="需求分析"></a>需求分析</h2><ul>
<li>图片上传成功、视频上传成功后，可以通过预览按钮查看文件内容</li>
<li>预览的方式是通过浏览器直接打开文件，对于图片和浏览器支持的视频格式可以直接浏览<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038438.png" alt="img"></li>
<li>说明<ol>
<li>前端请求接口层预览文件</li>
<li>接口层将文件id传递给服务层</li>
<li>服务层使用文件id查询媒资数据库文件表，获取文件的URL</li>
<li>接口层将文件url返回给前端，通过浏览器打开URL</li>
</ol>
</li>
</ul>
<h2 id="接口定义-2"><a href="#接口定义-2" class="headerlink" title="接口定义"></a>接口定义</h2><ul>
<li><p>根据需求分析，定义的接口如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;预览文件&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/preview/&#123;mediaId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;String&gt; <span class="title function_">getPlayUrlByMediaId</span><span class="params">(<span class="meta">@PathVariable</span> String mediaId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口开发-2"><a href="#接口开发-2" class="headerlink" title="接口开发"></a>接口开发</h2><h3 id="设置URL"><a href="#设置URL" class="headerlink" title="设置URL"></a>设置URL</h3><ul>
<li><p>有一些浏览器不支持的视频格式，不能在浏览器中直接浏览，所以我们要修改保存媒资信息到数据库的方法</p>
<ul>
<li>当文件是图片时，设置URL字段</li>
<li>当视频是MP4格式时，设置URL字段</li>
<li>其他情况暂不设置URL，需要文件处理后再设置URL字段</li>
</ul>
</li>
<li><p>修改保存媒资信息的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文件信息添加到文件表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uploadFileParamsDto 上传文件的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileMD5             文件的md5码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket              桶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> MediaFiles <span class="title function_">addMediaFilesToDB</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存到数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> mediaFilesMapper.selectById(fileMD5);</span><br><span class="line">        <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span>) &#123;</span><br><span class="line">            mediaFiles = <span class="keyword">new</span> <span class="title class_">MediaFiles</span>();</span><br><span class="line">            BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles);</span><br><span class="line">            mediaFiles.setId(fileMD5);</span><br><span class="line">            mediaFiles.setFileId(fileMD5);</span><br><span class="line">            mediaFiles.setCompanyId(companyId);</span><br><span class="line">            mediaFiles.setBucket(bucket);</span><br><span class="line">            mediaFiles.setCreateDate(LocalDateTime.now());</span><br><span class="line">            mediaFiles.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            mediaFiles.setFilePath(objectName);</span><br><span class="line">+           <span class="comment">// 获取源文件名的contentType</span></span><br><span class="line">+           <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> getContentType(objectName);</span><br><span class="line">+           <span class="comment">// 如果是图片格式或者mp4格式，则设置URL属性，否则不设置</span></span><br><span class="line">+           <span class="keyword">if</span> (contentType.contains(<span class="string">&quot;image&quot;</span>) || contentType.contains(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">+               mediaFiles.setUrl(<span class="string">&quot;/&quot;</span> + bucket + <span class="string">&quot;/&quot;</span> + objectName);</span><br><span class="line">+           &#125;</span><br><span class="line">            <span class="comment">// 查阅数据字典，002003表示审核通过</span></span><br><span class="line">            mediaFiles.setAuditStatus(<span class="string">&quot;002003&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> mediaFilesMapper.insert(mediaFiles);</span><br><span class="line">        <span class="keyword">if</span> (insert &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;保存文件信息失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mediaFiles;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DAO开发-2"><a href="#DAO开发-2" class="headerlink" title="DAO开发"></a>DAO开发</h3><ul>
<li>使用自动生成的Mapper接口即可</li>
</ul>
<h3 id="Service开发-2"><a href="#Service开发-2" class="headerlink" title="Service开发"></a>Service开发</h3><ul>
<li><p>定义根据id查询媒资文件接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MediaFiles <span class="title function_">getFileById</span><span class="params">(String mediaId)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MediaFiles <span class="title function_">getFileById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> mediaFilesMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span> || StringUtils.isEmpty(mediaFiles.getUrl())) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;视频还没有转码处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mediaFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="完善Controller-1"><a href="#完善Controller-1" class="headerlink" title="完善Controller"></a>完善Controller</h3><ul>
<li><p>完善接口层代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;预览文件&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/preview/&#123;mediaId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;String&gt; <span class="title function_">getPlayUrlByMediaId</span><span class="params">(<span class="meta">@PathVariable</span> String mediaId)</span> &#123;</span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> mediaFileService.getFileById(mediaId);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(mediaFile.getUrl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口测试-1"><a href="#接口测试-1" class="headerlink" title="接口测试"></a>接口测试</h3><ul>
<li>前后端联调<ul>
<li>上传MP4视频文件，并预览</li>
<li>上传图片文件，并预览</li>
<li>上传.avi格式的视频文件，尝试预览，观察错误提示信息，稍后通过视频处理对视频转码</li>
</ul>
</li>
</ul>
<h1 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h1><h2 id="分布式任务处理"><a href="#分布式任务处理" class="headerlink" title="分布式任务处理"></a>分布式任务处理</h2><h3 id="什么是分布式任务调度"><a href="#什么是分布式任务调度" class="headerlink" title="什么是分布式任务调度"></a>什么是分布式任务调度</h3><ul>
<li><p>视频上传成功需要对视频格式进行处理，如何用Java程序对视频进行处理呢？</p>
<ul>
<li>这里有一个关键的需求就是：当视频比较多的时候，我们如何高效的处理</li>
</ul>
</li>
<li><p>如何去高效的处理一批任务呢？</p>
<ol>
<li>多线程<ul>
<li>多线程是充分利用单机的资源</li>
</ul>
</li>
<li>分布式+多线程<ul>
<li>充分利用多台计算机，每台计算机使用多线程处理</li>
</ul>
</li>
</ol>
</li>
<li><p>方案2的可扩展性更强，同时方案二也是一种分布式任务调度的处理方案</p>
</li>
<li><p>什么是分布式任务调度?</p>
<ul>
<li><p>我们可以先思考一下下面业务场景的解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">某电商系统需要在每天上午10点，下午3点，晚上8点发放一批优惠券</span><br><span class="line"></span><br><span class="line">某财务系统需要在每天上午10天谴结算前一天的账单数据，统计汇总</span><br><span class="line"></span><br><span class="line">某电商平台每天凌晨3点，要对订单中的无效订单进行处理</span><br><span class="line"></span><br><span class="line">12306网站会根据车次不同，设置几个时间点分批放票</span><br><span class="line"></span><br><span class="line">电商正点抢购，商品价格某天上午8点整开始优惠</span><br><span class="line"></span><br><span class="line">商品成功发货后，需要向客户发送短信提醒</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类似的场景还有很多，我们该如何实现呢？</p>
<ul>
<li>以上这些场景，就是任务调度所需要解决的问题</li>
</ul>
</li>
<li><p>任务调度，顾名思义就是对任务的调度，它是指系统为了完成特定业务，基于给定时间点，给定时间间隔或者给定执行次数自动执行任务</p>
</li>
<li><p>如何实现任务调度？</p>
<ul>
<li><p>多线程方式实现</p>
<ul>
<li><p>我们可以开启一个线程，每sleep一段时间，就去检查是否已经到预期执行时间，下面代码简单实现了任务调度的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 任务执行时间间隔</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeInterval</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> something</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(timeInterval);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>上面的代码实现了按一定时间间隔，执行任务调度的功能</p>
</li>
<li><p>JDK也为我们提供了相关支持，如Timer、ScheduledExecutor，下面我们了解下</p>
<ul>
<li><p>Timer</p>
</li>
<li><p>ScheduledExecutor</p>
</li>
<li><p>Timer方式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="number">2000</span>); <span class="comment">// 1秒后开始调度，每2秒执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Timer的优点在于简单易用，每个Timer对应一个线程，因此可以同时启动多个Timer并行执行多个任务，同一个Timer中的任务是串行执行</p>
</li>
</ul>
</li>
<li><p>Timer和ScheduledExecutor都仅能提供基于开始时间与重复间隔的任务调度，不能胜任更加复杂的调度需求。比如，设置每个月第一天凌晨1点执行任务、复杂调度任务的管理、任务键传递数据等等</p>
</li>
<li><p>Quartz是一个功能强大的任务调度框架，它可以满足更多更复杂的调度需求</p>
<ul>
<li><p>Quartz设计的核心类包括Job，Trigger以及Scheduler。</p>
<ul>
<li>Job负责定义需要执行的任务</li>
<li>Trigger负责设置调度策略</li>
<li>Scheduler将二者组装在一起，并触发任务开始执行。</li>
</ul>
</li>
<li><p>Quartz支持简单的按时间间隔调度，还支持按日历调度方式，通过设置CronTrigger表达式（包括：秒、分、时、日、月、周、年）进行任务调度</p>
</li>
<li><p>第三方Quartz方式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] agrs)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">    <span class="comment">//创建一个Scheduler</span></span><br><span class="line">    <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">    <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">    <span class="comment">//创建JobDetail</span></span><br><span class="line">    <span class="type">JobBuilder</span> <span class="variable">jobDetailBuilder</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class);</span><br><span class="line">    jobDetailBuilder.withIdentity(<span class="string">&quot;jobName&quot;</span>,<span class="string">&quot;jobGroupName&quot;</span>);</span><br><span class="line">    <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> jobDetailBuilder.build();</span><br><span class="line">    <span class="comment">//创建触发的CronTrigger 支持按日历调度</span></span><br><span class="line">    <span class="type">CronTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">            .withIdentity(<span class="string">&quot;triggerName&quot;</span>, <span class="string">&quot;triggerGroupName&quot;</span>)</span><br><span class="line">            .startNow()</span><br><span class="line">            .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/2 * * * * ?&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//创建触发的SimpleTrigger 简单的间隔调度</span></span><br><span class="line">    <span class="comment">/*SimpleTrigger trigger = TriggerBuilder.newTrigger()</span></span><br><span class="line"><span class="comment">            .withIdentity(&quot;triggerName&quot;,&quot;triggerGroupName&quot;)</span></span><br><span class="line"><span class="comment">            .startNow()</span></span><br><span class="line"><span class="comment">            .withSchedule(SimpleScheduleBuilder</span></span><br><span class="line"><span class="comment">                    .simpleSchedule()</span></span><br><span class="line"><span class="comment">                    .withIntervalInSeconds(2)</span></span><br><span class="line"><span class="comment">                    .repeatForever())</span></span><br><span class="line"><span class="comment">            .build();*/</span></span><br><span class="line">    scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line">    scheduler.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;todo something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>什么是分布式任务调度</p>
<ul>
<li>通常任务调度的程序是集成在应用中的，比如<ul>
<li>优惠券服务汇总包括了定时发布优惠券的调度程序</li>
<li>结算服务中包括了定期生成报表的任务调度程序</li>
</ul>
</li>
<li>由于采用分布式架构，一个服务通常会部署在多个冗余实例来运行我们的业务</li>
<li>在这种分布式环境下运行任务调度，就称之为分布式业务调度<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160049197.png" alt="img"></li>
</ul>
</li>
<li><p>分布式调度要实现的目标</p>
<ul>
<li>不管是任务调度程序集成在应用程序中，还是单独构建的任务调度系统，如果采用分布式调度任务的方式，就相当于将任务调度程序分布式构建，这样就可以具有分布式系统的特点，并且提高任务的调度处理能力</li>
</ul>
<ol>
<li>并行任务调度<ul>
<li>并行任务调度实现靠多线程，如果有大量任务需要调度，此时光靠多线程就会有瓶颈了，因为一台计算机的CPU处理能力是有限的</li>
<li>如果将任务调度程序分布式部署，每个节点还可以部署为集群，这样就可以让多台计算机共同去完成任务调度，我们可以将任务分割为若干个分片，由不同的实例并行执行，来提高任务调度的处理效率</li>
</ul>
</li>
<li>高可用<ul>
<li>若某一个实例宕机，不影响其他实例来执行任务</li>
</ul>
</li>
<li>弹性扩容<ul>
<li>当集群中增加实例就可以提高并执行任务的处理效率</li>
</ul>
</li>
<li>任务管理与检测<ul>
<li>对系统中存在的定时任进行统一的管理及监测，让开发人员及运维人员能够及时了解任务执行情况，从而做出快速应急处理响应</li>
</ul>
</li>
<li>避免任务重复执行<ul>
<li>当任务调度以集群方式部署，同一个任务调度可能会执行多次，比如上面提到的电商系统中定时发放优惠券的例子，就会发放多次优惠券，对公司造成很多损失，所以我们需要控制相同的任务在多个运行实例上只执行一次</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="XXL-JOB介绍"><a href="#XXL-JOB介绍" class="headerlink" title="XXL-JOB介绍"></a>XXL-JOB介绍</h3><ul>
<li><p>XXL-JOB是一个轻量级分布式任务调度平台，其核心设计是开发迅速、学习简单、轻量级、易扩展，现已开放源代码并接入多家公司线上产品线，开箱即用</p>
</li>
<li><p>官网：<a target="_blank" rel="noopener" href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p>
</li>
<li><p>XXL-JOB主要由调度中心、执行器、任务</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038334.png" alt="img"></p>
<ul>
<li>调度中心<ul>
<li>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码</li>
<li>主要职责为执行器管理、任务管理、监控运维、日志管理等</li>
</ul>
</li>
<li>任务执行器<ul>
<li>负责接收调度请求并执行任务逻辑</li>
<li>知道职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等</li>
</ul>
</li>
<li>任务<ul>
<li>负责执行具体的业务逻辑</li>
</ul>
</li>
</ul>
</li>
<li><p>调度中心与执行器之间的工作流程如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160054757.png" alt="img"></p>
</li>
<li><p>执行流程</p>
<ol>
<li>任务执行器根据配置的调度中心的地址，自动注册到调度中心</li>
<li>达到任务出发条件，调度中心下发任务</li>
<li>执行器基于线程池执行任务，并把执行结果放入内存队列、把执行日志写入日志文件中</li>
<li>执行器消费内存队列中的执行结果，主动上报给调度中心</li>
<li>当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情</li>
</ol>
</li>
</ul>
<h3 id="搭建XXL-JOB"><a href="#搭建XXL-JOB" class="headerlink" title="搭建XXL-JOB"></a>搭建XXL-JOB</h3><h4 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h4><ul>
<li><p>首先下载XXL-JOB</p>
<ul>
<li>GitHub：<a target="_blank" rel="noopener" href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></li>
<li>GitEE：<a target="_blank" rel="noopener" href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></li>
<li>项目使用2.3.1版本： <a target="_blank" rel="noopener" href="https://github.com/xuxueli/xxl-job/releases/tag/2.3.1">https://github.com/xuxueli/xxl-job/releases/tag/2.3.1</a></li>
</ul>
</li>
<li><p>使用IDEA打开项目</p>
<ul>
<li>xxl-job-admin：调度中心</li>
<li>xxl-job-core：公共依赖</li>
<li>xxj-job-executor-samples：执行器Sample示例<ul>
<li>xxl-job-executor-sample-springboot：SpringBoot版本，通过SpringBoot管理执行器</li>
<li>xxl-job-executor-sample-frameless：无框架版本</li>
</ul>
</li>
</ul>
</li>
<li><p>根据数据库脚本创建数据库，修改数据库连接信息和端口，启动xxl-job-admin，访问</p>
<p><a target="_blank" rel="noopener" href="http://local:18088/xxl-job-admin/">http://local:18088/xxl-job-admin/</a></p>
<ul>
<li>账号密码：admin&#x2F;123456<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038789.png" alt="img"></li>
</ul>
</li>
<li><p>启动成功之后，可以选择在Linux上运行</p>
<ul>
<li><p>使用maven命令，将xxl-job-admin打包，然后将其上传至Linux中，使用命令启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar /绝对路径/xxl-job-admin-2.3.1.jar &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><ul>
<li><p>下面配置执行器，执行器负责与调度中心通信，接收调度中心发起的任务调度请求</p>
<ol>
<li><p>首先在media-service工程中添加依赖（父工程中完成了版本控制，这里的版本是2.3.1）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在nacos下的media-service-dev.yaml下配置xxl-job</p>
<ul>
<li><p>注意这里配置的appname是执行器的应用名，稍后会在调度中心配置执行器的时候使用</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">xxl</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">job</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">admin</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">addresses</span>: <span class="string">http://192.168.101.128:18088/xxl-job-admin/</span></span><br><span class="line">    <span class="attr">executor</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">appname</span>: <span class="string">media-process-service</span></span><br><span class="line">      <span class="attr">address</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">ip</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">port</span>: <span class="string">9999</span></span><br><span class="line">      <span class="attr">logpath</span>: <span class="string">/data/applogs/xxl-job-jobhandler</span></span><br><span class="line">      <span class="attr">logretentiondays</span>: <span class="string">30</span></span><br><span class="line">    <span class="attr">accessToken</span>: <span class="string">default_token</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置xxl-job的执行器</p>
<ul>
<li><p>将示例工程下的配置类拷贝到media-service工程下，该类中的属性就是获取配置文件中的配置得到的，同时提供了一个执行器的Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 针对多网卡、容器内部署等情况，可借助 &quot;spring-cloud-commons&quot; 提供的 &quot;InetUtils&quot; 组件灵活定制注册IP；</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *      1、引入依赖：</span></span><br><span class="line"><span class="comment">    *          &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    *             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    *             &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    *             &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    *         &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *      2、配置文件，或者容器启动变量</span></span><br><span class="line"><span class="comment">    *          spring.cloud.inetutils.preferred-networks: &#x27;xxx.xxx.xxx.&#x27;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *      3、获取IP</span></span><br><span class="line"><span class="comment">    *          String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>进入调度中心，添加执行器<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160055001.png" alt="img"></p>
</li>
</ol>
</li>
<li><p>重启媒资管理服务模块，可以看到执行器在调入中心注册成功<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038308.png" alt="img"></p>
</li>
</ul>
<h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><ul>
<li><p>下面编写任务，任务类的编写方法参考示例工程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxl.job.executor.service.jobhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.context.XxlJobHelper;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XxlJob开发示例（Bean模式）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开发步骤：</span></span><br><span class="line"><span class="comment"> *      1、任务开发：在Spring Bean实例中，开发Job方法；</span></span><br><span class="line"><span class="comment"> *      2、注解配置：为Job方法添加注解 &quot;<span class="doctag">@XxlJob</span>(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。</span></span><br><span class="line"><span class="comment"> *      3、执行日志：需要通过 &quot;XxlJobHelper.log&quot; 打印执行日志；</span></span><br><span class="line"><span class="comment"> *      4、任务结果：默认任务结果为 &quot;成功&quot; 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 &quot;XxlJobHelper.handleFail/handleSuccess&quot; 自主设置任务结果；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuxueli 2019-12-11 21:52:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleXxlJob</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SampleXxlJob.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、简单任务示例（Bean模式）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;XXL-JOB, Hello World.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;beat at:&quot;</span> + i);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// default success</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、分片广播任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分片参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shardTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == shardIndex) &#123;</span><br><span class="line">                XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 命中分片开始处理&quot;</span>, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 忽略&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、命令行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;commandJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commandJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> XxlJobHelper.getJobParam();</span><br><span class="line">        <span class="type">int</span> <span class="variable">exitValue</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// command process</span></span><br><span class="line">            <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">            processBuilder.command(command);</span><br><span class="line">            processBuilder.redirectErrorStream(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">            <span class="comment">//Process process = Runtime.getRuntime().exec(command);</span></span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(process.getInputStream());</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(bufferedInputStream));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// command log</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                XxlJobHelper.log(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// command exit</span></span><br><span class="line">            process.waitFor();</span><br><span class="line">            exitValue = process.exitValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XxlJobHelper.log(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exitValue == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// default success</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            XxlJobHelper.handleFail(<span class="string">&quot;command exit value(&quot;</span>+exitValue+<span class="string">&quot;) is failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、跨平台Http任务</span></span><br><span class="line"><span class="comment">     *  参数示例：</span></span><br><span class="line"><span class="comment">     *      &quot;url: http://www.baidu.com\n&quot; +</span></span><br><span class="line"><span class="comment">     *      &quot;method: get\n&quot; +</span></span><br><span class="line"><span class="comment">     *      &quot;data: content\n&quot;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;httpJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">httpJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// param parse</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> XxlJobHelper.getJobParam();</span><br><span class="line">        <span class="keyword">if</span> (param==<span class="literal">null</span> || param.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;param[&quot;</span>+ param +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] httpParams = param.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String httpParam: httpParams) &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpParam.startsWith(<span class="string">&quot;url:&quot;</span>)) &#123;</span><br><span class="line">                url = httpParam.substring(httpParam.indexOf(<span class="string">&quot;url:&quot;</span>) + <span class="number">4</span>).trim();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (httpParam.startsWith(<span class="string">&quot;method:&quot;</span>)) &#123;</span><br><span class="line">                method = httpParam.substring(httpParam.indexOf(<span class="string">&quot;method:&quot;</span>) + <span class="number">7</span>).trim().toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (httpParam.startsWith(<span class="string">&quot;data:&quot;</span>)) &#123;</span><br><span class="line">                data = httpParam.substring(httpParam.indexOf(<span class="string">&quot;data:&quot;</span>) + <span class="number">5</span>).trim();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// param valid</span></span><br><span class="line">        <span class="keyword">if</span> (url==<span class="literal">null</span> || url.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;url[&quot;</span>+ url +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method==<span class="literal">null</span> || !Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>).contains(method)) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;method[&quot;</span>+ method +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isPostMethod</span> <span class="operator">=</span> method.equals(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// request</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// connection</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">realUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">            connection = (HttpURLConnection) realUrl.openConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// connection setting</span></span><br><span class="line">            connection.setRequestMethod(method);</span><br><span class="line">            connection.setDoOutput(isPostMethod);</span><br><span class="line">            connection.setDoInput(<span class="literal">true</span>);</span><br><span class="line">            connection.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">            connection.setReadTimeout(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            connection.setConnectTimeout(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Accept-Charset&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do connection</span></span><br><span class="line">            connection.connect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// data</span></span><br><span class="line">            <span class="keyword">if</span> (isPostMethod &amp;&amp; data!=<span class="literal">null</span> &amp;&amp; data.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(connection.getOutputStream());</span><br><span class="line">                dataOutputStream.write(data.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                dataOutputStream.flush();</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// valid StatusCode</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> connection.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (statusCode != <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Http Request StatusCode(&quot;</span> + statusCode + <span class="string">&quot;) Invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// result</span></span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(connection.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                result.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">responseMsg</span> <span class="operator">=</span> result.toString();</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.log(responseMsg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XxlJobHelper.log(e);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                    connection.disconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                XxlJobHelper.log(e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5、生命周期任务示例：任务初始化与销毁时，支持自定义相关逻辑；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;demoJobHandler2&quot;, init = &quot;init&quot;, destroy = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;XXL-JOB, Hello World.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们现在参考简单示例自己编写代码，在media-service下新建包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.xuecheng.media.service.jobhandler</span><br></pre></td></tr></table></figure>

<p>，在该包下定义我们的任务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.media.service.jobhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;testJob&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始执行.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进入调度中心添加任务，进入任务管理，新增任务信息<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160055168.png" alt="img"></p>
</li>
<li><p>其中JobHandler中填写@XxlJob注解中的名称</p>
</li>
<li><p>随后启动任务，控制台可以看到执行器的方法执行<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160055252.png" alt="img"></p>
</li>
</ul>
<h3 id="分片广播"><a href="#分片广播" class="headerlink" title="分片广播"></a>分片广播</h3><ul>
<li><p>前面我们了解了一下xxl-job的基本使用，下面思考如何进行分布式任务处理呢？</p>
<ul>
<li>我们需要启动多个执行器组成一个集群，去执行任务<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/pSjh7QA.png" alt="img"></li>
</ul>
</li>
<li><p>执行器在集群部署下调度中心有哪些调度策略呢？</p>
<ul>
<li><p>查看xxl-job官方文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 高级配置：</span><br><span class="line">    - 路由策略：当执行器集群部署时，提供丰富的路由策略，包括；</span><br><span class="line">        - FIRST（第一个）：固定选择第一个机器；</span><br><span class="line">        - LAST（最后一个）：固定选择最后一个机器；</span><br><span class="line">        - ROUND（轮询）：；</span><br><span class="line">        - RANDOM（随机）：随机选择在线的机器；</span><br><span class="line">        - CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</span><br><span class="line">        - LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</span><br><span class="line">        - LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</span><br><span class="line">        - FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</span><br><span class="line">        - BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</span><br><span class="line">        - SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>我们这里重点要说的是<code>SHARDING_BROADCAST(分片广播)</code>，分片是指调度中心将集群汇总的执行器标上序号：0、1、2、3…，广播是指每次调度会向集群中的所有执行器发送调度请求，请求中携带分片参数<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038663.png" alt="img"></p>
</li>
<li><p>每个执行器收到调度请求，根据分片参数自行决定是否执行任务</p>
</li>
<li><p>另外xxl-job还支持动态分片，当执行器数量有变更时，调度中心会动态修改分片的数量</p>
</li>
<li><p>作业分片适用于哪些场景呢？</p>
<ul>
<li>分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍</li>
<li>广播任务场景：广播执行器同时运行shell脚本、广播集群节点进行缓存更新等</li>
</ul>
</li>
<li><p>所以广播分片方式不仅可以充分发挥每个执行器的能力，并且根据分片参数可以控制任务是否执行，最终灵活控制了执行器集群的分布式处理任务</p>
</li>
<li><p>使用说明</p>
<ul>
<li><p>分片广播和普通任务开发流程一致，不同之处在于可以获取分片参数进行分片业务处理</p>
</li>
<li><p>获取分片参数方式，参考示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、分片广播任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">    XxlJobHelper.log(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shardTotal; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == shardIndex) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 命中分片开始处理&quot;</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 忽略&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>下面测试作业分片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@XxlJob(&quot;shardingJobHandler&quot;)</span><br><span class="line">public void shardingJob() &#123;</span><br><span class="line">    int shardIndex = XxlJobHelper.getShardIndex();</span><br><span class="line">    int shardTotal = XxlJobHelper.getShardTotal();</span><br><span class="line">    log.debug(&quot;shardIndex:&#123;&#125;, shardTotal:&#123;&#125;&quot;, shardIndex, shardTotal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在调度中心添加任务，注意路由策略选择分片广播</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160056689.png" alt="img"></p>
<ul>
<li>高级配置说明<ul>
<li>子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度，通过子任务可以实现一个任务执行完成去执行另一个任务。<ul>
<li>调度过期策略：<ul>
<li>忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；</li>
<li>立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；</li>
</ul>
</li>
<li>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；<ul>
<li>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</li>
<li>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</li>
<li>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</li>
</ul>
</li>
<li>任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；</li>
<li>失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>下面我们需要启动两个执行器实例，观察每个实例的执行情况</p>
</li>
<li><p>首先我们需要在nacos中编辑media-service的配置，设置本地配置优先</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">   config:</span><br><span class="line">    override-none: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>将media-service启动两个实例，添加的vm选项就是用本地配置覆盖nacos中的配置，主要是修改端口号和xxl执行器端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dserver.port=53051 -Dxxl.job.executor.port=9998  对应如下配置项</span><br><span class="line">server: </span><br><span class="line">  port: 53051</span><br><span class="line">xxl:</span><br><span class="line">  job:</span><br><span class="line">    executor:</span><br><span class="line">      port: 9998</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038759.png" alt="img"></p>
</li>
<li><p>将两个服务启动，观察任务调度中心，可以看到有两个执行器<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160056615.png" alt="img"></p>
</li>
<li><p>启动任务，可以从日志中看到，两个实例的分片序号不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 实例1</span><br><span class="line">[SimpleJob.java:25] - shardIndex:0, shardTotal:2</span><br><span class="line"></span><br><span class="line"># 实例2</span><br><span class="line">[SimpleJob.java:25] - shardIndex:1, shardTotal:2</span><br></pre></td></tr></table></figure>
</li>
<li><p>到此作业分片任务调试完成，此时我们来思考一下</p>
<ul>
<li>当一次分片广播到来，各执行器如何根据分片参数去分布式执行任务，保证执行器之间执行的任务不重复呢？</li>
</ul>
</li>
</ul>
<h2 id="需求分析-3"><a href="#需求分析-3" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="作业分片方案"><a href="#作业分片方案" class="headerlink" title="作业分片方案"></a>作业分片方案</h3><ul>
<li>任务添加成功后，对于要处理的任务，会添加到待处理任务表中，现在启动多个执行器实例去查询这些待处理任务，此时如何保证多个执行器不会重复执行任务？<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160057472.png" alt="img"></li>
<li>在上一小节的测试中，每个执行器收到广播任务有两个参数，分片序号和分片总数<ul>
<li>每个执行器从数据表取任务时，可以用<code>任务id</code>对<code>分片总数</code>取<code>模</code>，如果等于该执行器的分片序号，则执行此任务</li>
<li>例如<ul>
<li>1 % 2 &#x3D; 1，执行器2执行</li>
<li>2 % 2 &#x3D; 0，执行器1执行</li>
<li>3 % 2 &#x3D; 1，执行器2执行</li>
<li>4 % 2 &#x3D; 1，执行器1执行</li>
<li>以此类推</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="保证任务不重复执行"><a href="#保证任务不重复执行" class="headerlink" title="保证任务不重复执行"></a>保证任务不重复执行</h3><ul>
<li><p>通过作业分片方案，保证了执行器之间分配的任务不重复执行</p>
</li>
<li><p>但是如果同一个执行器，在处理一个视频的时候，还没有处理完，此时调度中心又来了一次请求调度，为了不重复处理同一个视频，该怎么办？</p>
</li>
<li><p>首先配置调度过期策略</p>
<ul>
<li>调度过期策略：<ul>
<li>忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；</li>
<li>立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；</li>
</ul>
</li>
</ul>
</li>
<li><p>这里我们选择<code>忽略</code>，如果立即执行一次，可能会重复调度</p>
</li>
<li><p>其次，我们在看阻塞处理策略。</p>
</li>
<li><p>阻塞处理策略就是当前执行器正在执行任务还没有结束时，调度中心又请求调度，此时该如何处理</p>
<ul>
<li>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；<ul>
<li>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</li>
<li>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</li>
<li>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</li>
</ul>
</li>
</ul>
</li>
<li><p>这里选择<code>丢弃后续调度</code>，避免重复调度</p>
</li>
<li><p>最后，也就是要注意保证任务处理的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">幂等性</span><br></pre></td></tr></table></figure>

<p>，什么是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务的幂等性</span><br></pre></td></tr></table></figure>

<p>？</p>
<ul>
<li>任务的幂等性是指：对于数据的操作不论多少次，操作的结果始终是一致的。</li>
</ul>
</li>
<li><p>执行器接收调度请求去执行任务，要有办法去判断该任务是否处理完成，如果处理完则不再处理，即使重复调度处理相同的任务也不能重复处理相同的视频。</p>
</li>
<li><p>什么是幂等性？</p>
<ul>
<li>它描述了一次和多次请求某一个资源，对于资源本身应该具有相同的结果</li>
</ul>
</li>
<li><p>幂等性是为了解决重复提交问题，比如：恶意刷单、重复支付等</p>
</li>
<li><p>解决幂等性常用的方案</p>
<ol>
<li>数据库约束，例如：唯一索引、主键</li>
<li>乐观锁，长用户数据库，更新数据时根据乐观锁状态去更新</li>
<li>唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等，则执行</li>
</ol>
</li>
<li><p>这里我们在数据库视频处理表中添加状态处理字段，视频处理完成更新状态为完成，执行视频前判断状态是否完成，如果完成则不再处理</p>
</li>
</ul>
<h3 id="业务流程-2"><a href="#业务流程-2" class="headerlink" title="业务流程"></a>业务流程</h3><ul>
<li><p>确定了分片方案，下面梳理哼歌视频上传以及处理的业务流程<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160109212.png" alt="image-20230616010916018"></p>
</li>
<li><p>上传视频成功，向视频待处理表中添加记录，视频处理的详细流程如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160109375.png" alt="img"></p>
</li>
</ul>
<ol>
<li>任务调度中心广播作业分片</li>
<li>执行器收到广播作业分片，从数据库读取待处理任务</li>
<li>执行器根据任务内容MinIO下载要处理的文件</li>
<li>执行器启动多线程去处理任务</li>
<li>任务处理完成，上传处理后的视频到MinIO</li>
<li>将更新任务处理结果，如果视频处理完成，除了更新任务处理结果之外，还要将文件的访问地址更新至任务处理表及文件中，最后将任务完成记录写入历史表</li>
</ol>
<ul>
<li>下面是待处理任务表<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/pSva4sJ.png" alt="img"></li>
</ul>
<h2 id="查询待处理任务"><a href="#查询待处理任务" class="headerlink" title="查询待处理任务"></a>查询待处理任务</h2><h3 id="添加待处理任务"><a href="#添加待处理任务" class="headerlink" title="添加待处理任务"></a>添加待处理任务</h3><ul>
<li>上传视频成功，向视频处理待处理表添加记录，暂时只添加.avi类型视频的处理记录</li>
<li>根据Mime Type去判断，是否为avi视频，下面列出部分Mime Type</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Video Type</th>
<th align="center">Extension</th>
<th align="center">MIME Type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Flash</td>
<td align="center">fl</td>
<td align="center">video&#x2F;x-flv</td>
</tr>
<tr>
<td align="center">MPEG-4</td>
<td align="center">.mp4</td>
<td align="center">video&#x2F;mp4</td>
</tr>
<tr>
<td align="center">iPhone Index</td>
<td align="center">.m3u8</td>
<td align="center">application&#x2F;x-mpegURL</td>
</tr>
<tr>
<td align="center">iPhone Segment</td>
<td align="center">.ts</td>
<td align="center">video&#x2F;MP2T</td>
</tr>
<tr>
<td align="center">3GP Mobile</td>
<td align="center">.3gp</td>
<td align="center">video&#x2F;3gpp</td>
</tr>
<tr>
<td align="center">QuickTime</td>
<td align="center">.mov</td>
<td align="center">video&#x2F;quicktime</td>
</tr>
<tr>
<td align="center">A&#x2F;V Interleave</td>
<td align="center">.avi</td>
<td align="center">video&#x2F;x-msvideo</td>
</tr>
<tr>
<td align="center">Windows Media</td>
<td align="center">.wmv</td>
<td align="center">video&#x2F;x-ms-wmv</td>
</tr>
</tbody></table>
<ul>
<li><p>avi视频的Mine Type是video&#x2F;x-msvideo</p>
</li>
<li><p>修改addMediaFilesToDB方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文件信息添加到文件表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uploadFileParamsDto 上传文件的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileMD5             文件的md5码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket              桶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> MediaFiles <span class="title function_">addMediaFilesToDB</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据文件名获取Content-Type</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> getContentType(objectName);</span><br><span class="line">        <span class="comment">// 保存到数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> mediaFilesMapper.selectById(fileMD5);</span><br><span class="line">        <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span>) &#123;</span><br><span class="line">            mediaFiles = <span class="keyword">new</span> <span class="title class_">MediaFiles</span>();</span><br><span class="line">            BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles);</span><br><span class="line">            mediaFiles.setId(fileMD5);</span><br><span class="line">            mediaFiles.setFileId(fileMD5);</span><br><span class="line">            mediaFiles.setCompanyId(companyId);</span><br><span class="line">            mediaFiles.setBucket(bucket);</span><br><span class="line">            mediaFiles.setCreateDate(LocalDateTime.now());</span><br><span class="line">            mediaFiles.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            mediaFiles.setFilePath(objectName);</span><br><span class="line">            <span class="keyword">if</span> (contentType.contains(<span class="string">&quot;image&quot;</span>) || contentType.contains(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">                mediaFiles.setUrl(<span class="string">&quot;/&quot;</span> + bucket + <span class="string">&quot;/&quot;</span> + objectName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查阅数据字典，002003表示审核通过</span></span><br><span class="line">            mediaFiles.setAuditStatus(<span class="string">&quot;002003&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> mediaFilesMapper.insert(mediaFiles);</span><br><span class="line">        <span class="keyword">if</span> (insert &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;保存文件信息失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">+       <span class="comment">// 如果是avi视频，则额外添加至视频待处理表</span></span><br><span class="line">+       <span class="keyword">if</span> (<span class="string">&quot;video/x-msvideo&quot;</span>.equals(contentType)) &#123;</span><br><span class="line">+           <span class="type">MediaProcess</span> <span class="variable">mediaProcess</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaProcess</span>();</span><br><span class="line">+           BeanUtils.copyProperties(mediaFiles, mediaProcess);</span><br><span class="line">+           mediaProcess.setStatus(<span class="string">&quot;1&quot;</span>); <span class="comment">// 未处理</span></span><br><span class="line">+           <span class="type">int</span> <span class="variable">processInsert</span> <span class="operator">=</span> mediaProcessMapper.insert(mediaProcess);</span><br><span class="line">+           <span class="keyword">if</span> (processInsert &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">+               XueChengPlusException.cast(<span class="string">&quot;保存avi视频到待处理表失败&quot;</span>);</span><br><span class="line">+           &#125;</span><br><span class="line">+       &#125;</span><br><span class="line">        <span class="keyword">return</span> mediaFiles;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查询待处理任务-1"><a href="#查询待处理任务-1" class="headerlink" title="查询待处理任务"></a>查询待处理任务</h3><ul>
<li><p>如何保证查询到的待处理视频记录不重复？</p>
<ul>
<li><p>解决方案我们前面已经给出了，用<strong>任务id</strong>对<strong>分片总数</strong>取模，如果等于该执行器的<strong>分片序号</strong>，则执行，同时为了避免同一个任务被执行两次，我们需要额外指定任务状态为未处理，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status = 1</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> media_process <span class="keyword">WHERE</span> id <span class="operator">%</span> #&#123;shareTotal&#125; <span class="operator">=</span> #&#123;shareIndex&#125; <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> LIMIT #&#123;count&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编写根据分片参数获取待处理任务的DAO方法，定义DAO接口如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据分片参数获取待处理任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shardTotal    分片总数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shardIndex    分片序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count         任务数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM media_process WHERE id % #&#123;shardTotal&#125; = #&#123;shardIndex&#125; AND status = &#x27;1&#x27; LIMIT #&#123;count&#125;&quot;)</span></span><br><span class="line">List&lt;MediaProcess&gt; <span class="title function_">selectListByShardIndex</span><span class="params">(<span class="meta">@Param(&quot;shardTotal&quot;)</span> <span class="type">int</span> shardTotal, <span class="meta">@Param(&quot;shardIndex&quot;)</span> <span class="type">int</span> shardIndex, <span class="meta">@Param(&quot;count&quot;)</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义Service接口，查询待处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaFileProcessService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取待处理任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardIndex    分片序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardTotal    分片总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count         获取记录数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  待处理任务集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;MediaProcess&gt; <span class="title function_">getMediaProcessList</span><span class="params">(<span class="type">int</span> shardIndex, <span class="type">int</span> shardTotal, <span class="type">int</span> count)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaFileProcessServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MediaFileProcessService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaProcessMapper mediaProcessMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MediaProcess&gt; <span class="title function_">getMediaProcessList</span><span class="params">(<span class="type">int</span> shardIndex, <span class="type">int</span> shardTotal, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mediaProcessMapper.selectListByShardIndex(shardTotal, shardIndex, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="更新任务状态"><a href="#更新任务状态" class="headerlink" title="更新任务状态"></a>更新任务状态</h2><ul>
<li><p>任务处理完成后，需要更新任务处理结果，任务执行成功，则更新视频的URL、及任务处理结果，将待处理任务记录删除，同时向历史任务表添加记录</p>
</li>
<li><p>定义Service接口，更新任务状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">saveProcessFinishStatus</span><span class="params">(Long taskId, String status, String fileId, String url, String errorMsg)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveProcessFinishStatus</span><span class="params">(Long taskId, String status, String fileId, String url, String errorMsg)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询这个任务</span></span><br><span class="line">    <span class="type">MediaProcess</span> <span class="variable">mediaProcess</span> <span class="operator">=</span> mediaProcessMapper.selectById(taskId);</span><br><span class="line">    <span class="keyword">if</span> (mediaProcess == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;更新任务状态时，此任务：&#123;&#125;，为空&quot;</span>, taskId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LambdaQueryWrapper&lt;MediaProcess&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;MediaProcess&gt;().eq(MediaProcess::getId, taskId);</span><br><span class="line">    <span class="comment">// 如果任务失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;3&quot;</span>.equals(status)) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;任务失败：&#123;&#125;&quot;</span>, taskId);</span><br><span class="line">        <span class="type">MediaProcess</span> <span class="variable">mediaProcess_u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaProcess</span>();</span><br><span class="line">        mediaProcess_u.setStatus(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        mediaProcess_u.setErrormsg(errorMsg);</span><br><span class="line">        mediaProcess_u.setFinishDate(LocalDateTime.now());</span><br><span class="line">        mediaProcessMapper.update(mediaProcess_u, queryWrapper);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务成功，将其从待处理任务表中删除，同时新增历史处理表记录</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;2&quot;</span>.equals(status)) &#123;</span><br><span class="line">        mediaProcess.setStatus(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        mediaProcess.setUrl(url);</span><br><span class="line">        mediaProcess.setFinishDate(LocalDateTime.now());</span><br><span class="line">        mediaProcessMapper.update(mediaProcess, queryWrapper);</span><br><span class="line">        <span class="type">MediaProcessHistory</span> <span class="variable">mediaProcessHistory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaProcessHistory</span>();</span><br><span class="line">        <span class="comment">// 两张表的属性完全一致，直接拷贝</span></span><br><span class="line">        BeanUtils.copyProperties(mediaProcess, mediaProcessHistory);</span><br><span class="line">        <span class="comment">// 向历史处理表新增数据</span></span><br><span class="line">        mediaProcessHistoryMapper.insert(mediaProcessHistory);</span><br><span class="line">        <span class="comment">// 同时删除待处理任务表中的数据</span></span><br><span class="line">        mediaProcessMapper.deleteById(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="视频处理-1"><a href="#视频处理-1" class="headerlink" title="视频处理"></a>视频处理</h2><h3 id="什么是视频编码"><a href="#什么是视频编码" class="headerlink" title="什么是视频编码"></a>什么是视频编码</h3><ul>
<li><p>视频上传成功后，需要对视频进行转码处理</p>
</li>
<li><p>什么是视频编码？百度百科的定义如下</p>
<ul>
<li>所谓视频编码方式就是指通过压缩技术，将原始视频格式的文件转换成另一种视频格式文件的方式。视频流传输中最为重要的编解码标准有国际电联的H.261、H.263、H.264，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，此外在互联网上被广泛应用的还有Real-Networks的RealVideo、微软公司的WMV以及Apple公司的QuickTime等。</li>
</ul>
</li>
<li><p>首先我们要分清文件格式和编码格式</p>
<ul>
<li><code>文件格式</code>是指：<code>.mp4</code>、<code>.avi</code>、<code>.rmvb</code>等这些不同扩展名的视频文件的文件格式。视频文件的内容主要包括视频、音频，其文件格式是按照一定的编码格式去编码，并且按照该文件所规定的的封装格式，将视频、音频、字幕等信息封装到一起，播放器会根据他们的封装个事去提取出编码，然后由播放器解码，最终播放音视频</li>
<li><code>编码格式</code>是指：通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输。比如一个.avi的视频文件原来的编码是a，通过编码后编码格式变为b</li>
</ul>
</li>
<li><p>音视频编码格式种类繁多，主要由以下几类</p>
<ul>
<li><pre><code>MPEG系列
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （由ISO下属的MPEG开发）</span><br><span class="line"></span><br><span class="line">  - 视频编码方面主要是Mpeg1（VCD）、Mpeg2（DVD）、Mpeg4（divx，xvid）、Mpeg4 AVC</span><br><span class="line">  - 音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3（MP3）、MPEG-2 AAC 、MPEG-4 AAC</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  H.26X系列</span><br></pre></td></tr></table></figure>

（由ITU主导，侧重网络传输，注意：只是视频编码）

- 包括H.261、H.262、H.263、H.263+、H.263++、H.264
</code></pre>
</li>
</ul>
</li>
<li><p>目前最常用的编码标准是</p>
<ul>
<li>视频：H.264</li>
<li>音频：AAC</li>
</ul>
</li>
</ul>
<h3 id="FFmpeg的基本使用"><a href="#FFmpeg的基本使用" class="headerlink" title="FFmpeg的基本使用"></a>FFmpeg的基本使用</h3><ul>
<li><p>我们将视频录制完成后，使用视频编码软件第视频进行编码，本项目使用FFmpeg对视频进行编码</p>
</li>
<li><p>什么是FFmpeg？</p>
<ul>
<li>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频&#x2F;视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。</li>
<li>FFmpeg在Linux平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括Windows、Mac OS X等。这个项目最早由Fabrice Bellard发起，2004年至2015年间由Michael Niedermayer主要负责维护。许多FFmpeg的开发人员都来自MPlayer项目，而且当前FFmpeg也是放在MPlayer项目组的服务器上。项目的名称来自MPEG视频编码标准，前面的”FF”代表”Fast Forward”。FFmpeg编码库可以使用GPU加速。</li>
</ul>
</li>
<li><p>下载：<a target="_blank" rel="noopener" href="https://www.ffmpeg.org/download.html#build-windows">FFmpeg</a>，并将其加入环境变量</p>
</li>
<li><p>测试是否正常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装成功后，做一下简单测试，将.mp4文件转为.avi，再将.avi转为.gif等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 胶水.mp4 胶水.avi</span><br><span class="line"></span><br><span class="line">ffmpeg -i 胶水.avi 胶水.gif</span><br></pre></td></tr></table></figure>
</li>
<li><p>胶水是我家的猫猫</p>
</li>
</ul>
<h3 id="视频处理工具类"><a href="#视频处理工具类" class="headerlink" title="视频处理工具类"></a>视频处理工具类</h3><ul>
<li><p>导入黑马提供的工具类，将其拷贝至base工程</p>
</li>
<li><p>其中Mp4VideoUtil类是用于将视频转为mp4格式，是我们项目要使用的工具类</p>
</li>
<li><p>下面我们来简单了解一下该类的使用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//ffmpeg的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ffmpeg_path</span> <span class="operator">=</span> <span class="string">&quot;D:\\SoftWare\\ffmpeg\\ffmpeg.exe&quot;</span>;<span class="comment">//ffmpeg的安装位置</span></span><br><span class="line">    <span class="comment">//源avi视频的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">video_path</span> <span class="operator">=</span> <span class="string">&quot;D:\\BaiduNetdiskDownload\\星际牛仔1998\\胶水.avi&quot;</span>;</span><br><span class="line">    <span class="comment">//转换后mp4文件的名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mp4_name</span> <span class="operator">=</span> <span class="string">&quot;胶水_mp4.mp4&quot;</span>;</span><br><span class="line">    <span class="comment">//转换后mp4文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mp4_path</span> <span class="operator">=</span> <span class="string">&quot;D:\\BaiduNetdiskDownload\\星际牛仔1998\\胶水_mp4.mp4&quot;</span>;</span><br><span class="line">    <span class="comment">//创建工具类对象</span></span><br><span class="line">    <span class="type">Mp4VideoUtil</span> <span class="variable">videoUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mp4VideoUtil</span>(ffmpeg_path,video_path,mp4_name,mp4_path);</span><br><span class="line">    <span class="comment">//开始视频转换，成功将返回success</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> videoUtil.generateMp4();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行main方法，最终在控制台输出<code>success</code>表示执行成功</p>
</li>
</ul>
<h3 id="任务类"><a href="#任务类" class="headerlink" title="任务类"></a>任务类</h3><ul>
<li><p>视频采用并发处理，每个视频使用一个线程去处理，每次处理的视频数量不要超过cpu核心数</p>
</li>
<li><p>所有视频处理完成后，结束本次执行，为了防止代码出现异常而无限等待，添加超时设置，到达超时时间还没有处理完成，仍结束任务</p>
</li>
<li><p>代码思路如下</p>
<ol>
<li>根据分片序号和分片总数，查询待处理任务</li>
<li>启动多线程去处理</li>
<li>将原始视频下载到本地</li>
<li>调用工具类将avi转为mp4</li>
<li>上传到MinIO</li>
<li>记录任务处理结果url</li>
</ol>
</li>
<li><p>定义任务类VideoTask如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoTask</span> &#123;</span><br><span class="line">    <span class="comment">// 从配置文件中获取ffmpeg的安装位置</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;videoprocess.ffmpegpath&#125;&quot;)</span></span><br><span class="line">    String ffmpegPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaProcessMapper mediaProcessMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaFileService mediaFileService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaFileProcessService mediaFileProcessService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(&quot;videoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">videoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 分片序号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">        <span class="comment">// 分片总数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">        <span class="comment">// 查询待处理任务，一次处理的任务数与cpu核心数相同</span></span><br><span class="line">        List&lt;MediaProcess&gt; mediaProcessList = mediaFileProcessService.getMediaProcessList(shardTotal, shardIndex, <span class="number">12</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(mediaProcessList.size());</span><br><span class="line">        <span class="comment">// 未查询到待处理任务，结束方法</span></span><br><span class="line">        <span class="keyword">if</span> (mediaProcessList == <span class="literal">null</span> || mediaProcessList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;查询到的待处理任务数为0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要处理的任务数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mediaProcessList.size();</span><br><span class="line">        <span class="comment">// 查询到任务，创建size个线程去处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(size);</span><br><span class="line">        mediaProcessList.forEach(mediaProcess -&gt; threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> mediaProcess.getStatus();</span><br><span class="line">            <span class="comment">// 避免重复执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;2&quot;</span>.equals(status)) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;该视频已经被处理，无需再次处理。视频信息：&#123;&#125;&quot;</span>, mediaProcess);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 桶</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> mediaProcess.getBucket();</span><br><span class="line">            <span class="comment">// 文件路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> mediaProcess.getFilePath();</span><br><span class="line">            <span class="comment">// 原始文件的md5</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileId</span> <span class="operator">=</span> mediaProcess.getFileId();</span><br><span class="line">            <span class="type">File</span> <span class="variable">originalFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">File</span> <span class="variable">mp4File</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将原始视频下载到本地，创建临时文件</span></span><br><span class="line">                originalFile = File.createTempFile(<span class="string">&quot;original&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 处理完成后的文件</span></span><br><span class="line">                mp4File = File.createTempFile(<span class="string">&quot;mp4&quot;</span>, <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理视频前创建临时文件失败&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                XueChengPlusException.cast(<span class="string">&quot;处理视频前创建临时文件失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mediaFileService.downloadFileFromMinio(originalFile, bucket, filePath);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;下载原始文件过程中出错：&#123;&#125;，文件信息：&#123;&#125;&quot;</span>, e.getMessage(), mediaProcess);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                XueChengPlusException.cast(<span class="string">&quot;下载原始文件过程出错&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用工具类将avi转为mp4</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Mp4VideoUtil</span> <span class="variable">videoUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mp4VideoUtil</span>(ffmpegPath, originalFile.getAbsolutePath(), mp4File.getName(), mp4File.getAbsolutePath());</span><br><span class="line">                <span class="comment">// 获取转换结果，转换成功返回success 转换失败返回错误信息</span></span><br><span class="line">                result = videoUtil.generateMp4();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理视频失败，视频地址：&#123;&#125;，错误信息：&#123;&#125;&quot;</span>, originalFile.getAbsolutePath(), e.getMessage());</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                XueChengPlusException.cast(<span class="string">&quot;处理视频失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 转换成功，上传到MinIO</span></span><br><span class="line">            <span class="comment">// 设置默认状态为失败</span></span><br><span class="line">            status = <span class="string">&quot;3&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;success&quot;</span>.equals(result)) &#123;</span><br><span class="line">                <span class="comment">// 根据文件md5，生成objectName</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> mediaFileService.getFilePathByMd5(fileId, <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mediaFileService.addMediaFilesToMinIO(mp4File.getAbsolutePath(), bucket, objectName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;上传文件失败：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                    XueChengPlusException.cast(<span class="string">&quot;上传文件失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理成功，将状态设为成功</span></span><br><span class="line">                status = <span class="string">&quot;2&quot;</span>;   </span><br><span class="line">                <span class="comment">// 拼接url，准备更新数据</span></span><br><span class="line">                url = <span class="string">&quot;/&quot;</span> + bucket + <span class="string">&quot;/&quot;</span> + objectName;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录任务处理结果url</span></span><br><span class="line">            mediaFileProcessService.saveProcessFinishStatus(mediaProcess.getId(), status, fileId, url, result);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">// 等待，为了防止无线等待，这里设置一个超时时间为30分钟（很充裕了），若到时间还未处理完，则结束任务</span></span><br><span class="line">        countDownLatch.await(<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在media-service-dev.yaml中新增配置，指定ffmpeg安装位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">videoprocess:</span><br><span class="line">  ffmpegpath: D:\SoftWare\ffmpeg\ffmpeg.exe</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="视频处理测试"><a href="#视频处理测试" class="headerlink" title="视频处理测试"></a>视频处理测试</h2><ul>
<li>进入xxl-job调度中心添加执行器和视频处理任务</li>
<li>在xxl-job配置任务调度策略<ul>
<li>配置阻塞处理策略为：丢弃后续调度</li>
<li>配置视频处理调度时间间隔不用根据视频处理时间去确定，可以配置的小一些<ul>
<li>如：5分钟，即使到达调度时间，如果视频没有处理完成，仍丢弃调度请求</li>
</ul>
</li>
</ul>
</li>
<li>配置完成后开始测试视频处理<ol>
<li>首先上传至少4个视频，非mp4格式</li>
<li>在xxl-job启动视频处理任务</li>
<li>观察媒资管理服务后台日志</li>
</ol>
</li>
</ul>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="XXL-JOB工作原理"><a href="#XXL-JOB工作原理" class="headerlink" title="XXL-JOB工作原理"></a>XXL-JOB工作原理</h3><ol>
<li><p>xxl-job的工作原理是什么？xxl-job是什么？</p>
<ul>
<li><p>xxl-job分布式任务调度服务由调度中心和执行器组成，调度中心负责按任务调度策略向执行器下发任务，执行器负责接收任务，执行任务</p>
<ol>
<li><p>首先部署并启动xxl-job调度中心（一个java工程，打成jar包可以放到虚拟机上运行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar xxl-job-admin...  &amp; </span><br></pre></td></tr></table></figure>
</li>
<li><p>在微服务中添加xxl-job依赖，在微服务中配置执行器</p>
<ul>
<li>依赖</li>
<li>yml配置</li>
<li>配置类</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>启动微服务，执行器向调度中心上报自己</p>
</li>
<li><p>在微服务中写一个任务方法，并用xxl-job的注解去标记执行任务的方法名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;testJob&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始执行.......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在调度中心配置任务调度策略，调度策略就是每个多长时间执行，又或者是每天&#x2F;每月的固定时间去执行等</p>
</li>
<li><p>在调度中心启动任务</p>
</li>
<li><p>调度中心根据任务调度策略，到达时间就开始下发任务给执行器</p>
</li>
<li><p>执行器收到任务就开始执行任务</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>如何保证任务不重复执行？</p>
<ol>
<li>调度中心按<code>分片广播</code>的方式去下发任务</li>
<li>执行器收到作业分片广播的参数：分片总数(shardTotal)和分片序号(shardIndex)，计算<code>任务id % 分片总数</code>(taskId % shardTotal)，如果结果等于分片序号，就去执行这个任务(taskId % shardTotal &#x3D; shardIndex)。这样就可以保证不同的执行器执行不同的任务</li>
<li>配置调度过期策略为<code>忽略</code>，避免同一个执行器多次重复执行同一个任务</li>
<li>配置任务阻塞处理策略为<code>丢弃后续调度</code>，注意：丢弃也没事，下一次调度还可以执行</li>
<li>另外还要保证任务处理的幂等性，执行过的任务可以打一个状态标记已完成（上面的代码设置status&#x3D;2即为完成），下次再次调度该任务时，判断该任务已完成，就不再执行</li>
</ol>
</li>
<li><p>任务幂等性如何保证？</p>
<ul>
<li>幂等性描述的是依次和多次请求某一个资源，对于资源本身，应该返回同样的结果</li>
<li>幂等性是为了解决重复提交问题，例如：恶意刷单，重复支付等</li>
<li>解决幂等性的常用方案<ol>
<li>数据库约束，例如：唯一索引、主键</li>
<li>乐观锁：常用于数据库，更新数据时，根据乐观锁的状态去更新</li>
<li>唯一序列号，请求前生成的唯一序列号，携带序列号去请求，执行是在redis记录该序列号，用于表示该序列号请求已经执行过了，如果相同的序列号再次来执行，则说明是重复执行。这里的解决方式是在数据库中添加状态处理字段，视频处理完成，则更新该字段为已完成，执行视频处理之前判断状态是否为已完成，若已完成则不处理</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="绑定媒资-1"><a href="#绑定媒资-1" class="headerlink" title="绑定媒资"></a>绑定媒资</h1><h2 id="需求分析-4"><a href="#需求分析-4" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="业务流程-3"><a href="#业务流程-3" class="headerlink" title="业务流程"></a>业务流程</h3><ul>
<li>截至目前，媒资管理已经完成文件上传、视频处理等基本功能。那么本小节就来讲解课程计划绑定媒资文件</li>
<li>如何将课程计划绑定媒资文件呢？<ul>
<li>进入课程计划界面，在小节中点击<code>添加视频/文档/作业</code>按钮，输入关键字搜索，进行绑定即可</li>
</ul>
</li>
</ul>
<h3 id="数据模型-2"><a href="#数据模型-2" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>课程计划绑定媒资文件后，存储至<code>课程计划绑定媒资表</code>，即<code>teachplan_media</code>表中<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160058526.png" alt="img"></li>
</ul>
<h2 id="接口定义-3"><a href="#接口定义-3" class="headerlink" title="接口定义"></a>接口定义</h2><ul>
<li><p>根据业务流程，用户进入课程计划列表，首先确定向哪个课程计划添加视频，点击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加视频</span><br></pre></td></tr></table></figure>

<p>按钮后，用户选择视频，点击提交，前端以json格式请求以下参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请求网址: http:<span class="comment">//localhost:8601/api/content/teachplan/association/media</span></span><br><span class="line">请求方法: POST</span><br><span class="line">载荷：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mediaId&quot;</span>: <span class="string">&quot;a92da96ebcf28dfe194a1e2c393dd860&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fileName&quot;</span>: <span class="string">&quot;胶水.avi&quot;</span>,</span><br><span class="line">  <span class="string">&quot;teachplanId&quot;</span>: <span class="number">293</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从请求网址可以看出，该接口在内容管理模块提供，即在content-api中提供</p>
</li>
<li><p>请求方式为POST，那么我们定义一个DTO类用来接收请求参数，里面只包含载荷中的三个属性即可，在content-model中新建BindTeachplanMediaDto模型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;BindTeachplanMediaDto&quot;, description = &quot;教学计划-媒资绑定DTO&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BindTeachplanMediaDto</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;媒资文件id&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String mediaId;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;媒资文件名称&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程计划标识&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> Long teachplanId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在content-api下的TeachplanController中定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程计划与媒资信息绑定&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/teachplan/association/media&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(<span class="meta">@RequestBody</span> BindTeachplanMediaDto bindTeachplanMediaDto)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口开发-3"><a href="#接口开发-3" class="headerlink" title="接口开发"></a>接口开发</h2><h3 id="DAO开发-3"><a href="#DAO开发-3" class="headerlink" title="DAO开发"></a>DAO开发</h3><ul>
<li>使用自动生成的TeachplanMedia的Mapper即可</li>
</ul>
<h3 id="Service开发-3"><a href="#Service开发-3" class="headerlink" title="Service开发"></a>Service开发</h3><ul>
<li><p>根据需求定义Service接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 教学计划绑定媒资信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bindTeachplanMediaDto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(BindTeachplanMediaDto bindTeachplanMediaDto)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(BindTeachplanMediaDto bindTeachplanMediaDto)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">teachplanId</span> <span class="operator">=</span> bindTeachplanMediaDto.getTeachplanId();</span><br><span class="line">    <span class="comment">// 先根据请求参数查询出对应的教学计划teachplan</span></span><br><span class="line">    <span class="type">Teachplan</span> <span class="variable">teachplan</span> <span class="operator">=</span> teachplanMapper.selectById(teachplanId);</span><br><span class="line">    <span class="keyword">if</span> (teachplan == <span class="literal">null</span>) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;教学计划不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取教学计划的层级，只有第二层级允许绑定媒资信息（第二层级为小节，第一层级为章节）</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">grade</span> <span class="operator">=</span> teachplan.getGrade();</span><br><span class="line">    <span class="keyword">if</span> (grade != <span class="number">2</span>) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;只有小节允许绑定媒资信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定媒资，如果之前已经绑定过了媒资，再次绑定时为更新（例如该小节已经绑定了 星际牛仔.avi，现在改绑为 胶水.avi，其实现方式为先删再增）</span></span><br><span class="line">    LambdaQueryWrapper&lt;TeachplanMedia&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;TeachplanMedia&gt;().eq(TeachplanMedia::getTeachplanId, teachplanId);</span><br><span class="line">    teachplanMediaMapper.delete(queryWrapper);</span><br><span class="line">    <span class="type">TeachplanMedia</span> <span class="variable">teachplanMedia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeachplanMedia</span>();</span><br><span class="line">    teachplanMedia.setTeachplanId(bindTeachplanMediaDto.getTeachplanId());</span><br><span class="line">    teachplanMedia.setMediaFilename(bindTeachplanMediaDto.getFileName());</span><br><span class="line">    teachplanMedia.setMediaId(bindTeachplanMediaDto.getMediaId());</span><br><span class="line">    teachplanMedia.setCourseId(teachplan.getCourseId());</span><br><span class="line">    teachplanMedia.setCreateDate(LocalDateTime.now());</span><br><span class="line">    teachplanMediaMapper.insert(teachplanMedia);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口层完善-1"><a href="#接口层完善-1" class="headerlink" title="接口层完善"></a>接口层完善</h3><ul>
<li><p>调用service层的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程计划与媒资信息绑定&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/teachplan/association/media&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(<span class="meta">@RequestBody</span> BindTeachplanMediaDto bindTeachplanMediaDto)</span> &#123;</span><br><span class="line">    teachplanService.associationMedia(bindTeachplanMediaDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口测试-2"><a href="#接口测试-2" class="headerlink" title="接口测试"></a>接口测试</h3><ul>
<li>向指定课程计划添加视频，成功添加后，再次添加视频，则会替换掉原有的视频<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../pic/202306160038991.png" alt="img"></li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul>
<li><p>根据接口定义实现解除绑定功能</p>
<ul>
<li>点击已经绑定的视频名称即可解除绑定</li>
</ul>
</li>
<li><p>接口定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">delete /teachplan/association/media/&#123;teachPlanId&#125;/&#123;mediaId&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在TeachplanController中定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程计划解除媒资信息绑定&quot;)</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/teachplan/association/media/&#123;teachPlanId&#125;/&#123;mediaId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unassociationMedia</span><span class="params">(<span class="meta">@PathVariable</span> Long teachPlanId, <span class="meta">@PathVariable</span> Long mediaId)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据需求定义Service接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 解绑教学计划与媒资信息</span><br><span class="line"> * @param teachPlanId       教学计划id</span><br><span class="line"> * @param mediaId           媒资信息id</span><br><span class="line"> */</span><br><span class="line">void unassociationMedia(Long teachPlanId, Long mediaId);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unassociationMedia</span><span class="params">(Long teachPlanId, Long mediaId)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;TeachplanMedia&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(TeachplanMedia::getTeachplanId, teachPlanId)</span><br><span class="line">            .eq(TeachplanMedia::getMediaId, mediaId);</span><br><span class="line">    teachplanMediaMapper.delete(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完善接口层，调用service层的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程计划解除媒资信息绑定&quot;)</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/teachplan/association/media/&#123;teachPlanId&#125;/&#123;mediaId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unassociationMedia</span><span class="params">(<span class="meta">@PathVariable</span> Long teachPlanId, <span class="meta">@PathVariable</span> String mediaId)</span> &#123;</span><br><span class="line">    teachplanService.unassociationMedia(teachPlanId, mediaId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ADAN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/28/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/">http://example.com/2023/06/28/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://www.adan.com" target="_blank">ADAN</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">光明</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%AE%9E%E6%88%98/">java实战</a></div><div class="post_share"><div class="social-share" data-image="/img/4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/28/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97/" title="全文检索模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">全文检索模块</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/28/docker%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3/" title="docker操作文档"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">docker操作文档</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/28/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/" title="认证授权"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-28</div><div class="title">认证授权</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/king.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ADAN</div><div class="author-info__description">如有一味绝境，非历十方生死</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://weixin.com/" target="_blank" title="weixin"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://qq.com/" target="_blank" title="2028038953"><i class="iconfont icon-QQ"></i></a><a class="social-icon" href="mailto:2028038953@qq.com" target="_blank" title="2028038953@qq.com"><i class="iconfont icon-youxiang"></i></a><a class="social-icon" href="https://gitee.com/" target="_blank" title="gitee"><i class="iconfont icon-gitee"></i></a><a class="social-icon" href="https://bilibili.com/" target="_blank" title="bilibili"><i class="iconfont icon-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">模块需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">模块介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">业务流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87"><span class="toc-number">1.2.1.</span> <span class="toc-text">上传图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91"><span class="toc-number">1.2.2.</span> <span class="toc-text">上传视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">处理视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A1%E6%A0%B8%E5%AA%92%E8%B5%84"><span class="toc-number">1.2.4.</span> <span class="toc-text">审核媒资</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%AA%92%E8%B5%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">绑定媒资</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">数据模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">搭建模块环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">架构分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BANacos"><span class="toc-number">2.2.</span> <span class="toc-text">搭建Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%AD%E5%BF%83"><span class="toc-number">2.2.1.</span> <span class="toc-text">服务发现中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">2.2.2.</span> <span class="toc-text">配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">配置三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEcontent-service"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">配置content-service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEcontent-api"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">配置content-api</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.3.</span> <span class="toc-text">公用配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.4.</span> <span class="toc-text">系统管理配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.2.5.</span> <span class="toc-text">配置优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAGateway"><span class="toc-number">2.3.</span> <span class="toc-text">搭建Gateway</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%AA%92%E8%B5%84%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">搭建媒资工程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">分布式文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.</span> <span class="toc-text">什么是分布式文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MinIO"><span class="toc-number">3.2.</span> <span class="toc-text">MinIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDK"><span class="toc-number">3.2.2.</span> <span class="toc-text">SDK</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">上传文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">删除文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">查询文件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87-1"><span class="toc-number">4.</span> <span class="toc-text">上传图片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">业务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">4.1.2.</span> <span class="toc-text">数据模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">4.2.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.</span> <span class="toc-text">接口定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91"><span class="toc-number">4.4.</span> <span class="toc-text">接口开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DAO%E5%BC%80%E5%8F%91"><span class="toc-number">4.4.1.</span> <span class="toc-text">DAO开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E5%BC%80%E5%8F%91"><span class="toc-number">4.4.2.</span> <span class="toc-text">Service开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%96%84Controller"><span class="toc-number">4.4.3.</span> <span class="toc-text">完善Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.4.</span> <span class="toc-text">Service代码优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E4%BA%8B%E5%8A%A1%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.5.</span> <span class="toc-text">Service事务优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83"><span class="toc-number">4.5.</span> <span class="toc-text">前后端联调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bug%E4%BF%AE%E5%A4%8D"><span class="toc-number">4.6.</span> <span class="toc-text">bug修复</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91-1"><span class="toc-number">5.</span> <span class="toc-text">上传视频</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-1"><span class="toc-number">5.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">5.2.</span> <span class="toc-text">断点续传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">5.2.1.</span> <span class="toc-text">什么是断点续传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E4%B8%8E%E5%90%88%E5%B9%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">分块与合并测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.3.</span> <span class="toc-text">上传视频流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89-1"><span class="toc-number">5.3.</span> <span class="toc-text">接口定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91-1"><span class="toc-number">5.4.</span> <span class="toc-text">接口开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DAO%E5%BC%80%E5%8F%91-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">DAO开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E5%BC%80%E5%8F%91-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">Service开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E5%92%8C%E5%88%86%E5%9D%97"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">检查文件和分块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%88%86%E5%9D%97"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">上传分块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%88%86%E5%9D%97%E6%B5%8B%E8%AF%95"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">上传分块测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%89%8D%E4%B8%8B%E8%BD%BD%E5%88%86%E5%9D%97"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">合并前下载分块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%88%86%E5%9D%97"><span class="toc-number">5.4.2.5.</span> <span class="toc-text">合并分块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%88%86%E5%9D%97%EF%BC%88%E6%96%B0%EF%BC%89"><span class="toc-number">5.4.3.</span> <span class="toc-text">合并分块（新）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-service-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">定义 service 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#service-%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">service 实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.3.2.1.</span> <span class="toc-text">合并最后一个文件操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.3.2.2.</span> <span class="toc-text">合并整个文件操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%96%87%E4%BB%B6"><span class="toc-number">5.4.3.2.3.</span> <span class="toc-text">验证文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">5.4.3.2.4.</span> <span class="toc-text">保存文件信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%88%86%E5%9D%97%E6%96%87%E4%BB%B6"><span class="toc-number">5.4.3.2.5.</span> <span class="toc-text">删除分块文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B1%82%E5%AE%8C%E5%96%84"><span class="toc-number">5.4.4.</span> <span class="toc-text">接口层完善</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95"><span class="toc-number">5.5.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.6.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%A2%84%E8%A7%88"><span class="toc-number">6.</span> <span class="toc-text">文件预览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-2"><span class="toc-number">6.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89-2"><span class="toc-number">6.2.</span> <span class="toc-text">接口定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91-2"><span class="toc-number">6.3.</span> <span class="toc-text">接口开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEURL"><span class="toc-number">6.3.1.</span> <span class="toc-text">设置URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DAO%E5%BC%80%E5%8F%91-2"><span class="toc-number">6.3.2.</span> <span class="toc-text">DAO开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E5%BC%80%E5%8F%91-2"><span class="toc-number">6.3.3.</span> <span class="toc-text">Service开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%96%84Controller-1"><span class="toc-number">6.3.4.</span> <span class="toc-text">完善Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-1"><span class="toc-number">6.3.5.</span> <span class="toc-text">接口测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">视频处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">分布式任务处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">7.1.1.</span> <span class="toc-text">什么是分布式任务调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXL-JOB%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.2.</span> <span class="toc-text">XXL-JOB介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAXXL-JOB"><span class="toc-number">7.1.3.</span> <span class="toc-text">搭建XXL-JOB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">调度中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">执行器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.1.3.3.</span> <span class="toc-text">执行任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E5%B9%BF%E6%92%AD"><span class="toc-number">7.1.4.</span> <span class="toc-text">分片广播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-3"><span class="toc-number">7.2.</span> <span class="toc-text">需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E5%88%86%E7%89%87%E6%96%B9%E6%A1%88"><span class="toc-number">7.2.1.</span> <span class="toc-text">作业分片方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E4%BB%BB%E5%8A%A1%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C"><span class="toc-number">7.2.2.</span> <span class="toc-text">保证任务不重复执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B-2"><span class="toc-number">7.2.3.</span> <span class="toc-text">业务流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%BE%85%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.3.</span> <span class="toc-text">查询待处理任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%BE%85%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.3.1.</span> <span class="toc-text">添加待处理任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%BE%85%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1-1"><span class="toc-number">7.3.2.</span> <span class="toc-text">查询待处理任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">7.4.</span> <span class="toc-text">更新任务状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86-1"><span class="toc-number">7.5.</span> <span class="toc-text">视频处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81"><span class="toc-number">7.5.1.</span> <span class="toc-text">什么是视频编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FFmpeg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">7.5.2.</span> <span class="toc-text">FFmpeg的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">7.5.3.</span> <span class="toc-text">视频处理工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%B1%BB"><span class="toc-number">7.5.4.</span> <span class="toc-text">任务类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E6%B5%8B%E8%AF%95"><span class="toc-number">7.6.</span> <span class="toc-text">视频处理测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">7.7.</span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XXL-JOB%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">7.7.1.</span> <span class="toc-text">XXL-JOB工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%AA%92%E8%B5%84-1"><span class="toc-number">8.</span> <span class="toc-text">绑定媒资</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-4"><span class="toc-number">8.1.</span> <span class="toc-text">需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B-3"><span class="toc-number">8.1.1.</span> <span class="toc-text">业务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-2"><span class="toc-number">8.1.2.</span> <span class="toc-text">数据模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89-3"><span class="toc-number">8.2.</span> <span class="toc-text">接口定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91-3"><span class="toc-number">8.3.</span> <span class="toc-text">接口开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DAO%E5%BC%80%E5%8F%91-3"><span class="toc-number">8.3.1.</span> <span class="toc-text">DAO开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E5%BC%80%E5%8F%91-3"><span class="toc-number">8.3.2.</span> <span class="toc-text">Service开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B1%82%E5%AE%8C%E5%96%84-1"><span class="toc-number">8.3.3.</span> <span class="toc-text">接口层完善</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-2"><span class="toc-number">8.3.4.</span> <span class="toc-text">接口测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">8.4.</span> <span class="toc-text">实战</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/30/spring%E9%9D%A2%E8%AF%95/" title="spring面试"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="spring面试"/></a><div class="content"><a class="title" href="/2023/06/30/spring%E9%9D%A2%E8%AF%95/" title="spring面试">spring面试</a><time datetime="2023-06-30T12:41:44.405Z" title="发表于 2023-06-30 20:41:44">2023-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/29/Reids%E5%AE%9E%E6%88%98/" title="redis实战"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis实战"/></a><div class="content"><a class="title" href="/2023/06/29/Reids%E5%AE%9E%E6%88%98/" title="redis实战">redis实战</a><time datetime="2023-06-29T05:38:51.647Z" title="发表于 2023-06-29 13:38:51">2023-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/28/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97/" title="全文检索模块"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="全文检索模块"/></a><div class="content"><a class="title" href="/2023/06/28/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97/" title="全文检索模块">全文检索模块</a><time datetime="2023-06-27T17:09:00.610Z" title="发表于 2023-06-28 01:09:00">2023-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/28/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/" title="媒资管理模块"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="媒资管理模块"/></a><div class="content"><a class="title" href="/2023/06/28/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/" title="媒资管理模块">媒资管理模块</a><time datetime="2023-06-27T17:09:00.608Z" title="发表于 2023-06-28 01:09:00">2023-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/28/docker%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3/" title="docker操作文档"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker操作文档"/></a><div class="content"><a class="title" href="/2023/06/28/docker%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3/" title="docker操作文档">docker操作文档</a><time datetime="2023-06-27T17:09:00.606Z" title="发表于 2023-06-28 01:09:00">2023-06-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By ADAN</div><div class="footer_custom_text">听天，不会由命</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>