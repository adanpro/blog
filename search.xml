<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring面试</title>
      <link href="/adanpro/adanblog/2023/06/30/spring%E9%9D%A2%E8%AF%95/"/>
      <url>/adanpro/adanblog/2023/06/30/spring%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1、简单介绍Spring"><a href="#1、简单介绍Spring" class="headerlink" title="1、简单介绍Spring"></a>1、简单介绍Spring</h1><p>spring是一个轻量级的、用于简化Java应用程序开发的框架，其<strong>核心功能模块</strong>主要是SpringCore；是spring的核心类库，所有功能都依赖于该类库，提供IOC&#x2F;DI&#x2F;AOP&#x2F;事务功能，开发者只需要关注业务需求，而不需要关心bean的管理。Spring通过IOC和DI有效降低了耦合性，通过aop有效降低了代码的侵入性；事务可定制性高，支持多个隔离级别、传播策略，</p><h1 id="IoC-控制反转"><a href="#IoC-控制反转" class="headerlink" title="IoC 控制反转"></a>IoC 控制反转</h1><p>创建对象的控制权由内部（new实例化）反转到外部（即IOC容器），此思想称为控制反转。使用对象时，由主动new产生对象转换为由外部提供对象。</p><p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。<br><strong>bean基础配置</strong></p><p>在spring配置文件中配置beans下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>id</strong>:  bean的id，使用容器可以通过id值获取对应的bean，在一个容器中id值唯一</p><p><strong>class</strong>: bean的类型，即配置的bean的全路径类名</p><p><strong>name</strong>：定义bean的别名，可定义多个，使用逗号(,)分号(;)空格()分隔</p><p><strong>scope</strong>：为bean设置作用范围，可选值为单例singloton，非单例prototype</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span><br><span class="line">   &lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./spring%E9%9D%A2%E8%AF%95.assets/image-20230630213133379.png" alt="image-20230630213133379"></p><p><strong>步骤1：配置别名</strong></p><p>打开spring的配置文件applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service service4 bookEbi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口</strong></p><p><strong>步骤2:根据名称容器中获取bean对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForName</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;service4&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p><ul><li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p><p><img src="/adanpro/adanblog/./spring%E9%9D%A2%E8%AF%95.assets/image-20230630213531572.png" alt="image-20230630213531572"></p></li><li><p>如果不存在,则会报错找不到bean对象</p></li></ul><p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常&#x3D;&#x3D;NoSuchBeanDefinitionException&#x3D;&#x3D;</p><h1 id="实例化bean的三种方式"><a href="#实例化bean的三种方式" class="headerlink" title="实例化bean的三种方式"></a>实例化bean的三种方式</h1><p>在Spring框架中，实例化Bean的方式有三种常见的方式：</p><ol><li>基于XML配置文件：通过在XML配置文件中定义Bean的配置和属性，Spring容器根据配置文件中的定义实例化Bean。例如，可以使用<code>&lt;bean&gt;</code>标签指定Bean的类名、构造函数参数、属性值等信息。</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Spring底层使用的是类的无参构造方法，</p><ul><li><p>静态工厂实例化：创建静态工厂对象，在xml文件中指定class工厂类全名，通过factory-mehod:具体工厂类中创建对象的方法名，通过ClassPathXmlApplicationContext使用从IOC容器中获取bean的方法。</p></li><li><p>实例工厂实例化：创建实例化工厂对象，调用对象中的方法来创建bean，对应的是第二行配置</p></li></ul><p>​factory-bean:工厂的实例对象</p><p>​factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p><p><img src="/adanpro/adanblog/./spring%E9%9D%A2%E8%AF%95.assets/image-20230630215912634.png" alt="image-20230630215912634"></p><p>​通过ClassPathXmlApplicationContext使用从IOC容器中获取bean的方法。</p><ol start="2"><li>基于注解：使用注解在类上标记Bean，并由Spring容器扫描和实例化。常用的注解包括<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>和<code>@Controller</code>等，它们分别表示普通组件、服务类、数据访问类和控制器类。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>基于Java配置类：使用纯Java代码定义和配置Bean。可以使用<code>@Configuration</code>注解标记一个Java配置类，并使用<code>@Bean</code>注解标记方法，该方法返回所需的Bean实例。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上三种方式中，都需要将配置或类扫描到Spring容器中，以便Spring容器能够实例化并管理这些Bean。Spring框架提供了多种容器实现，如<code>ClassPathXmlApplicationContext</code>、<code>AnnotationConfigApplicationContext</code>和<code>XmlWebApplicationContext</code>等，可以根据不同的使用场景选择适合的容器。</p><h1 id="Bean的作用域-以及默认的作用域"><a href="#Bean的作用域-以及默认的作用域" class="headerlink" title="Bean的作用域,以及默认的作用域"></a>Bean的作用域,以及默认的作用域</h1><p>在默认情况下，Bean在Spring容器中是单例的，但我们可以通过@Scope注解来修改Bean的作用域。这个注解有五个不同的取值，代表了Bean的五种不同类型作用域</p><ul><li>singleton单例（默认） ：在Spring容器中仅存在一个实例，即Bean以单例的形式存在。</li><li>prototype原型：每次从Spring容器中获取Bean时，都会执行new操作，返回一个新的实例。</li><li>request请求：每次HTTP请求都会创建一个新的Bean。</li><li>session ：同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。同一个HTTP Session是指同一个客户端与同一个服务器之间建立的连接，包括同一浏览器重启后依然是同一个客户端。</li><li>globalSession：同一个全局的Session共享一个Bean。全局Session存储与请求无关的全局公共数据，在应用程序重启后失效，可以通过持久化磁盘失效重启后数据恢复。</li></ul><p><strong>自定义作用域：</strong></p><p>使用Spring的注解方式自定义Bean作用域很简单，您可以通过实现org.springframework.beans.factory.config.Scope接口并结合Spring框架中提供的@Scope注解来实现。</p><p>具体步骤如下：</p><p>实现Scope接口，并重写get()和remove()方法。<br>在实现类上添加@Scope注解，并指定其值为自定义Scope的名称。<br>get()方法用于从当前作用域中获取给定名称的对象实例。如果找不到该对象，则应返回null。 remove()方法用于从当前作用域中删除指定名称的对象实例。 如果找不到该对象，则无动作。</p><h1 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h1><ol><li>功能不同：<ul><li>BeanFactory是Spring框架最基本的Bean容器，负责创建、管理和获取Bean实例。它提供了通用的操作方法，如获取Bean、销毁Bean、获取Bean的元数据等。</li><li>FactoryBean是一个特殊的Bean，它实现了FactoryBean接口，并提供了创建其他Bean实例的方法。FactoryBean的主要方法是getObject()，用于返回由FactoryBean创建的Bean实例。</li></ul></li><li>角色不同：<ul><li>BeanFactory是Spring容器的核心接口，负责整个Spring的Bean管理生命周期、依赖关系和作用域，并提供了对Bean的注册和获取等功能。</li><li>FactoryBean是一种Bean，它被Spring容器注册和管理，并在需要时通过其getObject()方法创建其他的Bean实例。FactoryBean本身并不是一个真正的Bean实例，它是用于生产其他Bean的工厂。</li></ul></li><li>使用方式不同：<ul><li>使用BeanFactory时，我们可以直接通过BeanFactory调用getBean()方法来获取Bean实例。</li><li>使用FactoryBean时，我们需要通过BeanFactory调用getBean()方法来获取FactoryBean的实例，然后再通过该实例的getObject()方法来获取由FactoryBean创建的Bean实例。</li></ul></li></ol><p>总结： <strong>BeanFactory</strong>是Spring框架的基础接口，负责创建和管理Bean实例，也就是IOC容器，它有一些方法可以判断容器里Bean是否存在、是否单例等。而FactoryBean是一种特殊的Bean，它实现了FactoryBean接口，并提供了创建其他Bean实例的方法。BeanFactory是Spring容器的核心，而FactoryBean是一种扩展机制，用于自定义Bean的创建逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis实战</title>
      <link href="/adanpro/adanblog/2023/06/29/Reids%E5%AE%9E%E6%88%98/"/>
      <url>/adanpro/adanblog/2023/06/29/Reids%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<ul><li>短信登录</li></ul><p>这一块我们会使用redis共享session来实现</p><ul><li>商户查询缓存</li></ul><p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p><ul><li>优惠卷秒杀</li></ul><p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p><ul><li>附近的商户</li></ul><p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p><ul><li>UV统计</li></ul><p>主要是使用Redis来完成统计功能</p><ul><li>用户签到</li></ul><p>使用Redis的BitMap数据统计功能</p><ul><li>好友关注</li></ul><p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p><ul><li>打人探店</li></ul><p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p><p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p><p><img src="/adanpro/adanblog/../pic/1653056228879.png" alt="1653056228879"></p><h2 id="1、短信登录"><a href="#1、短信登录" class="headerlink" title="1、短信登录"></a>1、短信登录</h2><h3 id="1-1、导入黑马点评项目"><a href="#1-1、导入黑马点评项目" class="headerlink" title="1.1、导入黑马点评项目"></a>1.1、导入黑马点评项目</h3><h4 id="1-1-1-、导入SQL"><a href="#1-1-1-、导入SQL" class="headerlink" title="1.1.1 、导入SQL"></a>1.1.1 、导入SQL</h4><p><img src="/adanpro/adanblog/../pic/1653057872536.png" alt="1653057872536"></p><h4 id="1-1-2、有关当前模型"><a href="#1-1-2、有关当前模型" class="headerlink" title="1.1.2、有关当前模型"></a>1.1.2、有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p><p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p><p><img src="/adanpro/adanblog/../pic/1653059409865.png" alt="1653059409865"></p><h4 id="1-1-3、导入后端项目"><a href="#1-1-3、导入后端项目" class="headerlink" title="1.1.3、导入后端项目"></a>1.1.3、导入后端项目</h4><p>在资料中提供了一个项目源码：</p><p><img src="/adanpro/adanblog/../pic/1653060237073.png" alt="1653060237073"></p><h4 id="1-1-4、导入前端工程"><a href="#1-1-4、导入前端工程" class="headerlink" title="1.1.4、导入前端工程"></a>1.1.4、导入前端工程</h4><p><img src="/adanpro/adanblog/../pic/1653060337562.png" alt="1653060337562"></p><h4 id="1-1-5-运行前端项目"><a href="#1-1-5-运行前端项目" class="headerlink" title="1.1.5 运行前端项目"></a>1.1.5 运行前端项目</h4><p><img src="/adanpro/adanblog/../pic/1653060588190.png" alt="1653060588190"></p><h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><p><img src="/adanpro/adanblog/../pic/1653066208144.png" alt="1653066208144"></p><h3 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h3><p><strong>页面流程</strong></p><p><img src="/adanpro/adanblog/../pic/1653067054461.png" alt="1653067054461"></p><p><strong>具体代码如下</strong></p><p><strong>贴心小提示：</strong></p><p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p><ul><li>发送验证码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>登录</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p><p><img src="/adanpro/adanblog/../pic/1653068196656.png" alt="1653068196656"></p><p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p><p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><p><strong>温馨小贴士：关于threadlocal</strong></p><p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p><p><img src="/adanpro/adanblog/../pic/1653068874258.png" alt="1653068874258"></p><p>拦截器代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">              response.setStatus(<span class="number">401</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让拦截器生效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p><strong>在登录方法处修改</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure><p><strong>在拦截器处：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure><p><strong>在UserHolder处：将user对象换成UserDTO</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p><p><img src="/adanpro/adanblog/../pic/1653069893050.png" alt="1653069893050"></p><h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><h4 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p><p><img src="/adanpro/adanblog/../pic/1653319261433.png" alt="1653319261433"></p><h4 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p><p>在设计这个key的时候，我们之前讲过需要满足两点</p><p>1、key要具有唯一性</p><p>2、key要方便携带</p><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p><h4 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p><p><img src="/adanpro/adanblog/../pic/1653319474181.png" alt="1653319474181"></p><h3 id="1-8-基于Redis实现短信登录"><a href="#1-8-基于Redis实现短信登录" class="headerlink" title="1.8 基于Redis实现短信登录"></a>1.8 基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p><p><strong>UserServiceImpl代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.从redis获取验证码并校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;</span><br><span class="line">        <span class="comment">// 不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">    <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3.存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-解决状态登录刷新问题"><a href="#1-9-解决状态登录刷新问题" class="headerlink" title="1.9 解决状态登录刷新问题"></a>1.9 解决状态登录刷新问题</h3><h4 id="1-9-1-初始方案思路总结："><a href="#1-9-1-初始方案思路总结：" class="headerlink" title="1.9.1 初始方案思路总结："></a>1.9.1 初始方案思路总结：</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</p><p><img src="/adanpro/adanblog/../pic/1653320822964.png" alt="1653320822964"></p><h4 id="1-9-2-优化方案"><a href="#1-9-2-优化方案" class="headerlink" title="1.9.2 优化方案"></a>1.9.2 优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p><p><img src="/adanpro/adanblog/../pic/1653320764547.png" alt="1653320764547"></p><h4 id="1-9-3-代码"><a href="#1-9-3-代码" class="headerlink" title="1.9.3 代码"></a>1.9.3 代码</h4><p><strong>RefreshTokenInterceptor</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>LoginInterceptor</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、商户查询缓存"><a href="#2、商户查询缓存" class="headerlink" title="2、商户查询缓存"></a>2、商户查询缓存</h2><h3 id="2-1-什么是缓存"><a href="#2-1-什么是缓存" class="headerlink" title="2.1 什么是缓存?"></a>2.1 什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p><p>就像自行车,越野车的避震器<img src="/adanpro/adanblog/../pic/%E9%81%BF%E9%9C%87%E5%99%A8.gif"></p><p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p><p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p><p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效;</p><h4 id="2-1-1-为什么要使用缓存"><a href="#2-1-1-为什么要使用缓存" class="headerlink" title="2.1.1 为什么要使用缓存"></a>2.1.1 为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p><img src="/adanpro/adanblog/../pic/image-20220523214414123.png"></p><h4 id="2-1-2-如何使用缓存"><a href="#2-1-2-如何使用缓存" class="headerlink" title="2.1.2 如何使用缓存"></a>2.1.2 如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><img src="/adanpro/adanblog/../pic/image-20220523212915666.png"></p><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    //这里是直接查询数据库</span><br><span class="line">    return shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-、缓存模型和思路"><a href="#2-2-1-、缓存模型和思路" class="headerlink" title="2.2.1 、缓存模型和思路"></a>2.2.1 、缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="/adanpro/adanblog/../pic/1653322097736.png" alt="1653322097736"></p><h4 id="2-1-2、代码如下"><a href="#2-1-2、代码如下" class="headerlink" title="2.1.2、代码如下"></a>2.1.2、代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p><p><img src="/adanpro/adanblog/../pic/1653322190155.png" alt="1653322190155"></p><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="/adanpro/adanblog/../pic/1653322506393.png" alt="1653322506393"></p><h4 id="2-3-1-、数据库缓存不一致解决方案："><a href="#2-3-1-、数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="/adanpro/adanblog/../pic/1653322857620.png" alt="1653322857620"></p><h4 id="2-3-2-、数据库和缓存不一致采用什么方案"><a href="#2-3-2-、数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p><img src="/adanpro/adanblog/../pic/1653323595206.png" alt="1653323595206"></p><h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><p><img src="/adanpro/adanblog/../pic/1653325871232.png" alt="1653325871232"></p><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p><p><img src="/adanpro/adanblog/../pic/1653325929549.png" alt="1653325929549"></p><h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="/adanpro/adanblog/../pic/1653326156516.png" alt="1653326156516"></p><h3 id="2-6-编码解决商品查询的缓存穿透问题："><a href="#2-6-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.6 编码解决商品查询的缓存穿透问题："></a>2.6 编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><p><img src="/adanpro/adanblog/../pic/1653327124561.png" alt="1653327124561"></p><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="2-7-缓存雪崩问题及解决思路"><a href="#2-7-缓存雪崩问题及解决思路" class="headerlink" title="2.7 缓存雪崩问题及解决思路"></a>2.7 缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="/adanpro/adanblog/../pic/1653327884526.png" alt="1653327884526"></p><h3 id="2-8-缓存击穿问题及解决思路"><a href="#2-8-缓存击穿问题及解决思路" class="headerlink" title="2.8 缓存击穿问题及解决思路"></a>2.8 缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="/adanpro/adanblog/../pic/1653328022622.png" alt="1653328022622"></p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="/adanpro/adanblog/../pic/1653328288627.png" alt="1653328288627"></p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="/adanpro/adanblog/../pic/1653328663897.png" alt="1653328663897"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="/adanpro/adanblog/../pic/1653357522914.png" alt="1653357522914"></p><h3 id="2-9-利用互斥锁解决缓存击穿问题"><a href="#2-9-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.9 利用互斥锁解决缓存击穿问题"></a>2.9 利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="/adanpro/adanblog/../pic/1653357860001.png" alt="1653357860001"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//4.1 获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 4.2 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//4.3 失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4.4 成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁</span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-0-、利用逻辑过期解决缓存击穿问题"><a href="#3-0-、利用逻辑过期解决缓存击穿问题" class="headerlink" title="3.0 、利用逻辑过期解决缓存击穿问题"></a>3.0 、利用逻辑过期解决缓存击穿问题</h3><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="/adanpro/adanblog/../pic/1653360308731.png" alt="1653360308731"></p><p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p><p><strong>步骤一、</strong></p><p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RedisData &#123;</span><br><span class="line">    private LocalDateTime expireTime;</span><br><span class="line">    private Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤二、</strong></p><p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p><p><img src="/adanpro/adanblog/../pic/1653360807133.png" alt="1653360807133"></p><p><strong>在测试类中</strong></p><p><img src="/adanpro/adanblog/../pic/1653360864839.png" alt="1653360864839"></p><p>步骤三：正式代码</p><p><strong>ShopServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1、封装Redis工具类"><a href="#3-1、封装Redis工具类" class="headerlink" title="3.1、封装Redis工具类"></a>3.1、封装Redis工具类</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li></ul><p>存击穿问题</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>将逻辑进行封装</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl 中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3、优惠卷秒杀"><a href="#3、优惠卷秒杀" class="headerlink" title="3、优惠卷秒杀"></a>3、优惠卷秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 -全局唯一ID"></a>3.1 -全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p><p><img src="/adanpro/adanblog/../pic/1653362612286.png" alt="1653362612286"></p><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><p><img src="/adanpro/adanblog/../pic/1653363100502.png" alt="1653363100502"></p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p><img src="/adanpro/adanblog/../pic/1653363172079.png" alt="1653363172079">ID的组成部分：符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><h3 id="3-2-Redis实现全局唯一Id"><a href="#3-2-Redis实现全局唯一Id" class="headerlink" title="3.2 -Redis实现全局唯一Id"></a>3.2 -Redis实现全局唯一Id</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><p>知识小贴士：关于countdownlatch</p><p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p><p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p><p>CountDownLatch 中有两个最重要的方法</p><p>1、countDown</p><p>2、await</p><p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p><p><img src="/adanpro/adanblog/../pic/1653365145124.png" alt="1653365145124"></p><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p><p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p><p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>**新增普通卷代码：  **VoucherController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>VoucherServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p><p><img src="/adanpro/adanblog/../pic/1653365839526.png" alt="1653365839526"></p><p>秒杀下单应该思考的内容：</p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="/adanpro/adanblog/../pic/1653366238564.png" alt="1653366238564"></p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 库存不足</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5，扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="/adanpro/adanblog/../pic/1653368335155.png" alt="1653368335155"></p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p><p><img src="/adanpro/adanblog/../pic/1653368562591.png" alt="1653368562591"></p><p><strong>悲观锁：</strong></p><p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p><strong>乐观锁：</strong></p><p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure><p><strong>课程中的使用方式：</strong></p><p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功</p><p><img src="/adanpro/adanblog/../pic/1653369268550.png" alt="1653369268550"></p><h3 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p><p>VoucherOrderServiceImpl 在扣减库存时，改为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure><p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p><p><strong>修改代码方案二、</strong></p><p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure><p><strong>知识小扩展：</strong></p><p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p><p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p><p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p><p>所以利用这么一个类，LongAdder来进行优化</p><p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p><p><img src="/adanpro/adanblog/../pic/1653370271627.png" alt="1653370271627"></p><h3 id="3-6-优惠券秒杀-一人一单"><a href="#3-6-优惠券秒杀-一人一单" class="headerlink" title="3.6 优惠券秒杀-一人一单"></a>3.6 优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p><strong>现在的问题在于：</strong></p><p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p><p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p><p><img src="/adanpro/adanblog/../pic/1653371854389.png" alt="1653371854389"></p><p>VoucherOrderServiceImpl  </p><p><strong>初步代码：增加一人一单逻辑</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">    <span class="comment">// 5.1.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 7.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 7.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p><p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：<br>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p><p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p><p><img src="/adanpro/adanblog/../pic/1653373434815.png" alt="1653373434815"></p><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</p><p><img src="/adanpro/adanblog/../pic/1653383810643.png" alt="1653383810643"></p><h3 id="3-7-集群环境下的并发问题"><a href="#3-7-集群环境下的并发问题" class="headerlink" title="3.7 集群环境下的并发问题"></a>3.7 集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>1、我们将服务启动两份，端口分别为8081和8082：</p><p><img src="/adanpro/adanblog/../pic/1653373887844.png" alt="1653373887844"></p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p><p><img src="/adanpro/adanblog/../pic/1653373908620.png" alt="1653373908620"></p><p><strong>具体操作(略)</strong></p><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="/adanpro/adanblog/../pic/1653374044740.png" alt="1653374044740"></p><h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="/adanpro/adanblog/../pic/1653374296906.png" alt="1653374296906"></p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p><img src="/adanpro/adanblog/../pic/1653381992018.png" alt="1653381992018"></p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><p><img src="/adanpro/adanblog/../pic/1653382219377.png" alt="1653382219377"></p><h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul><p><img src="/adanpro/adanblog/../pic/1653382669900.png" alt="1653382669900"></p></li></ul><p>核心思路：</p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><p> <img src="/adanpro/adanblog/../pic/1653382830810.png" alt="1653382830810"></p><h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><ul><li>加锁逻辑</li></ul><p><strong>锁的基本接口</strong></p><p><img src="/adanpro/adanblog/../pic/1656079017728.png" alt="1656079017728"></p><p><strong>SimpleRedisLock</strong></p><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>释放锁逻辑</li></ul><p>SimpleRedisLock</p><p>释放锁，防止删除别人的锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改业务代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.查询优惠券</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">//创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">//获取锁对象</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-Redis分布式锁误删情况说明"><a href="#4-4-Redis分布式锁误删情况说明" class="headerlink" title="4.4 Redis分布式锁误删情况说明"></a>4.4 Redis分布式锁误删情况说明</h3><p>逻辑说明：</p><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="/adanpro/adanblog/../pic/1653385920025.png" alt="1653385920025"></p><h3 id="4-5-解决Redis分布式锁误删问题"><a href="#4-5-解决Redis分布式锁误删问题" class="headerlink" title="4.5 解决Redis分布式锁误删问题"></a>4.5 解决Redis分布式锁误删问题</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><p><img src="/adanpro/adanblog/../pic/1653387398820.png" alt="1653387398820"></p><p>具体代码如下：加锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有关代码实操说明：</strong></p><p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p><h3 id="4-6-分布式锁的原子性问题"><a href="#4-6-分布式锁的原子性问题" class="headerlink" title="4.6 分布式锁的原子性问题"></a>4.6 分布式锁的原子性问题</h3><p>更为极端的误删逻辑说明：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p><p><img src="/adanpro/adanblog/../pic/1653387764938.png" alt="1653387764938"></p><h3 id="4-7-Lua脚本解决多条命令原子性问题"><a href="#4-7-Lua脚本解决多条命令原子性问题" class="headerlink" title="4.7 Lua脚本解决多条命令原子性问题"></a>4.7 Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><p>例如，我们要执行set name jack，则脚本是这样：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p><p><img src="/adanpro/adanblog/../pic/1653392181413.png" alt="1653392181413"></p><p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p><p><img src="/adanpro/adanblog/../pic/1653392218531.png" alt="1653392218531"></p><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p><p><img src="/adanpro/adanblog/../pic/1653392438917.png" alt="1653392438917"></p><p>接下来我们来回一下我们释放锁的逻辑：</p><p>释放锁的业务流程是这样的</p><p>​1、获取锁中的线程标示</p><p>​2、判断是否与指定的标示（当前线程标示）一致</p><p>​3、如果一致则释放锁（删除）</p><p>​4、如果不一致则什么都不做</p><p>如果用Lua脚本来表示则是这样的：</p><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="4-8-利用Java代码调用Lua脚本改造分布式锁"><a href="#4-8-利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="4.8 利用Java代码调用Lua脚本改造分布式锁"></a>4.8 利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p><p><img src="/adanpro/adanblog/../pic/1653393304844.png" alt="1653393304844"></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></pre></td></tr></table></figure><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><h2 id="5、分布式锁-redission"><a href="#5、分布式锁-redission" class="headerlink" title="5、分布式锁-redission"></a>5、分布式锁-redission</h2><h3 id="5-1-分布式锁-redission功能介绍"><a href="#5-1-分布式锁-redission功能介绍" class="headerlink" title="5.1 分布式锁-redission功能介绍"></a>5.1 分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="/adanpro/adanblog/../pic/1653546070602.png" alt="1653546070602"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="/adanpro/adanblog/../pic/1653546736063.png" alt="1653546736063"></p><h3 id="5-2-分布式锁-Redission快速入门"><a href="#5-2-分布式锁-Redission快速入门" class="headerlink" title="5.2 分布式锁-Redission快速入门"></a>5.2 分布式锁-Redission快速入门</h3><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-分布式锁-redission可重入锁原理"><a href="#5-3-分布式锁-redission可重入锁原理" class="headerlink" title="5.3 分布式锁-redission可重入锁原理"></a>5.3 分布式锁-redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p><p>在redission中，我们的也支持支持可重入锁</p><p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p><p>这个地方一共有3个参数</p><p><strong>KEYS[1] ： 锁名称</strong></p><p><strong>ARGV[1]：  锁失效时间</strong></p><p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p><p>exists: 判断数据是否存在  name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在</p><p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p><p>Lock{</p><p>​    id + <strong>“:”</strong> + threadId :  1</p><p>}</p><p>如果当前这把锁存在，则第一个条件不满足，再判断</p><p>redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1</p><p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p><p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p><p>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p><p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/../pic/1653548087334.png" alt="1653548087334"></p><h3 id="5-4-分布式锁-redission锁重试和WatchDog机制"><a href="#5-4-分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="5.4 分布式锁-redission锁重试和WatchDog机制"></a>5.4 分布式锁-redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p><p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p><p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p><img src="/adanpro/adanblog/../pic/1653553998403.png" alt="1653553998403"></p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="/adanpro/adanblog/../pic/1653554055048.png" alt="1653554055048"></p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><p><img src="/adanpro/adanblog/../pic/1653553093967.png" alt="1653553093967"></p><h2 id="6、秒杀优化"><a href="#6、秒杀优化" class="headerlink" title="6、秒杀优化"></a>6、秒杀优化</h2><h3 id="6-1-秒杀优化-异步秒杀思路"><a href="#6-1-秒杀优化-异步秒杀思路" class="headerlink" title="6.1 秒杀优化-异步秒杀思路"></a>6.1 秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、查询订单</p><p>4、校验是否是一人一单</p><p>5、扣减库存</p><p>6、创建订单</p><p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p><p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求</p><p><img src="/adanpro/adanblog/../pic/1653560986599.png" alt="1653560986599"></p><p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p><p><img src="/adanpro/adanblog/../pic/1653561657295.png" alt="1653561657295"></p><p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><img src="/adanpro/adanblog/../pic/1653562234886.png" alt="1653562234886"></p><h3 id="6-2-秒杀优化-Redis完成秒杀资格判断"><a href="#6-2-秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="6.2 秒杀优化-Redis完成秒杀资格判断"></a>6.2 秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p><ul><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p></li><li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p><p><img src="/adanpro/adanblog/../pic/1656080546603.png" alt="1656080546603"></p></li></ul><p>VoucherServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整lua表达式</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-秒杀优化-基于阻塞队列实现秒杀优化"><a href="#6-3-秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="6.3 秒杀优化-基于阻塞队列实现秒杀优化"></a>6.3 秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p><p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">            <span class="comment">// 2.创建锁对象</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">            <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.lock();</span><br><span class="line">            <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">                log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">                proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                redisLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//a</span></span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">         proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">           log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>小总结：</strong></p><p>秒杀业务的优化思路是什么？</p><ul><li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li><li>基于阻塞队列的异步秒杀存在哪些问题？<ul><li>内存限制问题</li><li>数据安全问题</li></ul></li></ul><h2 id="7、Redis消息队列"><a href="#7、Redis消息队列" class="headerlink" title="7、Redis消息队列"></a>7、Redis消息队列</h2><h3 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="/adanpro/adanblog/../pic/1653574849336.png" alt="1653574849336"></p><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="/adanpro/adanblog/../pic/1653575176451.png" alt="1653575176451"></p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="7-3-Redis消息队列-基于PubSub的消息队列"><a href="#7-3-Redis消息队列-基于PubSub的消息队列" class="headerlink" title="7.3 Redis消息队列-基于PubSub的消息队列"></a>7.3 Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="/adanpro/adanblog/../pic/1653575506373.png" alt="1653575506373"></p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="/adanpro/adanblog/../pic/1653577301737.png" alt="1653577301737"></p><p>例如：</p><p><img src="/adanpro/adanblog/../pic/1653577349691.png" alt="1653577349691"></p><p>读取消息的方式之一：XREAD</p><p><img src="/adanpro/adanblog/../pic/1653577445413.png" alt="1653577445413"></p><p>例如，使用XREAD读取第一个消息：</p><p><img src="/adanpro/adanblog/../pic/1653577643629.png" alt="1653577643629"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="/adanpro/adanblog/../pic/1653577659166.png" alt="1653577659166"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p><p><img src="/adanpro/adanblog/../pic/1653577689129.png" alt="1653577689129"></p><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="/adanpro/adanblog/../pic/1653577801668.png" alt="1653577801668"></p><p>创建消费者组：<br><img src="/adanpro/adanblog/../pic/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p><p>消费者监听消息的基本思路：</p><p><img src="/adanpro/adanblog/../pic/1653578211854.png" alt="1653578211854">STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><p>最后我们来个小对比</p><p><img src="/adanpro/adanblog/../pic/1653578560691.png" alt="1653578560691"></p><h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li></ul><p>修改lua表达式,新增3.6 </p><p><img src="/adanpro/adanblog/../pic/1656082824939.png" alt="1656082824939"></p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8、达人探店"><a href="#8、达人探店" class="headerlink" title="8、达人探店"></a>8、达人探店</h2><h3 id="8-1、达人探店-发布探店笔记"><a href="#8-1、达人探店-发布探店笔记" class="headerlink" title="8.1、达人探店-发布探店笔记"></a>8.1、达人探店-发布探店笔记</h3><p>发布探店笔记</p><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p><p><strong>具体发布流程</strong></p><p><img src="/adanpro/adanblog/../pic/1653578992639.png" alt="1653578992639"></p><p>上传接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p><p>BlogController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-达人探店-查看探店笔记"><a href="#8-2-达人探店-查看探店笔记" class="headerlink" title="8.2 达人探店-查看探店笔记"></a>8.2 达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p><p><img src="/adanpro/adanblog/../pic/1653579931626.png" alt="1653579931626"></p><p>实现代码：</p><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-达人探店-点赞功能"><a href="#8-3-达人探店-点赞功能" class="headerlink" title="8.3 达人探店-点赞功能"></a>8.3 达人探店-点赞功能</h3><p>初始代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//修改点赞数量</span></span><br><span class="line">    blogService.update().setSql(<span class="string">&quot;liked = liked +1 &quot;</span>).eq(<span class="string">&quot;id&quot;</span>,id).update();</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p><p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p><p><img src="/adanpro/adanblog/../pic/1653581590453.png" alt="1653581590453"></p><p>完善点赞功能</p><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>为什么采用set集合：</p><p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p><p>具体步骤：</p><p>1、在Blog 添加一个字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure><p>2、修改代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">       <span class="keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">           <span class="comment">//3.1 数据库点赞数+1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//3.2 保存用户到Redis的set集合</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">           <span class="comment">//4.1 数据库点赞数-1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//4.2 把用户从Redis的set集合移除</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-达人探店-点赞排行榜"><a href="#8-4-达人探店-点赞排行榜" class="headerlink" title="8.4 达人探店-点赞排行榜"></a>8.4 达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p><p><img src="/adanpro/adanblog/../pic/1653805077118.png" alt="1653805077118"></p><p>我们接下来来对比一下这些集合的区别是什么</p><p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p><p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p><p><img src="/adanpro/adanblog/../pic/1653805203758.png" alt="1653805203758"></p><p>修改代码</p><p>BlogServiceImpl</p><p>点赞逻辑代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">         <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">         <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Result.ok();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">     <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 用户未登录，无需查询是否点赞</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span> + blog.getId();</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>点赞列表查询列表</p><p>BlogController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogLikes(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、好友关注"><a href="#9、好友关注" class="headerlink" title="9、好友关注"></a>9、好友关注</h2><h3 id="9-1-好友关注-关注和取消关注"><a href="#9-1-好友关注-关注和取消关注" class="headerlink" title="9.1 好友关注-关注和取消关注"></a>9.1 好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p><img src="/adanpro/adanblog/../pic/1653806140822.png" alt="1653806140822"></p><p>实现思路：</p><p>需求：基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p><p><img src="/adanpro/adanblog/../pic/1653806253817.png" alt="1653806253817"></p><p>注意: 这里需要把主键修改为自增长，简化开发。</p><p>FollowController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FollowService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">取消关注service</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="comment">// 3.判断</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 关注service</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">            <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">            remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                    .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-好友关注-共同关注"><a href="#9-2-好友关注-共同关注" class="headerlink" title="9.2 好友关注-共同关注"></a>9.2 好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><p>1、去查询用户的详情</p><p>2、去查询用户的笔记</p><p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p><p><img src="/adanpro/adanblog/../pic/1653806706296.png" alt="1653806706296"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserController 根据id查询用户</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line"><span class="comment">// 查询详情</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlogController  根据id查询博主的探店笔记</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"><span class="comment">// 根据用户查询</span></span><br><span class="line">Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">.eq(<span class="string">&quot;user_id&quot;</span>, id).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line"><span class="comment">// 获取当前页数据</span></span><br><span class="line">List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line"><span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看看共同关注如何实现：</p><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p><p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p><p><img src="/adanpro/adanblog/../pic/1653806973212.png" alt="1653806973212"></p><p>我们先来改造当前的关注列表</p><p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p><p>FollowServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">        <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id从Redis集合中移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的关注代码：</strong></p><p>FollowServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-好友关注-Feed流实现方案"><a href="#9-3-好友关注-Feed流实现方案" class="headerlink" title="9.3 好友关注-Feed流实现方案"></a>9.3 好友关注-Feed流实现方案</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p><img src="/adanpro/adanblog/../pic/1653808641260.png" alt="1653808641260"></p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p><img src="/adanpro/adanblog/../pic/1653808993693.png" alt="1653808993693"></p><p>Feed流的实现有两种模式：</p><p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li></ul><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p><p>，因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><img src="/adanpro/adanblog/../pic/1653809450816.png" alt="1653809450816"></p><p><strong>推模式</strong>：也叫做写扩散。</p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="/adanpro/adanblog/../pic/1653809875208.png" alt="1653809875208"></p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><p><img src="/adanpro/adanblog/../pic/1653812346852.png" alt="1653812346852"></p><h3 id="9-4-好友关注-推送到粉丝收件箱"><a href="#9-4-好友关注-推送到粉丝收件箱" class="headerlink" title="9.4 好友关注-推送到粉丝收件箱"></a>9.4 好友关注-推送到粉丝收件箱</h3><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="/adanpro/adanblog/../pic/1653813047671.png" alt="1653813047671"></p><p>Feed流的滚动分页</p><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><p><img src="/adanpro/adanblog/../pic/1653813462834.png" alt="1653813462834"></p><p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5好友关注-实现分页查询收邮箱"><a href="#9-5好友关注-实现分页查询收邮箱" class="headerlink" title="9.5好友关注-实现分页查询收邮箱"></a>9.5好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><p>具体操作如下：</p><p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p><p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><p><img src="/adanpro/adanblog/../pic/1653819821591.png" alt="1653819821591"></p><p>一、定义出来具体的返回值实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogController</p><p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、附近商户"><a href="#10、附近商户" class="headerlink" title="10、附近商户"></a>10、附近商户</h2><h3 id="10-1、附近商户-GEO数据结构的基本用法"><a href="#10-1、附近商户-GEO数据结构的基本用法" class="headerlink" title="10.1、附近商户-GEO数据结构的基本用法"></a>10.1、附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><h3 id="10-2、-附近商户-导入店铺数据到GEO"><a href="#10-2、-附近商户-导入店铺数据到GEO" class="headerlink" title="10.2、 附近商户-导入店铺数据到GEO"></a>10.2、 附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p><p><img src="/adanpro/adanblog/../pic/1653822036941.png" alt="1653822036941"></p><p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p><p><img src="/adanpro/adanblog/../pic/1653822021827.png" alt="1653822021827"></p><p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p><p>代码</p><p>HmDianPingApplicationTests</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-附近商户-实现附近商户功能"><a href="#10-3-附近商户-实现附近商户功能" class="headerlink" title="10.3 附近商户-实现附近商户功能"></a>10.3 附近商户-实现附近商户功能</h3><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p><p>第一步：导入pom</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">6.1</span><span class="number">.6</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第二步：</p><p>ShopController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShopServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key,</span><br><span class="line">                        GeoReference.fromCoordinate(x, y),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="11、用户签到"><a href="#11、用户签到" class="headerlink" title="11、用户签到"></a>11、用户签到</h2><h4 id="11-1、用户签到-BitMap功能演示"><a href="#11-1、用户签到-BitMap功能演示" class="headerlink" title="11.1、用户签到-BitMap功能演示"></a>11.1、用户签到-BitMap功能演示</h4><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><p><img src="/adanpro/adanblog/../pic/1653823145495.png" alt="1653823145495"></p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="/adanpro/adanblog/../pic/1653824498278.png" alt="1653824498278"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h4 id="11-2-、用户签到-实现签到功能"><a href="#11-2-、用户签到-实现签到功能" class="headerlink" title="11.2 、用户签到-实现签到功能"></a>11.2 、用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><img src="/adanpro/adanblog/../pic/1653833970361.png" alt="1653833970361"></p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-用户签到-签到统计"><a href="#11-3-用户签到-签到统计" class="headerlink" title="11.3 用户签到-签到统计"></a>11.3 用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p><img src="/adanpro/adanblog/../pic/1653834455899.png" alt="1653834455899"></p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><p><img src="/adanpro/adanblog/../pic/1653835784444.png" alt="1653835784444"></p><p>代码</p><p><strong>UserController</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p><p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p><p>解决方案：</p><ul><li><p>判断id&lt;0</p></li><li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p></li></ul><p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p><p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p><p>所以我们如何解决呢？</p><p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p><p><img src="/adanpro/adanblog/../pic/1653836416586.png" alt="1653836416586"></p><p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p><p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p><p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p><p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p><p>id % bitmap.size  &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p><p><img src="/adanpro/adanblog/../pic/1653836578970.png" alt="1653836578970"></p><h2 id="12、UV统计"><a href="#12、UV统计" class="headerlink" title="12、UV统计"></a>12、UV统计</h2><h3 id="12-1-、UV统计-HyperLogLog"><a href="#12-1-、UV统计-HyperLogLog" class="headerlink" title="12.1 、UV统计-HyperLogLog"></a>12.1 、UV统计-HyperLogLog</h3><p>首先我们搞懂两个概念：</p><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><p><img src="/adanpro/adanblog/../pic/1653837988985.png" alt="1653837988985"></p><h3 id="12-2-UV统计-测试百万数据的统计"><a href="#12-2-UV统计-测试百万数据的统计" class="headerlink" title="12.2 UV统计-测试百万数据的统计"></a>12.2 UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><p><img src="/adanpro/adanblog/../pic/1653838053608.png" alt="1653838053608"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全文检索模块</title>
      <link href="/adanpro/adanblog/2023/06/28/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97/"/>
      <url>/adanpro/adanblog/2023/06/28/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-【检索模块】-需求分析"><a href="#1-【检索模块】-需求分析" class="headerlink" title="1 【检索模块】****需求分析"></a><strong>1 【检索模块】****需求分析</strong></h1><p><strong>课程搜索、课程发布时同步索引库。</strong></p><h2 id="1-1-全文检索介绍"><a href="#1-1-全文检索介绍" class="headerlink" title="1.1 全文检索介绍"></a><strong>1.1 全文检索介绍</strong></h2><p>课程搜索是课程展示的渠道，用户通过课程搜索找到课程信息，进一步去查看课程的详细信息，进行选课、支付、学习。</p><p>本项目的课程搜索支持全文检索技术。</p><p><strong>什么是全文检索？</strong></p><p><a href="https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/8028630?fromModule=lemma_inlink">全文检索</a>是指计算机索引程序通过扫描文章中的每一个词，<strong>对每一个词建立一个索引</strong>，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就<strong>根据事先建立的索引进行查找</strong>，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p><p>全文检索可以简单理解为<strong>通过索引搜索文章</strong>。</p><p><img src="/adanpro/adanblog/./../pic/64d5056677154d33bdf8a7ca7baac22b.png" alt="img"></p><p>全文检索的速度非常快，早期应用在搜索引擎技术中，比如：百度、google等，现在通常一些大型网站的搜索功能都是采用全文检索技术。</p><p><img src="/adanpro/adanblog/./../pic/e41c2a758bda4586adcdc4041d2da2ca.png" alt="img"></p><p>课程搜索也要将课程信息建立索引，在课程发布时建立课程索引，索引建立好用户可通过搜索网页去查询课程信息。</p><p><img src="/adanpro/adanblog/./../pic/efcc03fb1dbf47898bda1dcb9059dbf5.png" alt="img"></p><p>所以，课程搜索模块包括两部分：<strong>课程索引、课程搜索</strong>。</p><p>课程索引是将课程信息建立索引。</p><p>课程搜索是通过前端网页，通过关键字等条件去搜索课程。</p><h2 id="1-2-业务流程"><a href="#1-2-业务流程" class="headerlink" title="1.2 业务流程"></a><strong>1.2</strong> <strong>业务流程</strong></h2><p>根据模块介绍的内容，课程搜索模块包括<strong>课程索引、课程搜索</strong>两部分。</p><h3 id="1-2-1、课程发布时索引库里新增一条记录"><a href="#1-2-1、课程发布时索引库里新增一条记录" class="headerlink" title="1.2.1、课程发布时索引库里新增一条记录"></a><strong>1.2.1、课程发布时索引库里新增一条记录</strong></h3><p>首先要建好ES索引库，然后在<strong>课程发布操作执行后</strong>通过消息处理方式索引库里新增一条记录，如下图：</p><p><img src="/adanpro/adanblog/./../pic/dbf03f7a712642b0a433b54f74cb6d8d.png" alt="img"></p><blockquote><p><strong>课程发布业务流程：</strong></p><p>1、向内容管理数据库的课程发布表存储课程发布信息，更新课程基本信息表中发布状态为已发布。</p><p>2、向Redis存储课程缓存信息。</p><p><strong>3、向Elasticsearch存储课程索引信息。</strong></p><p>4、静态化课程预览页面并存储到文件系统minIO，实现快速浏览课程详情页面。</p></blockquote><p>本项目使用<strong>elasticsearch</strong>作为索引及搜索服务。</p><h3 id="1-2-2、课程搜索"><a href="#1-2-2、课程搜索" class="headerlink" title="**1.2.**2、课程搜索"></a>**1.2.**2、课程搜索</h3><p>课程索引创建完成，用户才可以通过前端搜索课程信息。</p><p>课程搜索可以从首页进入搜索页面。</p><p><img src="/adanpro/adanblog/./../pic/54021a2f968e450e9c6c32e67173301f.png" alt="img"></p><p>下图是搜索界面，可以通过课程分类、课程难度等级等条件进行搜索。</p><p><img src="/adanpro/adanblog/./../pic/fb7a0d0f36094f8ca465e4a1cb525446.png" alt="img"></p><h1 id="2-准备环境"><a href="#2-准备环境" class="headerlink" title="2 准备环境"></a><strong>2</strong> <strong>准备环境</strong></h1><h2 id="2-0-ES回顾"><a href="#2-0-ES回顾" class="headerlink" title="2.0 ES回顾"></a>2.0 ES回顾</h2><p><a href="https://blog.csdn.net/qq_40991313/article/details/126807267?spm=1001.2014.3001.5501">ElasticSearch基础1——索引和文档。Kibana,RestClient操作索引和文档+黑马旅游ES库导入_elasticsearch 文档 索引_vincewm的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/126819678?spm=1001.2014.3001.5501">elasticsearch基础2——DSL查询文档,黑马旅游项目查询功能_elasticsearch查询文档_vincewm的博客-CSDN博客</a><a href="https://blog.csdn.net/qq_40991313/article/details/126861326?spm=1001.2014.3001.5501">ElasticSearch基础3——聚合、补全、集群。黑马旅游检索高亮+自定义分词器+自动补全+前后端消息同步_vincewm的博客-CSDN博客</a> </p><h2 id="2-1-搭建ES-kibana"><a href="#2-1-搭建ES-kibana" class="headerlink" title="2.1 **搭建ES,**kibana"></a><strong>2.1</strong> **搭建ES,**kibana</h2><p><strong>1.docker搭建ES,kibana：</strong></p><blockquote><p>参考上面回顾文章第一篇。</p></blockquote><p>kibana 是 ELK（Elasticsearch , Logstash, Kibana ）之一，kibana 一款开源的数据分析和可视化平台，通过可视化界面访问elasticsearch的索引库，并可以生成一个数据报表。</p><p>开发中主要使用kibana通过api对elasticsearch进行索引和搜索操作，通过浏览器访问 <a href="http://192.168.101.65:5601/app/dev_tools#/console%E8%BF%9B%E5%85%A5kibana%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%95%8C%E9%9D%A2%E3%80%82">http://192.168.101.65:5601/app/dev_tools#/console进入kibana的开发工具界面。</a></p><p><strong>2.设置ES,kibana容器开机启动</strong> </p><p>修改虚拟机中的启动脚本restart.sh添加</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop elasticsearch</span><br><span class="line"></span><br><span class="line">docker stop kibana</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">docker start elasticsearch</span><br><span class="line"></span><br><span class="line">docker start kibana</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/8f4f9866aa8a4590a749a77cc8d48c6e.png" alt="img"></p><p>可通过命令：GET &#x2F;_cat&#x2F;indices?v 查看所有的索引，通过此命令判断kibana是否正常连接elasticsearch。</p><p>索引相当于MySQL中的表，Elasticsearch与MySQL之间概念的对应关系见下表：</p><p><img src="/adanpro/adanblog/./../pic/072dd615e048472693bcf047c7ed449d.png" alt="img"></p><p>要使用elasticsearch需要建立索引，Mapping相当于表结构，Mapping创建后其字段不能删除，如果要删除需要删除整个索引，下边介绍创建索引、查询索引、删除索引的方法：</p><h2 id="2-2-创建课程索引库"><a href="#2-2-创建课程索引库" class="headerlink" title="2.2 创建课程索引库"></a><strong>2.2 创建课程索引库</strong></h2><p><strong>创建索引，并指定Mapping。</strong></p><p>PUT &#x2F;course-publish</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;number_of_shards&quot;</span>: 1,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>: 0</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;companyId&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;companyName&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;users&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;tags&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;mt&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;mtName&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;st&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;stName&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;grade&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;teachmode&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;pic&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;description&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;createDate&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;status&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;remark&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;charge&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;price&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;scaled_float&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;scaling_factor&quot;</span>: 100</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;originalPrice&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;scaled_float&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;scaling_factor&quot;</span>: 100</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;validDays&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>删除索引</strong></p><p>如果发现创建的course-publish不正确可以删除重新创建。</p><p>删除索引后当中的文档数据也同时删除，一定要谨慎操作！</p><p>删除索引命令：DELETE &#x2F;course-publish</p></blockquote><h2 id="2-3-测试是否创建成功"><a href="#2-3-测试是否创建成功" class="headerlink" title="2.3 测试是否创建成功"></a>2.3 测试是否创建成功</h2><p>通过 GET &#x2F;_cat&#x2F;indices?v 查询所有的索引，查找course-publish是否创建成功。</p><p>通过GET &#x2F;course-publish&#x2F;_mapping 查询course-publish的索引结构。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;course-publish&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;mappings&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;properties&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;charge&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;companyId&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;companyName&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;analyzer&quot;</span> : <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;search_analyzer&quot;</span> : <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;createDate&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;date&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;format&quot;</span> : <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;description&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;analyzer&quot;</span> : <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;search_analyzer&quot;</span> : <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;grade&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;id&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;mt&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;mtName&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;name&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;analyzer&quot;</span> : <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;search_analyzer&quot;</span> : <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;originalPrice&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;scaled_float&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;scaling_factor&quot;</span> : 100.0</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;pic&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;index&quot;</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;price&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;scaled_float&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;scaling_factor&quot;</span> : 100.0</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;remark&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;index&quot;</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;st&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;stName&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;status&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;tags&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;analyzer&quot;</span> : <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;search_analyzer&quot;</span> : <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;teachmode&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;users&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;index&quot;</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;validDays&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;integer&quot;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-初始化-搜索模块"><a href="#2-4-初始化-搜索模块" class="headerlink" title="2.4 初始化****搜索模块"></a><strong>2.4 初始化****搜索模块</strong></h2><p>创建搜索模块：</p><p><img src="/adanpro/adanblog/./../pic/09ee1ea16a7540c0b5d2118002ff74e1.png" alt="img"></p><p>修改bootstrap.xml中nacos的namespace为自己的命名空间。</p><p><img src="/adanpro/adanblog/./../pic/81b14924c49745a7896066433b42fa38.png" alt="img"></p><p><img src="/adanpro/adanblog/./../pic/682d1546de85416d9263d4036b8e7fda.png" alt="img"></p><p>启动网关服务、搜索服务。</p><p>部署完成通过httpclient进行测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 添加课程索引</span></span><br><span class="line"></span><br><span class="line">POST &#123;&#123;search_host&#125;&#125;/search/index/course</span><br><span class="line"></span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;charge&quot;</span> : <span class="string">&quot;201000&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;companyId&quot;</span> : 100000,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;companyName&quot;</span> : <span class="string">&quot;北京黑马程序&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;createDate&quot;</span> : <span class="string">&quot;2022-09-25 09:36:11&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;description&quot;</span> : <span class="string">&quot;《Spring编程思想》是2007年6月1日机械工业出版社出版的图书，作者是埃克尔，译者是陈昊鹏。主要内容本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;grade&quot;</span> : <span class="string">&quot;204001&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;id&quot;</span> : 102,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;mt&quot;</span> : <span class="string">&quot;1-3&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;mtName&quot;</span> : <span class="string">&quot;编程开发&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Spring编程思想&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;originalPrice&quot;</span> : 200.0,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;pic&quot;</span> : <span class="string">&quot;/mediafiles/2022/09/20/1d0f0e6ed8a0c4a89bfd304b84599d9c.png&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;price&quot;</span> : 100.0,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;remark&quot;</span> : <span class="string">&quot;没有备注&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;st&quot;</span> : <span class="string">&quot;1-3-2&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;stName&quot;</span> : <span class="string">&quot;Java语言&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;status&quot;</span> : <span class="string">&quot;203002&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;tags&quot;</span> : <span class="string">&quot;没有标签&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;teachmode&quot;</span> : <span class="string">&quot;200002&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;validDays&quot;</span> : 222</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">### 搜索课程</span></span><br><span class="line"></span><br><span class="line">GET &#123;&#123;search_host&#125;&#125;/search/course/list?pageNo=1&amp;keywords=spring</span><br><span class="line"></span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>进入前端搜索界面<a href="http://www.51xuecheng.cn/course/search.html">http://www.51xuecheng.cn/course/search.html</a></p><p><img src="/adanpro/adanblog/./../pic/6c237d1bbcc84d0189013078113697a8.png" alt="img"></p><h1 id="3-索引管理"><a href="#3-索引管理" class="headerlink" title="3 索引管理"></a><strong>3</strong> <strong>索引管理</strong></h1><h2 id="3-1-文档操作回顾"><a href="#3-1-文档操作回顾" class="headerlink" title="3.1 文档操作回顾"></a><strong>3.1 文档操作回顾</strong></h2><h3 id="3-1-1-添加文档"><a href="#3-1-1-添加文档" class="headerlink" title="3.1.1 添加文档"></a><strong>3.1.1</strong> <strong>添加文档</strong></h3><p>索引创建好就可以向其中添加文档，此时elasticsearch会根据索引的mapping配置对有些字段进行分词。</p><p>这里我们要向course_publish中添加课程信息。</p><p>使用rest api进行测试，如下：</p><p>使用post请求，&#x2F;course-publish&#x2F;_doc&#x2F;103 第一部分为索引名称，_doc固定，103为文档的主键id，这里为课程id。</p><p>课程内容使用json表示。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /course-publish/_doc/103</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;charge&quot;</span> : <span class="string">&quot;201001&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;companyId&quot;</span> : 100000,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;companyName&quot;</span> : <span class="string">&quot;北京黑马程序&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;createDate&quot;</span> : <span class="string">&quot;2022-09-25 09:36:11&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;description&quot;</span> : <span class="string">&quot;HTML/CSS&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;grade&quot;</span> : <span class="string">&quot;204001&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;id&quot;</span> : 102,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;mt&quot;</span> : <span class="string">&quot;1-1&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;mtName&quot;</span> : <span class="string">&quot;前端开发&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Html参考大全&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;originalPrice&quot;</span> : 200.0,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;pic&quot;</span> : <span class="string">&quot;/mediafiles/2022/09/20/e726b71ba99c70e8c9d2850c2a7019d7.jpg&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;price&quot;</span> : 100.0,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;remark&quot;</span> : <span class="string">&quot;没有备注&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;st&quot;</span> : <span class="string">&quot;1-1-1&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;stName&quot;</span> : <span class="string">&quot;HTML/CSS&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;status&quot;</span> : <span class="string">&quot;203002&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;tags&quot;</span> : <span class="string">&quot;没有标签&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;teachmode&quot;</span> : <span class="string">&quot;200002&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;validDays&quot;</span> : 222</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修改文档的内容可以使用上边相同的方法，如果没有则添加，如果存在则更新。</p><h3 id="3-1-2-查询文档"><a href="#3-1-2-查询文档" class="headerlink" title="3.1.2 查询文档"></a><strong>3.1.2</strong> <strong>查询文档</strong></h3><p>添加文档成功后可以通过主键id查询该文档的信息。</p><p>语法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /&#123;索引库名称&#125;/_doc/&#123;<span class="built_in">id</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-更新文档"><a href="#3-1-3-更新文档" class="headerlink" title="3.1.3 更新文档"></a><strong>3.1.3</strong> <strong>更新文档</strong></h3><p>更新文档分为全量更新和局部更新。</p><p>全量更新是指先删除再更新，语法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /&#123;索引库名&#125;/_doc/文档<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;字段1&quot;</span>: <span class="string">&quot;值1&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;字段2&quot;</span>: <span class="string">&quot;值2&quot;</span>,</span><br><span class="line"></span><br><span class="line">    // ... 略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部更新语法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /&#123;索引库名&#125;/_update/文档id</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;字段名&quot;</span>: <span class="string">&quot;新的值&quot;</span>,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-4-删除文档"><a href="#3-1-4-删除文档" class="headerlink" title="3.1.4 删除文档"></a><strong>3.1.4</strong> <strong>删除文档</strong></h3><p>删除文档将从索引中删除文档的记录。</p><p>语法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE /&#123;索引库名&#125;/_doc/id值</span><br></pre></td></tr></table></figure><h2 id="3-2-课程-索引准备"><a href="#3-2-课程-索引准备" class="headerlink" title="3.2 课程****索引准备"></a><strong>3.2 课程****索引准备</strong></h2><p>当课程发布时请求添加课程接口添加课程信息到索引，当课程下架时请求删除课程接口从索引中删除课程信息。 </p><h3 id="3-2-1-课程索引模型类"><a href="#3-2-1-课程索引模型类" class="headerlink" title="3.2.1 课程索引模型类"></a>3.2.1 课程索引模型类</h3><p>根据索引的mapping结构创建po类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.search.po;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 课程索引信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itcast</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CourseIndex</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 主键</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 机构ID</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long companyId;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 公司名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 课程名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 适用人群</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String users;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 标签</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String tags;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 大分类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 大分类名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mtName;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 小分类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String st;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 小分类名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String stName;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 课程等级</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String grade;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 教育模式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String teachmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 课程图片</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 课程介绍</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 发布时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createDate;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 备注</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 收费规则，对应数据字典--203</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String charge;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 现价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 原价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Float originalPrice;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 课程有效期天数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer validDays;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-controller，添加课程索引"><a href="#3-2-2-controller，添加课程索引" class="headerlink" title="3.2.2 controller，添加课程索引"></a>3.2.2 controller，添加课程索引</h3><p>创建索引接口如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.search.controller;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 课程索引接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/24 22:31</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Api(value = &quot;课程信息索引接口&quot;, tags = &quot;课程信息索引接口&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CourseIndexController</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.course.index&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String courseIndexStore;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">    IndexService indexService;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;添加课程索引&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;course&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> CourseIndex courseIndex)</span> &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> courseIndex.getId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(id==<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;课程id为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> indexService.addCourseIndex(courseIndexStore, String.valueOf(id), courseIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line"></span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;添加课程索引失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-业务实现，添加课程索引"><a href="#3-3-业务实现，添加课程索引" class="headerlink" title="3.3 业务实现，添加课程索引"></a><strong>3.3 业务实现，</strong>添加课程索引</h2><p>定义service接口，请求elasticsearch添加课程信息。</p><blockquote><p>注意：为了适应其它文档信息，将添加文档定义为通用的添加文档接口，此接口不仅应添加课程还应添加其它信息。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.search.service.impl;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 课程索引管理接口实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IndexService</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line"> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Boolean <span class="title function_">addCourseIndex</span><span class="params">(String indexName,String id,Object object)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(object);</span><br><span class="line"></span><br><span class="line">  <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(indexName).id(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定索引文档内容</span></span><br><span class="line"></span><br><span class="line">  indexRequest.source(jsonString,XContentType.JSON);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//索引响应对象</span></span><br><span class="line"></span><br><span class="line">  <span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">   indexResponse = client.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">   log.error(<span class="string">&quot;添加索引出错:&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line"></span><br><span class="line">   e.printStackTrace();</span><br><span class="line"></span><br><span class="line">   XueChengPlusException.cast(<span class="string">&quot;添加索引出错&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> indexResponse.getResult().name();</span><br><span class="line"></span><br><span class="line">  System.out.println(name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name.equalsIgnoreCase(<span class="string">&quot;created&quot;</span>) || name.equalsIgnoreCase(<span class="string">&quot;updated&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a><strong>3.4</strong> <strong>测试</strong></h2><p>使用httpclient进行测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 添加课程索引</span></span><br><span class="line"></span><br><span class="line">POST &#123;&#123;search_host&#125;&#125;/search/index/course</span><br><span class="line"></span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;charge&quot;</span> : <span class="string">&quot;201000&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;companyId&quot;</span> : 100000,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;companyName&quot;</span> : <span class="string">&quot;北京黑马程序员&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;createDate&quot;</span> : <span class="string">&quot;2022-09-25 09:36:11&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;description&quot;</span> : <span class="string">&quot;《Java编程思想》是2007年6月1日机械工业出版社出版的图书，作者是埃克尔，译者是陈昊鹏。主要内容本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;grade&quot;</span> : <span class="string">&quot;204001&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;id&quot;</span> : 102,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;mt&quot;</span> : <span class="string">&quot;1-3&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;mtName&quot;</span> : <span class="string">&quot;编程开发&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Java编程思想&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;originalPrice&quot;</span> : 200.0,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;pic&quot;</span> : <span class="string">&quot;/mediafiles/2022/09/20/1d0f0e6ed8a0c4a89bfd304b84599d9c.png&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;price&quot;</span> : 100.0,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;remark&quot;</span> : <span class="string">&quot;没有备注&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;st&quot;</span> : <span class="string">&quot;1-3-2&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;stName&quot;</span> : <span class="string">&quot;Java语言&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;status&quot;</span> : <span class="string">&quot;203002&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;tags&quot;</span> : <span class="string">&quot;没有标签&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;teachmode&quot;</span> : <span class="string">&quot;200002&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;validDays&quot;</span> : 222</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-课程-搜索"><a href="#4-课程-搜索" class="headerlink" title="4 课程****搜索"></a><strong>4 课程****搜索</strong></h1><h2 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a><strong>4.1</strong> <strong>需求分析</strong></h2><p>索引信息维护完成下一步定义搜索接口搜索课程信息，首先需要搞清楚搜索功能的需求。</p><p>进入搜索界面，如下图：</p><p><img src="/adanpro/adanblog/./../pic/246ece546d4a4c35890d45634e10ceb5.png" alt="img"></p><p>根据搜索界面可知<strong>需求</strong>如下：</p><p>1、根据一级分类、二级分类搜索课程信息。</p><p>2、根据关键字搜索课程信息，搜索方式为全文检索，关键字需要匹配课程的名称、 课程内容。</p><p>3、根据难度等级搜索课程。</p><p>4、搜索结点分页显示。</p><p><strong>技术点：</strong></p><p>1、整体采用布尔查询。</p><p>2、根据关键字搜索，采用MultiMatchQuery，搜索name、description字段。</p><p>3、根据分类、课程等级搜索采用过滤器实现。</p><p>4、分页查询。</p><p>5、高亮显示。</p><blockquote><p><strong>为什么课程分类、课程等级等查询使用过滤器方式？</strong></p><p>使用关键字查询需要计算相关度得分，根据课程分类、课程等级去查询不需要计算相关度得分，使用过滤器实现根据课程分类、课程等级查询的过程<strong>不会计算相关度得分</strong>，效率更高。</p></blockquote><h2 id="4-2-接口定义"><a href="#4-2-接口定义" class="headerlink" title="4.2 接口定义"></a><strong>4.2</strong> <strong>接口定义</strong></h2><h3 id="4-2-1-搜索条件DTO类"><a href="#4-2-1-搜索条件DTO类" class="headerlink" title="4.2.1 搜索条件DTO类"></a>4.2.1 搜索条件DTO类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.search.dto;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 搜索课程参数dtl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/24 22:36</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Data</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@ToString</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchCourseParamDto</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">//关键字</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String keywords;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">//大分类</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String mt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">//小分类</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String st;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//难度等级</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String grade;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-搜索结果类"><a href="#4-2-2-搜索结果类" class="headerlink" title="4.2.2 搜索结果类"></a>4.2.2 搜索结果类</h3><p>为了适应后期的扩展，定义搜索结果类，让它继承PageResult</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.search.dto;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchPageResultDto</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">PageResult</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//大分类列表</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; mtList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小分类列表</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stList;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SearchPageResultDto</span><span class="params">(List&lt;T&gt; items, <span class="type">long</span> counts, <span class="type">long</span> page, <span class="type">long</span> pageSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(items, counts, page, pageSize);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-课程搜索controller"><a href="#4-2-3-课程搜索controller" class="headerlink" title="4.2.3 课程搜索controller"></a>4.2.3 课程搜索controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.search.controller;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 课程搜索接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Api(value = &quot;课程搜索接口&quot;,tags = &quot;课程搜索接口&quot;)</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/course&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CourseSearchController</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line"> CourseSearchService courseSearchService;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="meta">@ApiOperation(&quot;课程搜索列表&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> SearchPageResultDto&lt;CourseIndex&gt; <span class="title function_">list</span><span class="params">(PageParams pageParams, SearchCourseParamDto searchCourseParamDto)</span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> courseSearchService.queryCoursePubIndex(pageParams,searchCourseParamDto);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-课程搜索service完整代码"><a href="#4-2-4-课程搜索service完整代码" class="headerlink" title="4.2.4 课程搜索service完整代码"></a>4.2.4 课程搜索service完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> SearchPageResultDto&lt;CourseIndex&gt; <span class="title function_">queryCoursePubIndex</span><span class="params">(PageParams pageParams, SearchCourseParamDto courseSearchParam)</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置索引</span></span><br><span class="line"></span><br><span class="line">     <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(courseIndexStore);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">     <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//source源字段过虑</span></span><br><span class="line"></span><br><span class="line">     String[] sourceFieldsArray = sourceFields.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">     searchSourceBuilder.fetchSource(sourceFieldsArray, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(courseSearchParam==<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">         courseSearchParam = <span class="keyword">new</span> <span class="title class_">SearchCourseParamDto</span>();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//关键字</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getKeywords()))&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//匹配关键字</span></span><br><span class="line"></span><br><span class="line">         <span class="type">MultiMatchQueryBuilder</span> <span class="variable">multiMatchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.multiMatchQuery(courseSearchParam.getKeywords(), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;description&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//设置匹配占比</span></span><br><span class="line"></span><br><span class="line">         multiMatchQueryBuilder.minimumShouldMatch(<span class="string">&quot;70%&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//提升另个字段的Boost值</span></span><br><span class="line"></span><br><span class="line">         multiMatchQueryBuilder.field(<span class="string">&quot;name&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">         boolQueryBuilder.must(multiMatchQueryBuilder);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//过虑</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getMt()))&#123;</span><br><span class="line"></span><br><span class="line">         boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;mtName&quot;</span>,courseSearchParam.getMt()));</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getSt()))&#123;</span><br><span class="line"></span><br><span class="line">         boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;stName&quot;</span>,courseSearchParam.getSt()));</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getGrade()))&#123;</span><br><span class="line"></span><br><span class="line">         boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;grade&quot;</span>,courseSearchParam.getGrade()));</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//分页</span></span><br><span class="line"></span><br><span class="line">     <span class="type">Long</span> <span class="variable">pageNo</span> <span class="operator">=</span> pageParams.getPageNo();</span><br><span class="line"></span><br><span class="line">     <span class="type">Long</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageParams.getPageSize();</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (<span class="type">int</span>) ((pageNo-<span class="number">1</span>)*pageSize);</span><br><span class="line"></span><br><span class="line">     searchSourceBuilder.from(start);</span><br><span class="line"></span><br><span class="line">     searchSourceBuilder.size(Math.toIntExact(pageSize));</span><br><span class="line"></span><br><span class="line">     <span class="comment">//布尔查询</span></span><br><span class="line"></span><br><span class="line">     searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//高亮设置</span></span><br><span class="line"></span><br><span class="line">     <span class="type">HighlightBuilder</span> <span class="variable">highlightBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>();</span><br><span class="line"></span><br><span class="line">     highlightBuilder.preTags(<span class="string">&quot;&lt;font class=&#x27;eslight&#x27;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">     highlightBuilder.postTags(<span class="string">&quot;&lt;/font&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置高亮字段</span></span><br><span class="line"></span><br><span class="line">     highlightBuilder.fields().add(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>.Field(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">     searchSourceBuilder.highlighter(highlightBuilder);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//请求搜索</span></span><br><span class="line"></span><br><span class="line">     searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//聚合设置</span></span><br><span class="line"></span><br><span class="line">     buildAggregation(searchRequest);</span><br><span class="line"></span><br><span class="line">     <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">         e.printStackTrace();</span><br><span class="line"></span><br><span class="line">         log.error(<span class="string">&quot;课程搜索异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;CourseIndex&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="comment">//结果集处理</span></span><br><span class="line"></span><br><span class="line">     <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line"></span><br><span class="line">     SearchHit[] searchHits = hits.getHits();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//记录总数</span></span><br><span class="line"></span><br><span class="line">     <span class="type">TotalHits</span> <span class="variable">totalHits</span> <span class="operator">=</span> hits.getTotalHits();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//数据列表</span></span><br><span class="line"></span><br><span class="line">     List&lt;CourseIndex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line"></span><br><span class="line">         <span class="type">CourseIndex</span> <span class="variable">courseIndex</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, CourseIndex.class);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         <span class="comment">//取出source</span></span><br><span class="line"></span><br><span class="line">         Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         <span class="comment">//课程id</span></span><br><span class="line"></span><br><span class="line">         <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> courseIndex.getId();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//取出名称</span></span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> courseIndex.getName();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//取出高亮字段内容</span></span><br><span class="line"></span><br><span class="line">         Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(highlightFields!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">             <span class="type">HighlightField</span> <span class="variable">nameField</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(nameField!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                 Text[] fragments = nameField.getFragments();</span><br><span class="line"></span><br><span class="line">                 <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">for</span> (Text str : fragments) &#123;</span><br><span class="line"></span><br><span class="line">                     stringBuffer.append(str.string());</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 name = stringBuffer.toString();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         courseIndex.setId(id);</span><br><span class="line"></span><br><span class="line">         courseIndex.setName(name);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         list.add(courseIndex);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     SearchPageResultDto&lt;CourseIndex&gt; pageResult = <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;&gt;(list, totalHits.value,pageNo,pageSize);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取聚合结果</span></span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; mtList= getAggregation(searchResponse.getAggregations(), <span class="string">&quot;mtAgg&quot;</span>);</span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; stList = getAggregation(searchResponse.getAggregations(), <span class="string">&quot;stAgg&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     pageResult.setMtList(mtList);</span><br><span class="line"></span><br><span class="line">     pageResult.setStList(stList);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> pageResult;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-基本查询实现"><a href="#4-3-基本查询实现" class="headerlink" title="4.3 基本查询实现"></a><strong>4.3</strong> <strong>基本查询实现</strong></h2><h3 id="4-3-1-service"><a href="#4-3-1-service" class="headerlink" title="4.3.1 service"></a>4.3.1 service</h3><p>搜索接口的内容较多，我们分几步实现，首先实现根据分页搜索，接口实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.search.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 课程搜索service实现类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/24 22:48</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CourseSearchServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CourseSearchService</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.course.index&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String courseIndexStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.course.source_fields&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sourceFields;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">    RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 搜索课程列表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageParams 分页参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> searchCourseParamDto 搜索条件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PageResult&lt;CourseIndex&gt; 课程列表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/24 22:45</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SearchPageResultDto&lt;CourseIndex&gt; <span class="title function_">queryCoursePubIndex</span><span class="params">(PageParams pageParams, SearchCourseParamDto courseSearchParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置索引</span></span><br><span class="line"></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(courseIndexStore);</span><br><span class="line"></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//source源字段过虑</span></span><br><span class="line"></span><br><span class="line">        String[] sourceFieldsArray = sourceFields.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">        searchSourceBuilder.fetchSource(sourceFieldsArray, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分页</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">pageNo</span> <span class="operator">=</span> pageParams.getPageNo();</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageParams.getPageSize();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (<span class="type">int</span>) ((pageNo-<span class="number">1</span>)*pageSize);</span><br><span class="line"></span><br><span class="line">        searchSourceBuilder.from(start);</span><br><span class="line"></span><br><span class="line">        searchSourceBuilder.size(Math.toIntExact(pageSize));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//布尔查询</span></span><br><span class="line"></span><br><span class="line">        searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求搜索</span></span><br><span class="line"></span><br><span class="line">        searchRequest.source(searchSourceBuilder);    </span><br><span class="line"></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;课程搜索异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;CourseIndex&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果集处理</span></span><br><span class="line"></span><br><span class="line">        <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line"></span><br><span class="line">        SearchHit[] searchHits = hits.getHits();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录总数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TotalHits</span> <span class="variable">totalHits</span> <span class="operator">=</span> hits.getTotalHits();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据列表</span></span><br><span class="line"></span><br><span class="line">        List&lt;CourseIndex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line"></span><br><span class="line">            <span class="type">CourseIndex</span> <span class="variable">courseIndex</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, CourseIndex.class);</span><br><span class="line"></span><br><span class="line">            list.add(courseIndex);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SearchPageResultDto&lt;CourseIndex&gt; pageResult = <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;&gt;(list, totalHits.value,pageNo,pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pageResult;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-测试"><a href="#4-3-2-测试" class="headerlink" title="4.3.2 测试"></a><strong>4.3.2</strong> <strong>测试</strong></h3><p>当输入查询条件时会查询全部课程信息并支持分页查询。</p><p>1、准备测试</p><p>启动nginx、网关、搜索服务。</p><p>使用kibana通过rest api向索引库添加课程信息，或通过httpclient添加课程信息，至少添加两条信息。</p><p>2、进入搜索界面</p><p>默认查询出刚才添加的课程信息。</p><p>3、修改分页参数测试分页</p><p>打开course&#x2F; search.html页面 ，找到如下图所示位置：</p><p><img src="/adanpro/adanblog/./../pic/91988db821f34d4a93780a8bf54d093f.png" alt="img"></p><p>修改pageSize为1,即一页显示一条记录。</p><p>刷新搜索界面，每页显示一条记录，如下图：</p><p><img src="/adanpro/adanblog/./../pic/9e85b443ecfb4e8a8a4c52c8e91db3f2.png" alt="img"></p><h2 id="4-4-根据条件搜索"><a href="#4-4-根据条件搜索" class="headerlink" title="4.4 根据条件搜索"></a><strong>4.4</strong> <strong>根据条件搜索</strong></h2><p>下边实现根据关键、一级分类、二级分类、难度等级搜索。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SearchPageResultDto&lt;CourseIndex&gt; <span class="title function_">queryCoursePubIndex</span><span class="params">(PageParams pageParams, SearchCourseParamDto courseSearchParam)</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置索引</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(courseIndexStore);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//source源字段过虑</span></span><br><span class="line"></span><br><span class="line">    String[] sourceFieldsArray = sourceFields.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.fetchSource(sourceFieldsArray, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(courseSearchParam==<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        courseSearchParam = <span class="keyword">new</span> <span class="title class_">SearchCourseParamDto</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getKeywords()))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MultiMatchQueryBuilder</span> <span class="variable">multiMatchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.multiMatchQuery(courseSearchParam.getKeywords(), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;description&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置匹配占比</span></span><br><span class="line"></span><br><span class="line">        multiMatchQueryBuilder.minimumShouldMatch(<span class="string">&quot;70%&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提升另个字段的Boost值</span></span><br><span class="line"></span><br><span class="line">        multiMatchQueryBuilder.field(<span class="string">&quot;name&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.must(multiMatchQueryBuilder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过虑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getMt()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;mtName&quot;</span>,courseSearchParam.getMt()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getSt()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;stName&quot;</span>,courseSearchParam.getSt()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getGrade()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;grade&quot;</span>,courseSearchParam.getGrade()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">pageNo</span> <span class="operator">=</span> pageParams.getPageNo();</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageParams.getPageSize();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (<span class="type">int</span>) ((pageNo-<span class="number">1</span>)*pageSize);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.from(start);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.size(Math.toIntExact(pageSize));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//布尔查询</span></span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求搜索</span></span><br><span class="line"></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;课程搜索异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;CourseIndex&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果集处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line"></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录总数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TotalHits</span> <span class="variable">totalHits</span> <span class="operator">=</span> hits.getTotalHits();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据列表</span></span><br><span class="line"></span><br><span class="line">    List&lt;CourseIndex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line"></span><br><span class="line">        <span class="type">CourseIndex</span> <span class="variable">courseIndex</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, CourseIndex.class);</span><br><span class="line"></span><br><span class="line">        list.add(courseIndex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SearchPageResultDto&lt;CourseIndex&gt; pageResult = <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;&gt;(list, totalHits.value,pageNo,pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pageResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><p>进入搜索界面，输入关键字进行测试。</p><p>一级分类、二级分类在下边的聚合搜索中测试。</p><h2 id="4-5-聚合搜索，动态获取两级分类"><a href="#4-5-聚合搜索，动态获取两级分类" class="headerlink" title="4.5 聚合搜索，动态获取两级分类"></a><strong>4.5</strong> <strong>聚合搜索，动态获取两级分类</strong></h2><h3 id="4-5-1-实现"><a href="#4-5-1-实现" class="headerlink" title="4.5.1 实现"></a>4.5.1 实现</h3><p>搜索界面上显示的一级分类、二级分类来源于搜索结果，使用聚合搜索实现<strong>获取搜索结果中的一级分类、二级分类:</strong></p><p>搜索方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SearchPageResultDto&lt;CourseIndex&gt; <span class="title function_">queryCoursePubIndex</span><span class="params">(PageParams pageParams, SearchCourseParamDto courseSearchParam)</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置索引</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(courseIndexStore);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//source源字段过虑</span></span><br><span class="line"></span><br><span class="line">    String[] sourceFieldsArray = sourceFields.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.fetchSource(sourceFieldsArray, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(courseSearchParam==<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        courseSearchParam = <span class="keyword">new</span> <span class="title class_">SearchCourseParamDto</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getKeywords()))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MultiMatchQueryBuilder</span> <span class="variable">multiMatchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.multiMatchQuery(courseSearchParam.getKeywords(), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;description&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置匹配占比</span></span><br><span class="line"></span><br><span class="line">        multiMatchQueryBuilder.minimumShouldMatch(<span class="string">&quot;70%&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提升另个字段的Boost值</span></span><br><span class="line"></span><br><span class="line">        multiMatchQueryBuilder.field(<span class="string">&quot;name&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.must(multiMatchQueryBuilder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过虑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getMt()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;mtName&quot;</span>,courseSearchParam.getMt()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getSt()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;stName&quot;</span>,courseSearchParam.getSt()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getGrade()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;grade&quot;</span>,courseSearchParam.getGrade()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">pageNo</span> <span class="operator">=</span> pageParams.getPageNo();</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageParams.getPageSize();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (<span class="type">int</span>) ((pageNo-<span class="number">1</span>)*pageSize);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.from(start);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.size(Math.toIntExact(pageSize));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//布尔查询</span></span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求搜索</span></span><br><span class="line"></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚合设置</span></span><br><span class="line"></span><br><span class="line">    buildAggregation(searchRequest);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;课程搜索异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;CourseIndex&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果集处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line"></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录总数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TotalHits</span> <span class="variable">totalHits</span> <span class="operator">=</span> hits.getTotalHits();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据列表</span></span><br><span class="line"></span><br><span class="line">    List&lt;CourseIndex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line"></span><br><span class="line">        <span class="type">CourseIndex</span> <span class="variable">courseIndex</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, CourseIndex.class);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        list.add(courseIndex);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SearchPageResultDto&lt;CourseIndex&gt; pageResult = <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;&gt;(list, totalHits.value,pageNo,pageSize);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取聚合结果</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; mtList= getAggregation(searchResponse.getAggregations(), <span class="string">&quot;mtAgg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stList = getAggregation(searchResponse.getAggregations(), <span class="string">&quot;stAgg&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    pageResult.setMtList(mtList);</span><br><span class="line"></span><br><span class="line">    pageResult.setStList(stList);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pageResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-2-聚合搜索测试"><a href="#4-5-2-聚合搜索测试" class="headerlink" title="4.5.2 聚合搜索测试"></a><strong>4.5.2</strong> <strong>聚合搜索测试</strong></h3><p>进入搜索界面，观察搜索请求的响应内容中是否存在mtList和stList.</p><p>观察页面一级分类、二级分类是否有分类信息。</p><p>注意：当选中一个一级分类时才会显示二级分类。</p><h2 id="4-6-高亮设置"><a href="#4-6-高亮设置" class="headerlink" title="4.6 高亮设置"></a><strong>4.6</strong> <strong>高亮设置</strong></h2><h3 id="4-6-1-实现"><a href="#4-6-1-实现" class="headerlink" title="4.6.1 实现"></a><strong>4.6.1 实现</strong></h3><p>最后实现关键词在课程名称中高亮显示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SearchPageResultDto&lt;CourseIndex&gt; <span class="title function_">queryCoursePubIndex</span><span class="params">(PageParams pageParams, SearchCourseParamDto courseSearchParam)</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置索引</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(courseIndexStore);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//source源字段过虑</span></span><br><span class="line"></span><br><span class="line">    String[] sourceFieldsArray = sourceFields.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.fetchSource(sourceFieldsArray, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(courseSearchParam==<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        courseSearchParam = <span class="keyword">new</span> <span class="title class_">SearchCourseParamDto</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getKeywords()))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MultiMatchQueryBuilder</span> <span class="variable">multiMatchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.multiMatchQuery(courseSearchParam.getKeywords(), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;description&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置匹配占比</span></span><br><span class="line"></span><br><span class="line">        multiMatchQueryBuilder.minimumShouldMatch(<span class="string">&quot;70%&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提升另个字段的Boost值</span></span><br><span class="line"></span><br><span class="line">        multiMatchQueryBuilder.field(<span class="string">&quot;name&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.must(multiMatchQueryBuilder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//过虑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getMt()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;mtName&quot;</span>,courseSearchParam.getMt()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getSt()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;stName&quot;</span>,courseSearchParam.getSt()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getGrade()))&#123;</span><br><span class="line"></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;grade&quot;</span>,courseSearchParam.getGrade()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">pageNo</span> <span class="operator">=</span> pageParams.getPageNo();</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageParams.getPageSize();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (<span class="type">int</span>) ((pageNo-<span class="number">1</span>)*pageSize);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.from(start);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.size(Math.toIntExact(pageSize));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//布尔查询</span></span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高亮设置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">HighlightBuilder</span> <span class="variable">highlightBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>();</span><br><span class="line"></span><br><span class="line">    highlightBuilder.preTags(<span class="string">&quot;&lt;font class=&#x27;eslight&#x27;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    highlightBuilder.postTags(<span class="string">&quot;&lt;/font&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置高亮字段</span></span><br><span class="line"></span><br><span class="line">    highlightBuilder.fields().add(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>.Field(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.highlighter(highlightBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求搜索</span></span><br><span class="line"></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚合设置</span></span><br><span class="line"></span><br><span class="line">    buildAggregation(searchRequest);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;课程搜索异常：&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;CourseIndex&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果集处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line"></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录总数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TotalHits</span> <span class="variable">totalHits</span> <span class="operator">=</span> hits.getTotalHits();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据列表</span></span><br><span class="line"></span><br><span class="line">    List&lt;CourseIndex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line"></span><br><span class="line">        <span class="type">CourseIndex</span> <span class="variable">courseIndex</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, CourseIndex.class);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出source</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//课程id</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> courseIndex.getId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出名称</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> courseIndex.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出高亮字段内容</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(highlightFields!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">nameField</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nameField!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                Text[] fragments = nameField.getFragments();</span><br><span class="line"></span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Text str : fragments) &#123;</span><br><span class="line"></span><br><span class="line">                    stringBuffer.append(str.string());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                name = stringBuffer.toString();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        courseIndex.setId(id);</span><br><span class="line"></span><br><span class="line">        courseIndex.setName(name);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        list.add(courseIndex);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SearchPageResultDto&lt;CourseIndex&gt; pageResult = <span class="keyword">new</span> <span class="title class_">SearchPageResultDto</span>&lt;&gt;(list, totalHits.value,pageNo,pageSize);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取聚合结果</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; mtList= getAggregation(searchResponse.getAggregations(), <span class="string">&quot;mtAgg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stList = getAggregation(searchResponse.getAggregations(), <span class="string">&quot;stAgg&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    pageResult.setMtList(mtList);</span><br><span class="line"></span><br><span class="line">    pageResult.setStList(stList);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pageResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-2-高亮设置测试"><a href="#4-6-2-高亮设置测试" class="headerlink" title="4.6.2 高亮设置测试"></a><strong>4.6.2</strong> <strong>高亮设置测试</strong></h3><p>输入关键字，观察搜索结果，标题中是否对关键字信息进行高亮显示。</p><h1 id="5-课程信息和索引同步"><a href="#5-课程信息和索引同步" class="headerlink" title="5 课程信息和索引同步"></a><strong>5</strong> <strong>课程信息和索引同步</strong></h1><h2 id="5-1-技术方案"><a href="#5-1-技术方案" class="headerlink" title="5.1 技术方案"></a><strong>5.1</strong> <strong>技术方案</strong></h2><h3 id="5-1-1-实时性要求高的场景方案选择"><a href="#5-1-1-实时性要求高的场景方案选择" class="headerlink" title="5.1.1 实时性要求高的场景方案选择"></a>5.1.1 <strong>实时性要求高的场景方案选择</strong></h3><blockquote><p>通过向索引中添加课程信息最终实现了课程的搜索，我们发现课程信息是先保存在关系数据库中，而后再写入索引，这个过程是将关系数据中的数据同步到elasticsearch索引中的过程，可以简单成为索引同步。</p><p>通常项目中使用elasticsearch需要完成索引同步.</p></blockquote><p>针对实时性非常高的场景需要满足数据的及时同步，可以同步调用，或使用Canal去实现。</p><p>1）<strong>同步调用：</strong>同步调用即在向MySQL写数据后<strong>远程调用</strong>搜索服务的接口写入索引，此方法简单但是<strong>耦合</strong>代码太高。</p><p>2）<strong>canal：</strong>可以使用一个中间的软件canal解决耦合性的问题，但存在学习与维护成本。</p><h3 id="5-1-2-中间件Canal介绍"><a href="#5-1-2-中间件Canal介绍" class="headerlink" title="5.1.2 中间件Canal介绍"></a>5.1.2 中间件Canal介绍</h3><p><strong>canal</strong>主要用途是基于 MySQL 数据库增量日志解析，并能提供增量数据订阅和消费，实现将MySQL的数据<strong>同步</strong>到消息队列、Elasticsearch、其它数据库等，应用场景十分丰富。</p><p><img src="/adanpro/adanblog/./../pic/bba66b001919471e96bfb9753bc1d2bb.png" alt="img"></p><p>它的地址：</p><p>github地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p><p>版本下载地址：<a href="https://github.com/alibaba/canal/releases">https://github.com/alibaba/canal/releases</a></p><p>文档地址：<a href="https://github.com/alibaba/canal/wiki/Docker-QuickStart">https://github.com/alibaba/canal/wiki/Docker-QuickStart</a></p><p><strong>Canal基于mysql的binlog技术实现数据同步</strong>，什么是binlog，它是一个文件，二进制格式，记录了对数据库更新的SQL语句，向数据库写数据的同时向binlog文件里记录对应的sql语句。当数据库服务器发生了故障就可以使用binlog文件对数据库进行恢复。</p><p>所以，使用canal是需要开启mysql的binlog写入功能，Canal工作原理如下：</p><p><img src="/adanpro/adanblog/./../pic/51c7c4882ae64931bd044548bd54e730.png" alt="img"></p><p>1、canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump</p><p>协议</p><p>2、MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</p><p>3、canal 解析 binary log 对象(原始为 byte 流)</p><p>详细使用Canal进行索引同步的步骤参考：Canal实现索引同步.pdf</p><h3 id="5-1-3-实时性要求不高的方案（使用）"><a href="#5-1-3-实时性要求不高的方案（使用）" class="headerlink" title="5.1.3 实时性要求不高的方案（使用）"></a>5.1.3 实时性要求不高的方案（使用）</h3><p>当索引同步的实时性要求不高时可用的技术比较多，比如：MQ、Logstash、任务调度等。</p><p><strong>MQ：</strong>向mysql写数据的时候向mq写入消息，搜索服务监听MQ，收到消息后写入索引。使用MQ的优势是代码解耦，但是需要处理消息可靠性的问题有一定的技术成本，做到消息可靠性需要做到生产者投递成功、消息持久化以及消费者消费成功三个方面，另外还要做好消息幂等性问题。</p><p><strong>Logstash：</strong> 开源实时日志分析平台 ELK包括Elasticsearch、Kibana、Logstash，Logstash负责收集、解析和转换日志信息，可以实现MySQL与Elasticsearch之间的数据同步。也可以实现解耦合并且是官方推荐，但需要增加学习与维护成本。</p><p><strong>任务调度（使用）：</strong>向mysql写数据的时候记录修改记录，开启一个定时任务根据修改记录将数据同步到Elasticsearch。</p><p>根据本项目的需求，课程发布后信息同步的实时性要求不高，从提交审核到发布成功一般两个工作日完成。综合比较以上技术方案本项目的索引同步技术使用任务调度的方法。</p><p>如下图：</p><p><img src="/adanpro/adanblog/./../pic/74a74315351c46c0aa27f916b7d2571b.png" alt="img"></p><p>1、课程发布向消息表插入记录。</p><p>2、由任务调度程序通过消息处理SDK对消息记录进行处理。</p><p>3、向elasticsearch索引中保存课程信息。</p><p>如何向向elasticsearch索引中保存课程信息？</p><p>执行流程如下：</p><p>由内容管理服务远程调用搜索服务添加课程信息索引，搜索服务再请求elasticsearch向课程索引中添加文档。</p><h2 id="5-2-任务调度方式实现索引同步"><a href="#5-2-任务调度方式实现索引同步" class="headerlink" title="5.2 任务调度方式实现索引同步"></a><strong>5.2</strong> <strong>任务调度方式实现索引同步</strong></h2><p>首先拷贝CourseIndex 模型类到内容管理model 工程的dto包下。</p><h3 id="5-2-1-内容服务远程调用搜索服务，并设置熔断降级"><a href="#5-2-1-内容服务远程调用搜索服务，并设置熔断降级" class="headerlink" title="5.2.1 内容服务远程调用搜索服务，并设置熔断降级"></a>5.2.1 内容服务远程调用搜索服务，并设置熔断降级</h3><p>在内容管理服务中添加FeignClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.feignclient;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 搜索服务远程接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/20 20:29</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;search&quot;,fallbackFactory = SearchServiceClientFallbackFactory.class)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SearchServiceClient</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="meta">@PostMapping(&quot;/search/index/course&quot;)</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Boolean <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> CourseIndex courseIndex)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义SearchServiceClientFallbackFactory ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchServiceClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;SearchServiceClient&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SearchServiceClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchServiceClient</span>() &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">add</span><span class="params">(CourseIndex courseIndex)</span> &#123;</span><br><span class="line"></span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line"></span><br><span class="line">                log.debug(<span class="string">&quot;调用搜索发生熔断走降级方法,熔断异常:&quot;</span>, throwable.getMessage());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-课程发布的任务类补充保存索引库方法"><a href="#5-2-2-课程发布的任务类补充保存索引库方法" class="headerlink" title="5.2.2 课程发布的任务类补充保存索引库方法"></a>5.2.2 课程发布的任务类补充保存索引库方法</h3><p>编写课程索引任务执行方法</p><p>完善<strong>CoursePublishTask类</strong>中的saveCourseIndex方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存课程索引信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveCourseIndex</span><span class="params">(MqMessage mqMessage,<span class="type">long</span> courseId)</span>&#123;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;保存课程索引信息,课程id:&#123;&#125;&quot;</span>,courseId);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息id</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> mqMessage.getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息处理的service</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MqMessageService</span> <span class="variable">mqMessageService</span> <span class="operator">=</span> <span class="built_in">this</span>.getMqMessageService();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息幂等性处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">stageTwo</span> <span class="operator">=</span> mqMessageService.getStageTwo(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stageTwo &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;课程索引已处理直接返回，课程id:&#123;&#125;&quot;</span>,courseId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> saveCourseIndex(courseId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存第一阶段状态</span></span><br><span class="line"></span><br><span class="line">        mqMessageService.completedStageTwo(id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">saveCourseIndex</span><span class="params">(Long courseId)</span> &#123;</span><br><span class="line">    <span class="comment">//取出课程发布信息</span></span><br><span class="line">    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> coursePublishMapper.selectById(courseId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝至课程索引对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">CourseIndex</span> <span class="variable">courseIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CourseIndex</span>();</span><br><span class="line"></span><br><span class="line">    BeanUtils.copyProperties(coursePublish,courseIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程调用搜索服务api添加课程信息到索引</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">add</span> <span class="operator">=</span> searchServiceClient.add(courseIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!add)&#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;添加索引失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-测试"><a href="#5-2-3-测试" class="headerlink" title="5.2.3 测试"></a><strong>5.2.3</strong> <strong>测试</strong></h3><p>测试流程如下：</p><p>1、启动elasticsearch、kibana。</p><p>2、启动网关、内容管理、搜索服务、nginx。</p><p>3、启动xxl-job调度中心。</p><p>4、在任务调度中心开始课程发布任务。</p><p>5、发布一门课程，页面提示操作成功，查看发布课程任务是否写到任务表。</p><p>6、经过任务调度将课程信息写入索引。</p><p>7、通过门户进入搜索页面，查看课程信息是否展示。</p>]]></content>
      
      
      <categories>
          
          <category> xcplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>媒资管理模块</title>
      <link href="/adanpro/adanblog/2023/06/28/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/"/>
      <url>/adanpro/adanblog/2023/06/28/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="模块需求分析"><a href="#模块需求分析" class="headerlink" title="模块需求分析"></a>模块需求分析</h1><h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><ul><li>媒资管理系统是每个在线教育平台所必须具备的，百度百科对其定义如下</li></ul><blockquote><p>媒体资源管理(Media Asset Management，MAM)系统是建立在多媒体、网络、数据库和数字存储等先进技术基础上的一个对各种媒体及内容(如视&#x2F;音频资料、文本文件、图表等)进行数字化存储、管理以及应用的总体解决方案，包括数字媒体的采集、编目、管理、传输和编码转换等所有环节。其主要是满足媒体资源拥有者收集、保存、查找、编辑、发布各种信息的要求，为媒体资源的使用者提供访问内容的便捷方法，实现对媒体资源的高效管理，大幅度提高媒体资源的价值。</p></blockquote><ul><li>每个教学机构都可以在媒资管理系统管理自己的教学资源，包括：视频、教案等文件</li><li>目前媒资管理的主要管理对象是视频、图片、文档等，包括：媒资文件的查询、文件上传、视频处理等</li><li>主要的几个功能如下：<ul><li>媒资查询：教学机构查询自己所拥有的的媒资信息</li><li>文件上传：包括上传图片、上传文档、上传视频</li><li>视频处理：视频上传成功，系统自动对视频进行编码处理</li><li>文件删除：教学机构删除自己上传的媒资文件</li></ul></li><li>下图是课程编辑与发布的全流程，可以通过下图看到媒资在整体流程的位置<br><img src="/adanpro/adanblog/./../pic/202306160042201.png" alt="img"></li></ul><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><ul><li>教学机构人员在课程信息编辑页面上传课程图片，课程图片统一记录在媒资管理系统</li></ul><h3 id="上传视频"><a href="#上传视频" class="headerlink" title="上传视频"></a>上传视频</h3><ol><li>教学机构人员进入媒资管理列表查询自己上传的媒资文件</li><li>教育机构用户在<code>媒资管理</code>页面中点击<code>上传视频</code>按钮</li><li>选择要上传的文件，自动执行文件上传</li><li>视频上传成功会自动处理，处理完成后可以预览视频</li></ol><h3 id="处理视频"><a href="#处理视频" class="headerlink" title="处理视频"></a>处理视频</h3><ul><li>对需要转码处理的视频，系统会自动对齐处理，处理后生成视频的URL</li></ul><h3 id="审核媒资"><a href="#审核媒资" class="headerlink" title="审核媒资"></a>审核媒资</h3><ol><li>运营用户登入运营平台，并进入媒资管理界面，查找待审核媒资</li><li>点击列表中媒资名称连接，可以预览该媒资，若是视频，则播放视频</li><li>点击列表中某媒资后的<code>审核按钮</code>，即完成媒资的审批过程</li></ol><h3 id="绑定媒资"><a href="#绑定媒资" class="headerlink" title="绑定媒资"></a>绑定媒资</h3><ul><li>课程计划创建好后需要绑定媒资文件，比如：如果课程计划绑定了视频文件，进入课程在线学习界面后，点课程计划名称则在线播放视频</li><li>如何将课程计划绑定媒资呢？<ol><li>教育机构用户进入课程管理页面编辑某一课程，在<code>课程大纲</code>编辑页的某一小节后，可以添加<code>媒资信息</code></li><li>点击<code>添加视频</code>，会弹出对话框，可通过输入视频关键字搜索已审核通过的视频媒资</li><li>选择视频媒资，点击提交安努，完成课程计划绑定媒资流程</li></ol></li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul><li>本模块妹子恩建相关数据表如下<ol><li>media_files：存储文件信息，包括图片、视频、文档等<br><img src="/adanpro/adanblog/./../pic/202306160042130.png" alt="img"></li><li>media_process：待处理视频表<br><img src="/adanpro/adanblog/./../pic/202306160042674.png" alt="img"></li><li>media_process_history：视频处理历史表，记录已经处理成功的视频信息<br><img src="/adanpro/adanblog/./../pic/202306160123199.png" alt="img"></li></ol></li></ul><h1 id="搭建模块环境"><a href="#搭建模块环境" class="headerlink" title="搭建模块环境"></a>搭建模块环境</h1><h2 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h2><ul><li><p>当前要开发的是媒资管理服务，目前为止共三个微服务：内容管理、系统管理、媒资管理</p></li><li><p>后期还会添加更多的微服务，目前这种由前端直接请求微服务的方式存在弊端</p></li><li><p>如果在前端对每个请求地址都配置绝对路径，非常不利于系统维护，例如下面这种</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//</span> <span class="string">列表</span></span><br><span class="line"><span class="attr">export</span> <span class="string">async function dictionaryAll(params: any = undefined, body: any = undefined): Promise&lt;ISystemDictionary[]&gt; &#123;</span></span><br><span class="line"><span class="attr">//const</span> <span class="string">&#123; data &#125; = await createAPI(&#x27;/system/dictionary/all&#x27;, &#x27;get&#x27;, params, body)</span></span><br><span class="line"><span class="attr">const</span> <span class="string">&#123; data &#125; = await createAPI(&#x27;http://localhost:53110/system/dictionary/all&#x27;, &#x27;get&#x27;, params, body)</span></span><br><span class="line"><span class="attr">return</span> <span class="string">data</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>当系统上限后，需要将localhost改为公网域名，如果这种地址非常多，那么修改会很麻烦</p></li><li><p>基于这个问题，可以采用网关来解决<br><img src="/adanpro/adanblog/./../pic/202306160038170.png" alt="img"></p></li><li><p>这样在前端代码中只需要指定每个接口的相对路径</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//</span> <span class="string">列表</span></span><br><span class="line"><span class="attr">export</span> <span class="string">async function dictionaryAll(params: any = undefined, body: any = undefined): Promise&lt;ISystemDictionary[]&gt; &#123;</span></span><br><span class="line"><span class="attr">//const</span> <span class="string">&#123; data &#125; = await createAPI(&#x27;/system/dictionary/all&#x27;, &#x27;get&#x27;, params, body)</span></span><br><span class="line"><span class="attr">const</span> <span class="string">&#123; data &#125; = await createAPI(&#x27;/system/dictionary/all&#x27;, &#x27;get&#x27;, params, body)</span></span><br><span class="line"><span class="attr">return</span> <span class="string">data</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在前端代码的一个固定的地方在接口地址前统一添加网关地址，每个请求统一到网关，由网关将请求转发到具体的微服务</p></li><li><p>有了网关就可以对请求进行路由，例如：可以根据请求路径路由、根据host地址路由等。当微服务有多个实例时，还可以通过负载均衡算法进行路由</p></li><li><p>此外，网关还可以实现权限控制、限流等功能</p></li><li><p>本项目采用SpringCloudGateway作为网关，网关在请求路由时，需要知道每个微服务实例的地址。</p></li><li><p>项目使用Nacos作为服务发现中心和配置中心，整体架构如下<br><img src="/adanpro/adanblog/./../pic/202306160038249.jpeg" alt="img"></p></li><li><p>流程如下</p><ol><li>微服务启动，将自己注册到Nacos，Nacos记录了个微服务实例的地址</li><li>网关从Nacos读取服务列表，包括服务名称、服务地址等</li><li>请求到达网关，网关将请求路由到具体的微服务</li></ol></li><li><p>要使用网关首先搭建Nacos、Nacos有两个作用</p><ol><li>服务发现中心<ul><li>微服务将自身注册到Nacos，网关从Nacos获取微服务列表</li></ul></li><li>配置中心<ul><li>微服务众多，它们的配置信息也非常复杂，为了提供系统的可维护性，微服务的配置信息统一在Nacos配置</li></ul></li></ol></li></ul><h2 id="搭建Nacos"><a href="#搭建Nacos" class="headerlink" title="搭建Nacos"></a>搭建Nacos</h2><ul><li><p>在此之前我们先下载安装并启动</p><ul><li><p>拉取镜像</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">pull nacos/nacos-server:1.4.1</span></span><br></pre></td></tr></table></figure></li><li><p>创建并运行一个容器</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run --name nacos -e MODE=standalone -p 8849:8848 -d nacos/nacos-server:1.4.1</span></span><br></pre></td></tr></table></figure></li><li><p>访问<code>虚拟机ip:8848/nacos</code>登录，默认的账号密码均为nacos</p></li></ul></li></ul><h3 id="服务发现中心"><a href="#服务发现中心" class="headerlink" title="服务发现中心"></a>服务发现中心</h3><ul><li><p>搭建Nacos服务发现中心之前，需要搞清楚两个概念</p><ol><li>namespace：用于区分环境，例如：开发环境dev、测试环境test、生产环境prod</li><li>group：用于区分项目，例如xuecheng-plus、reggie项目</li></ol></li><li><p>首先，在Nacos配置namespace</p><ul><li>新增开发环境命名空间<br><img src="/adanpro/adanblog/./../pic/202306160038930.png" alt="img"></li><li>用同样的方法新增生产环境和测试环境的命名空间</li></ul></li><li><p>随后将各微服务注册到Nacos</p><ol><li><p>在xuecheng-plus-parent中添加依赖管理</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud-alibaba.version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud-alibaba.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在xuecheng-content-api、xuecheng-plus-system中添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置nacos地址</p><ul><li><p>在content-service的application.yml中配置如下信息</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-service</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">dev</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br></pre></td></tr></table></figure></li><li><p>在system-service的application.yml中配置如下信息</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">system-service</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">dev</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>重启这两个服务，进入Nacos中查看服务列表<br><img src="/adanpro/adanblog/./../pic/202306160038429.png" alt="img"></p></li></ol></li></ul><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><h4 id="配置三要素"><a href="#配置三要素" class="headerlink" title="配置三要素"></a>配置三要素</h4><ul><li><p>搭建完Nacos服务发现中心，现在我们来搭建Nacos配置中心，其目的就是通过Nacos去管理项目中的所有配置</p></li><li><p>那么先将项目中的配置文件进行分类</p><ol><li>每个项目特有的配置<ul><li>是指该配置只有在某些项目中需要配置，或者该配置在每个项目中配置的值不同</li><li>例如spring.application.name</li></ul></li><li>项目所公用的配置<ul><li>是指一些在若干项目中配置内容相同的配置，例如redis的配置，很多项目用的同一套redis服务，所以配置也一样</li></ul></li></ol></li><li><p>另外，还需要知道Nacos如何去定位一个具体的配置文件，即配置三要素</p><ul><li>namespace</li><li>group</li><li>dataid</li></ul></li><li><p>通过namespace、group找到具体的环境和具体的项目</p></li><li><p>通过dataid找到具体的配置文件，dataid由三部分组成</p><ul><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-service-dev.yml</span><br></pre></td></tr></table></figure><p>，由</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-service</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yml</span><br></pre></td></tr></table></figure><p>三部分组成</p><ul><li><code>content-service</code>：它是在application.yml中配置的应用名，即<code>spring.application.name</code>的值</li><li><code>dev</code>：它是环境名，由spring.profile.active指定</li><li><code>yml</code>：它是配置文件的后缀</li></ul></li></ul></li><li><p>所以，如果我们要配置content-service工程的配置文件</p><ul><li>在开发环境中配置content-service-dev.yml</li><li>在生产环境中配置content-service-prod.yml</li><li>在测试环境中配置content-service-test.yml</li></ul></li></ul><h4 id="配置content-service"><a href="#配置content-service" class="headerlink" title="配置content-service"></a>配置content-service</h4><ul><li><p>下面以配置content-service为例，在开发环境下添加<code>content-service-dev.yaml</code>配置<br><img src="/adanpro/adanblog/./../pic/202306160043410.png" alt="img"></p></li><li><p>为什么不在nacos中配置如下内容？</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-service</span></span><br></pre></td></tr></table></figure></li><li><p>因为Nacos是先根据spring.cloud.nacos.server-addr获取Nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p></li><li><p>而读取配置文件的顺序如下</p><ol><li>bootstrap.yml</li><li>nacos中的配置文件</li><li>本地application.yml</li></ol></li><li><p>所以我们要先在bootstrap.yml中配置文件id，然后nacos才知道怎么读取配置文件。</p></li><li><p>那么我们现在在content-service下创建bootstrap.yml</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-service</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>删除原本的application.yml，在content-service工程中添加依赖</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>随后运行测试方法，看看能否正产读取数据库的配置信息，并读取数据</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">@Test</span></span><br><span class="line"><span class="attr">void</span> <span class="string">contextQueryCourseTest() &#123;</span></span><br><span class="line">    <span class="attr">PageResult&lt;CourseBase&gt;</span> <span class="string">result = courseBaseInfoService.queryCourseBaseList(new PageParams(1L, 10L), new QueryCourseParamDto());</span></span><br><span class="line">    <span class="attr">log.info(&quot;查询到数据：&#123;&#125;&quot;,</span> <span class="string">result);</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="配置content-api"><a href="#配置content-api" class="headerlink" title="配置content-api"></a>配置content-api</h4><ul><li><p>以相同的方法配置content-api，在nacos的开发环境下新建配置<code>content-api-dev.yaml</code></p><ul><li><p>application.yml</p></li><li><p>content-api-dev.yaml</p></li><li><p>我们先来看看哪些配置可以交给Nacos管理</p><ul><li><p>原本content-api的配置如下，除了服务名，都可以交给</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-api-dev.yaml</span><br></pre></td></tr></table></figure><p>管理</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">servlet</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">context-path</span>: <span class="string">/content</span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">53040</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-api</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"># 日志文件配置路径</span></span><br><span class="line"><span class="attr">logging</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">config</span>: <span class="string">classpath:log4j2-dev.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># swagger 文档配置</span></span><br><span class="line"><span class="attr">swagger</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;学成在线内容管理系统&quot;</span></span><br><span class="line">  <span class="attr">description</span>: <span class="string">&quot;内容系统管理系统对课程相关信息进行业务管理数据&quot;</span></span><br><span class="line">  <span class="attr">base-package</span>: <span class="string">com.xuecheng.content</span></span><br><span class="line">  <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">version</span>: <span class="string">1.0.0</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>那么我们现在就需要配置<code>content-api</code>的<code>bootstrap.yml</code></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#微服务配置</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">content-api</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">extension-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: content-service-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：因为content-api接口工程依赖了content-service工程的jar，而content-service的配置也交由nacos管理了（主要是数据库配置），所以我们现在需要extension-configs扩展配置文件的方式引用service工程的配置文件</p></li><li><p>如果需要添加多个扩展文件，继续在下面添加即可</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">extension-configs</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">-</span> <span class="string">data-id: content-service-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">    <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">    <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">    <span class="attr">-</span> <span class="string">data-id: 填写文件 dataid</span></span><br><span class="line">    <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">    <span class="attr">refresh</span>: <span class="string">true           </span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="公用配置"><a href="#公用配置" class="headerlink" title="公用配置"></a>公用配置</h3><ul><li><p>nacos还提供了shared-configs，可以引用公用配置</p></li><li><p>我们之前在content-api中配置了swagger，并且所有接口工程都需要配置swagger</p></li><li><p>那么我们这里就可以将swagger的配置定义为一个公用配置，哪个项目需要，哪个项目就引用</p></li><li><p>接下来，我们就着手创建xuecheng-plus的公用配置，进入nacos的开发环境，添加<code>swagger-dev.yaml</code>公用配置，这里的group可以设置为<code>xuecheng-plus-common</code>，该组下的内容都作为<code>xuecheng-plus</code>的公用配置<br><img src="/adanpro/adanblog/./../pic/202306160044405.png" alt="img"></p></li><li><p>删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-api-dev.yaml</span><br></pre></td></tr></table></figure><p>中的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swagger</span><br></pre></td></tr></table></figure><p>配置，在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-api</span><br></pre></td></tr></table></figure><p>的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootstrap.yml</span><br></pre></td></tr></table></figure><p>中使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared-config</span><br></pre></td></tr></table></figure><p>添加公用配置</p><ul><li>content-api-dev.yaml</li><li>bootstrap.yml</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line">  <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">servlet</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">context-path</span>: <span class="string">/content</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">53040</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  # 日志文件配置路径</span></span><br><span class="line">  <span class="attr">logging</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>: <span class="string">classpath:log4j2-dev.xml</span></span><br><span class="line"><span class="comment">  # swagger 文档配置</span></span><br><span class="line"><span class="attr">-</span> <span class="string">swagger:</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">title: &quot;学成在线内容管理系统&quot;</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">description: &quot;内容系统管理系统对课程相关信息进行业务管理数据&quot;</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">base-package: com.xuecheng.content</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">enabled: true</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">version: 1.0.0</span></span><br></pre></td></tr></table></figure></li><li><p>再以相同的方法配置日志的公用配置<br><img src="/adanpro/adanblog/./../pic/202306160044856.png" alt="img"></p></li><li><p>删除</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">content-api-dev.yaml</span></span><br></pre></td></tr></table></figure><p>中的</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging</span></span><br></pre></td></tr></table></figure><p>配置，在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-api</span><br></pre></td></tr></table></figure><p>的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootstrap.yml</span><br></pre></td></tr></table></figure><p>中使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared-config</span><br></pre></td></tr></table></figure><p>添加公用配置</p><ul><li>content-api-dev.yaml</li><li>bootstrap.yml</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line">  <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">servlet</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">context-path</span>: <span class="string">/content</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">53040</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">-</span> <span class="string"># 日志文件配置路径</span></span><br><span class="line"><span class="attr">-</span> <span class="string">logging:</span></span><br><span class="line"><span class="attr">-</span>   <span class="string">config: classpath:log4j2-dev.xml</span></span><br></pre></td></tr></table></figure></li><li><p>那么到此为止，配置完成，重启content-api，访问swagger页面，查看swagger接口文档是否可以正常显示，查看控制台log4j2日志是否正常输出</p></li></ul><h3 id="系统管理配置"><a href="#系统管理配置" class="headerlink" title="系统管理配置"></a>系统管理配置</h3><ul><li><p>按照上面的方法，将系统管理服务的配置信息在nacos上进行配置</p></li><li><p>在开发环境下添加<code>system-service-dev.yaml</code>配置<br><img src="/adanpro/adanblog/./../pic/202306160044240.png" alt="img"></p></li><li><p>在system-service下创建bootstrap.yml配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">system-service</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">shared-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: logging-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>在开发环境下添加<code>system-api-dev.yaml</code>配置<br><img src="/adanpro/adanblog/./../pic/202306160038047.png" alt="img"></p></li><li><p>在system-api下创建bootstrap.yml配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#微服务配置</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">system-api</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">extension-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: system-service-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">shared-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: swagger-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: logging-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><ul><li><p>到目前位置，已经将所有微服务的配置统一在nacos进行配置，用到的配置文件有本地的bootstrap.yaml和nacos上的配置文件</p></li><li><p>引入配置文件的形式有</p><ol><li>通过dataid方式引入</li><li>以扩展配置文件方式引入</li><li>以公用配置文件方式引入</li></ol></li><li><p>各配置文件的优先级：项目应用名配置文件(content-api-dev.yaml) &gt; 扩展配置文件(content-service-dev.html) &gt; 共享配置文件(swagger-dev.yaml) &gt; 本地配置文件(application.yml)</p></li><li><p>有时候我们在测试程序时，直接在本地加一个配置进行测试，这时候我们想让本地配置优先级最高，那么可以在nacos配置文件中配置如下内容</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>: <span class="string"></span></span><br><span class="line">      <span class="attr">override-none</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="搭建Gateway"><a href="#搭建Gateway" class="headerlink" title="搭建Gateway"></a>搭建Gateway</h2><ul><li><p>本项目使用SpringCloudGateway作为网关，下面创建网关工程<br><img src="/adanpro/adanblog/./../pic/202306160038397.png" alt="img"></p></li><li><p>指定父工程，添加依赖</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;?xml</span> <span class="string">version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="attr">&lt;project</span> <span class="string">xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         <span class="attr">xsi</span>:<span class="string">schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span><br><span class="line">    <span class="attr">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span><br><span class="line">    <span class="attr">&lt;!--指定父工程为xuecheng-plus-parent--&gt;</span></span><br><span class="line">    <span class="attr">&lt;parent&gt;</span></span><br><span class="line">        <span class="attr">&lt;groupId&gt;com.xuecheng&lt;/groupId&gt;</span></span><br><span class="line">        <span class="attr">&lt;artifactId&gt;xuecheng-plus-parent&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line">        <span class="attr">&lt;relativePath&gt;../xuecheng-plus-parent&lt;/relativePath&gt;</span></span><br><span class="line">    <span class="attr">&lt;/parent&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;xuecheng-plus-gateway&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="attr">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line">    <span class="attr">&lt;name&gt;xuecheng-plus-gateway&lt;/name&gt;</span></span><br><span class="line">    <span class="attr">&lt;description&gt;xuecheng-plus-gateway&lt;/description&gt;</span></span><br><span class="line">    <span class="attr">&lt;properties&gt;</span></span><br><span class="line">        <span class="attr">&lt;java.version&gt;1.8&lt;/java.version&gt;</span></span><br><span class="line">    <span class="attr">&lt;/properties&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;dependencies&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--服务发现中心--&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&lt;!--</span> <span class="string">排除 Spring Boot 依赖的日志包冲突 --&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="attr">&lt;exclusions&gt;</span></span><br><span class="line">                <span class="attr">&lt;exclusion&gt;</span></span><br><span class="line">                    <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">                    <span class="attr">&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span></span><br><span class="line">                <span class="attr">&lt;/exclusion&gt;</span></span><br><span class="line">            <span class="attr">&lt;/exclusions&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--</span> <span class="string">Spring Boot 集成 log4j2 --&gt;</span></span><br><span class="line">        <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;/dependencies&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&lt;/project&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置网关的bootstrap.yml配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#微服务配置</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">$&#123;spring.profiles.active&#125;</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">shared-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: logging-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>在nacos的开发环境下创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gateway-dev.yaml</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">53010 # 网关端口</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">gateway</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">routes</span>: <span class="string"></span></span><br><span class="line">        <span class="attr">-</span> <span class="string">id: content-api # 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">lb://content-api # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates</span>: <span class="string"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="attr">-</span> <span class="string">Path=/content/** # 这个是按照路径匹配，只要以/content/开头就符合要求</span></span><br><span class="line">        <span class="attr">-</span> <span class="string">id: system-api</span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">lb://system-api</span></span><br><span class="line">          <span class="attr">predicates</span>:<span class="string"></span></span><br><span class="line">            <span class="attr">-</span> <span class="string">Path=/system/**</span></span><br></pre></td></tr></table></figure></li><li><p>在http-client.env.json中配置网关的地址</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;localhost:53010&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content_host&quot;</span>: <span class="string">&quot;localhost:53040&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_host&quot;</span>: <span class="string">&quot;localhost:53110&quot;</span>,</span><br><span class="line">    <span class="string">&quot;media_host&quot;</span>: <span class="string">&quot;localhost:53050&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cache_host&quot;</span>: <span class="string">&quot;localhost:53035&quot;</span>,</span><br><span class="line">+   <span class="string">&quot;gateway_host&quot;</span>: <span class="string">&quot;localhost:53010&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用HTTP Client测试课程查询接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">### 课程查询列表</span><br><span class="line"><span class="variable constant_">POST</span> &#123;&#123;gateway_host&#125;&#125;/content/course/list?pageNo=<span class="number">1</span>&amp;pageSize=<span class="number">2</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;auditStatus&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;courseName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;publishStatus&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行，得到正常请求数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> <span class="attr">http</span>:<span class="comment">//localhost:53010/content/course/list?pageNo=1&amp;pageSize=2</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line">transfer-<span class="attr">encoding</span>: chunked</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Tue</span>, <span class="number">14</span> <span class="title class_">Feb</span> <span class="number">2023</span> <span class="number">10</span>:<span class="number">25</span>:<span class="number">35</span> <span class="variable constant_">GMT</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;items&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;companyId&quot;</span>: <span class="number">22</span>,</span><br><span class="line">      <span class="string">&quot;companyName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;JAVA8/9/10新特性讲解啊&quot;</span>,</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="搭建媒资工程"><a href="#搭建媒资工程" class="headerlink" title="搭建媒资工程"></a>搭建媒资工程</h2><ul><li><p>从课程资料中获取媒资工程xuecheng-plus-media，拷贝到项目工程根目录，修改其bootstrap中的nacos连接信息</p></li><li><p>创建媒资数据库xc_media，并导入数据库脚本</p></li><li><p>在nacos的开发环境下创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-api-dev.yaml</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-service-dev.yaml</span><br></pre></td></tr></table></figure><ul><li>media-api-dev.yaml</li><li>media-service-dev.yaml</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /media</span><br><span class="line">  port: 53050</span><br></pre></td></tr></table></figure></li></ul><h1 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h1><h2 id="什么是分布式文件系统"><a href="#什么是分布式文件系统" class="headerlink" title="什么是分布式文件系统"></a>什么是分布式文件系统</h2><ul><li><p>我们先来看看文件系统的定义</p><blockquote><p>文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件系统由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p></blockquote></li><li><p>文件系统是负责管理和存储文件和系统软件，操作系统通过文件系统提供的借口去存取文件，用户通过操作系统访问磁盘上的文件</p></li><li><p>常见的文件系统：FAT16&#x2F;FAT32、NTFS、HFS、UFS、APFS、XFS、Ext4等</p></li><li><p>现在有个问题，一些短视频平台拥有大量的视频、图片，这些视频文件、图片文件该如何存储呢？如何存储可以满足互联网上海量用户的浏览</p><ul><li>这里说的分布式文件系统就是海量用户查阅海量文件的方案</li></ul></li><li><p>我们再来看看分布式文件系统的定义</p><blockquote><p>分布式文件系统（Distributed File System，DFS）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点（可简单的理解为一台计算机）相连；或是若干不同的逻辑磁盘分区或卷标组合在一起而形成的完整的有层次的文件系统。DFS为分布在网络上任意位置的资源提供一个逻辑上的树形文件系统结构，从而使用户访问分布在网络上的共享文件更加简便。单独的 DFS共享文件夹的作用是相对于通过网络上的其他共享文件夹的访问点</p></blockquote></li><li><p>可以简单的理解为：一个计算机无法存储海量的文件，通过网络将若干计算机组织起来共同去存储海量的文件，去接收海量用户的请求，这些组织起来的计算机通过计算机网络通信<br><img src="/adanpro/adanblog/./../pic/202306160038246.png" alt="img"></p></li><li><p>这样做的好处</p><ol><li>一台计算机的文件系统处理能力扩充到多台计算机同时处理</li><li>一台计算机挂了， 还有另外副本计算机提供数据</li><li>每台计算机可以放在不同的地域，这样用户就可以就近访问，提高访问速度</li></ol></li><li><p>市面上有哪些分布式文件系统的产品呢？</p><ol><li><p>NFS（Linux里讲过）</p><blockquote><p>NFS是基于UDP&#x2F;IP协议的应用，其实现主要是采用远程过程调用RPC机制，RPC提供了一组与机器、操作系统以及低层传送协议无关的存取远程文件的操作。RPC采用了XDR的支持。XDR是一种与机器无关的数据描述编码的协议，他以独立与任意机器体系结构的格式对网上传送的数据进行编码和解码，支持在异构系统之间数据的传送。</p><ul><li>特点<ul><li>在客户端上映射NFS服务器的驱动器</li><li>客户端通过万国访问NFS服务器的硬盘完全透明</li></ul></li></ul></blockquote></li><li><p>GFS</p><blockquote><p>GFS是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，并提供容错功能。它可以给大量的用户提供总体性能较高的服务。<br><img src="/adanpro/adanblog/./../pic/202306160038639.png" alt="img"></p><ul><li>GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成</li><li>master存储了数据文件的元数据，一个文件被分成了若干块存储在多个chunkserver中</li><li>用户从master中获取数据元信息，向chunkserver存储数据</li></ul></blockquote></li><li><p>HDFS</p><blockquote><p>Hadoop分布式文件系统(HDFS)是指被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统（Distributed File System）。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS放宽了一部分POSIX约束，来实现流式读取文件系统数据的目的。HDFS在最开始是作为Apache Nutch搜索引擎项目的基础架构而开发的。HDFS是Apache Hadoop Core项目的一部分。<br>HDFS有着高容错性（fault-tolerant）的特点，并且设计用来部署在低廉的（low-cost）硬件上。而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求（requirements）这样可以实现流的形式访问（streaming access）文件系统中的数据。<br><img src="/adanpro/adanblog/./../pic/202306160045795.png" alt="img"></p><ul><li>HDFS采用主从结构，一个HDFS集群由一个名称节点和若干数据节点组成</li><li>名称节点存储数据的元信息，一个完整的数据文件分成若干块存储在数据节点</li><li>客户端从名称节点获取数据的元信息及数据分块的信息，得到信息客户端即可从数据块来存储数据</li></ul></blockquote></li><li><p>云计算厂家</p><ul><li>阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。其数据设计持久性不低于 99.9999999999%（12 个 9），服务设计可用性（或业务连续性）不低于 99.995%。<ul><li>官方网站：<a href="https://www.aliyun.com/product/oss">https://www.aliyun.com/product/oss</a></li></ul></li><li>百度对象存储BOS提供稳定、安全、高效、高可扩展的云存储服务。您可以将任意数量和形式的非结构化数据存入BOS，并对数据进行管理和处理。BOS支持标准、低频、冷和归档存储等多种存储类型，满足多场景的存储需求。<ul><li>官方网站：<a href="https://cloud.baidu.com/product/bos.html">https://cloud.baidu.com/product/bos.html</a></li></ul></li></ul></li></ol></li></ul><h2 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>本项目采用MinIO构建分布式文件系统，MinIO是一个非常轻量的服务，可以很简单的和其他应用结合使用。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等</p></li><li><p>它的一大特点就是轻量，使用简单、功能强大，支持各种平台，单个文件最大5TB，兼容提供了Java、Python、GO等多版本SDK支持</p></li><li><p>官网：<a href="https://min.io/%EF%BC%8C">https://min.io/，</a></p></li><li><p>中文：<a href="https://www.minio.org.cn/%EF%BC%8C">https://www.minio.org.cn/，</a> <a href="http://docs.minio.org.cn/docs/">http://docs.minio.org.cn/docs/</a></p></li><li><p>MinIO键采用去中心化共享架构，每个节点是对等关系，通过Nginx可对MinIO进行负载均衡访问</p></li><li><p>去中心化有什么好处？</p><ul><li>在大数据领域，通常的设计理念都是无中心和分布式。MinIO分布式模式可以帮助你搭建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真是物理位置</li></ul></li><li><p>它将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式MinIO避免了单点故障<br><img src="/adanpro/adanblog/./../pic/202306160038629.png" alt="img"></p></li><li><p>MinIO使用纠删码技术来保护数据，它是一种恢复丢失和损坏数据的数学算法，它将数据分块，冗余地分散存储在各个节点的磁盘上，所有可用的磁盘组成一个集合，上图由8块硬盘组成一个集合，当上传一个文件时，会通过纠删码算法计算对文件进行分块存储，除了将文件本身分成4个数据块，还会生成4个校验块，数据块和校验开会分散的存储在这8块硬盘上</p></li><li><p>使用纠删码的好处是即便丢失一半数量(N&#x2F;2)的硬盘，仍可以恢复数据。例如上面集合中有4个以内的硬盘损害，仍可保证数据恢复，不影响上传和下载；但如果多余一半的硬盘损坏，则无法恢复。</p></li><li><p>MinIO下载地址：<a href="https://dl.min.io/server/minio/release/">https://dl.min.io/server/minio/release/</a></p></li><li><p>安装完毕后，CMD进入minio.exe所在目录，执行下面的命令，会在D盘创建4个目录，模拟4个硬盘</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minio.exe server D:\develop\minio_data\data1  D:\develop\minio_data\data2  D:\develop\minio_data\data3  D:\develop\minio_data\data4</span><br></pre></td></tr></table></figure></li><li><p>启动结果如下<br><img src="/adanpro/adanblog/./../pic/202306160046236.png" alt="img"></p></li><li><p>默认账号密码均为<code>minioadmin</code>，访问<code>localhost:9000</code>进行登录</p></li><li><p>不过我们这里由于条件有限，所以先不做分布式，修改启动命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minio.exe server d:\minio_data</span><br></pre></td></tr></table></figure></li><li><p>之后创建两个buckets</p><ul><li><code>mediafiles</code>：普通文件</li><li><code>video</code>：视频文件<br><img src="/adanpro/adanblog/./../pic/202306160038678.png" alt="img"></li></ul></li></ul><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><ul><li><p>MinIO听歌多个语言版本SDK的支持，Java版本的文档地址：<a href="https://docs.min.io/docs/java-client-quickstart-guide.html">https://docs.min.io/docs/java-client-quickstart-guide.html</a></p></li><li><p>最低需求Java 1.8或更高版本</p></li><li><p>在media-service工程中添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>从官方文档中看到，需要三个参数才能连接到minio服务</p></li></ul><table><thead><tr><th align="center">Parameters</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">Endpoint</td><td align="center">URL to S3 service.</td></tr><tr><td align="center">Access Key</td><td align="center">Access key (aka user ID) of an account in the S3 service.</td></tr><tr><td align="center">Secret Key</td><td align="center">Secret key (aka password) of an account in the S3 service.</td></tr></tbody></table><ul><li><p>官方文档给出的示例代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.minio.BucketExistsArgs;</span><br><span class="line"><span class="keyword">import</span> io.minio.MakeBucketArgs;</span><br><span class="line"><span class="keyword">import</span> io.minio.MinioClient;</span><br><span class="line"><span class="keyword">import</span> io.minio.UploadObjectArgs;</span><br><span class="line"><span class="keyword">import</span> io.minio.errors.MinioException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.InvalidKeyException;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, InvalidKeyException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Create a minioClient with the MinIO server playground, its access key and secret key.</span></span><br><span class="line">      <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span></span><br><span class="line">          MinioClient.builder()</span><br><span class="line">              .endpoint(<span class="string">&quot;https://play.min.io&quot;</span>)</span><br><span class="line">              .credentials(<span class="string">&quot;Q3AM3UQ867SPQQA43P2F&quot;</span>, <span class="string">&quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;</span>)</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make &#x27;asiatrip&#x27; bucket if not exist.</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span></span><br><span class="line">          minioClient.bucketExists(BucketExistsArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="comment">// Make a new bucket called &#x27;asiatrip&#x27;.</span></span><br><span class="line">        minioClient.makeBucket(MakeBucketArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bucket &#x27;asiatrip&#x27; already exists.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Upload &#x27;/home/user/Photos/asiaphotos.zip&#x27; as object name &#x27;asiaphotos-2015.zip&#x27; to bucket</span></span><br><span class="line">      <span class="comment">// &#x27;asiatrip&#x27;.</span></span><br><span class="line">      minioClient.uploadObject(</span><br><span class="line">          UploadObjectArgs.builder()</span><br><span class="line">              .bucket(<span class="string">&quot;asiatrip&quot;</span>)</span><br><span class="line">              .object(<span class="string">&quot;asiaphotos-2015.zip&quot;</span>)</span><br><span class="line">              .filename(<span class="string">&quot;/home/user/Photos/asiaphotos.zip&quot;</span>)</span><br><span class="line">              .build());</span><br><span class="line">      System.out.println(</span><br><span class="line">          <span class="string">&quot;&#x27;/home/user/Photos/asiaphotos.zip&#x27; is successfully uploaded as &quot;</span></span><br><span class="line">              + <span class="string">&quot;object &#x27;asiaphotos-2015.zip&#x27; to bucket &#x27;asiatrip&#x27;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MinioException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Error occurred: &quot;</span> + e);</span><br><span class="line">      System.out.println(<span class="string">&quot;HTTP trace: &quot;</span> + e.httpTrace());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>那么我们在其基础上进行修改，完成基本的上传、下载和删除功能</p><ul><li><p>分析</p></li><li><p>修改</p></li><li><p>我们先来分析一下示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, InvalidKeyException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Create a minioClient with the MinIO server playground, its access key and secret key.</span></span><br><span class="line">      <span class="comment">// 创建MinIO客户端，连接参数就是上述表格中的三个参数，127.0.0.1:9000、minioadmin、minioadmin</span></span><br><span class="line">      <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span></span><br><span class="line">          MinioClient.builder()</span><br><span class="line">              .endpoint(<span class="string">&quot;https://play.min.io&quot;</span>)</span><br><span class="line">              .credentials(<span class="string">&quot;Q3AM3UQ867SPQQA43P2F&quot;</span>, <span class="string">&quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;</span>)</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make &#x27;asiatrip&#x27; bucket if not exist.</span></span><br><span class="line">      <span class="comment">// 由于backet我们已经手动创建了，所以这段代码可以删掉</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span></span><br><span class="line">          minioClient.bucketExists(BucketExistsArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="comment">// Make a new bucket called &#x27;asiatrip&#x27;.</span></span><br><span class="line">        minioClient.makeBucket(MakeBucketArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bucket &#x27;asiatrip&#x27; already exists.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Upload &#x27;/home/user/Photos/asiaphotos.zip&#x27; as object name &#x27;asiaphotos-2015.zip&#x27; to bucket</span></span><br><span class="line">      <span class="comment">// &#x27;asiatrip&#x27;.</span></span><br><span class="line">      <span class="comment">// 将 &#x27;/home/user/Photos/asiaphotos.zip&#x27; 文件命名为 &#x27;asiaphotos-2015.zip&#x27;</span></span><br><span class="line">      <span class="comment">// 并上传到 &#x27;asiatrip&#x27; 里（示例代码创建的bucket）</span></span><br><span class="line">      minioClient.uploadObject(</span><br><span class="line">          UploadObjectArgs.builder()</span><br><span class="line">              .bucket(<span class="string">&quot;asiatrip&quot;</span>)</span><br><span class="line">              .object(<span class="string">&quot;asiaphotos-2015.zip&quot;</span>)</span><br><span class="line">              .filename(<span class="string">&quot;/home/user/Photos/asiaphotos.zip&quot;</span>)</span><br><span class="line">              .build());</span><br><span class="line">      <span class="comment">// 这段输出也没有用，可以直接删掉</span></span><br><span class="line">      System.out.println(</span><br><span class="line">          <span class="string">&quot;&#x27;/home/user/Photos/asiaphotos.zip&#x27; is successfully uploaded as &quot;</span></span><br><span class="line">              + <span class="string">&quot;object &#x27;asiaphotos-2015.zip&#x27; to bucket &#x27;asiatrip&#x27;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MinioException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Error occurred: &quot;</span> + e);</span><br><span class="line">      System.out.println(<span class="string">&quot;HTTP trace: &quot;</span> + e.httpTrace());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>上传文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">package</span> com.xuecheng.media;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试MinIO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span></span><br><span class="line">            MinioClient.builder()</span><br><span class="line">                    .endpoint(<span class="string">&quot;http://192.168.101.65:9000&quot;</span>)</span><br><span class="line">                    .credentials(<span class="string">&quot;minioadmin&quot;</span>, <span class="string">&quot;minioadmin&quot;</span>)    <span class="comment">//accessKey和secretKey</span></span><br><span class="line">                    .build();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//上传文件</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">upload</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">UploadObjectArgs</span> <span class="variable">testbucket</span> <span class="operator">=</span> UploadObjectArgs.builder()</span><br><span class="line">                    .bucket(<span class="string">&quot;testbucket&quot;</span>)<span class="comment">//桶名</span></span><br><span class="line"><span class="comment">//                    .object(&quot;test001.mp4&quot;)</span></span><br><span class="line">                    .object(<span class="string">&quot;test/001/1.mp4&quot;</span>)<span class="comment">//对象，上传后的文件名</span></span><br><span class="line">                    .filename(<span class="string">&quot;D:\\develop\\upload\\1.mp4&quot;</span>)    <span class="comment">//待上传的本地文件路径</span></span><br><span class="line">                    .contentType(<span class="string">&quot;video/mp4&quot;</span>)<span class="comment">//默认根据扩展名确定文件内容类型，也可以指定</span></span><br><span class="line">                    .build();</span><br><span class="line">            minioClient.uploadObject(testbucket);</span><br><span class="line">            System.out.println(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>由于我们已经将桶的权限修改为了public，所以我们直接访问<a href="http://127.0.0.1:9000/testbucket/pic01.png%EF%BC%8C">http://127.0.0.1:9000/testbucket/pic01.png，</a> 也是可以直接看到上传的图片的</p><p><strong>启动测试</strong> </p><p><strong>执行upload方法</strong>，分别测试向桶的根目录上传文件以及子目录上传文件。</p><p>上传成功，通过web控制台刷新查看文件，并预览文件。</p><p><strong>说明：</strong></p><p><strong>设置contentType</strong>可以通过com.j256.simplemagic.ContentType枚举类查看常用的mimeType<strong>（媒体类型）</strong></p><p><img src="/adanpro/adanblog/./../pic/e2665347120d4bf1a4eb2346b4f2469d.png" alt="img"></p><p> <strong>通过扩展名（如.mp4）得到媒体类型mimeType：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">//根据扩展名取出mimeType</span></span><br><span class="line"><span class="type">ContentInfo</span> <span class="variable">extensionMatch</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(<span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> MediaType.APPLICATION_OCTET_STREAM_VALUE;<span class="comment">//通用mimeType，字节流</span></span><br></pre></td></tr></table></figure><p>通过扩展名得到媒体类型mimeType，完善上边的代码 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">upload</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//根据扩展名取出mimeType</span></span><br><span class="line">        <span class="type">ContentInfo</span> <span class="variable">extensionMatch</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(<span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> MediaType.APPLICATION_OCTET_STREAM_VALUE;<span class="comment">//通用mimeType，字节流</span></span><br><span class="line">        <span class="keyword">if</span>(extensionMatch!=<span class="literal">null</span>)&#123;</span><br><span class="line">            mimeType = extensionMatch.getMimeType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">UploadObjectArgs</span> <span class="variable">testbucket</span> <span class="operator">=</span> UploadObjectArgs.builder()</span><br><span class="line">                    .bucket(<span class="string">&quot;testbucket&quot;</span>)</span><br><span class="line"><span class="comment">//                    .object(&quot;test001.mp4&quot;)</span></span><br><span class="line">                    .object(<span class="string">&quot;001/test001.mp4&quot;</span>)<span class="comment">//添加子目录</span></span><br><span class="line">                    .filename(<span class="string">&quot;D:\\develop\\upload\\1mp4.temp&quot;</span>)</span><br><span class="line">                    .contentType(mimeType)<span class="comment">//默认根据扩展名确定文件内容类型，也可以指定</span></span><br><span class="line">                    .build();</span><br><span class="line">            minioClient.uploadObject(testbucket);</span><br><span class="line">            System.out.println(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><ul><li><p>编写测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        minioClient.removeObject(RemoveObjectArgs</span><br><span class="line">                .builder()</span><br><span class="line">                .bucket(<span class="string">&quot;testbucket&quot;</span>)</span><br><span class="line">                .object(<span class="string">&quot;pic01.png&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="查询文件"><a href="#查询文件" class="headerlink" title="查询文件"></a>查询文件</h4><ul><li><p>编写测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFileTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;testbucket&quot;</span>)</span><br><span class="line">                .object(<span class="string">&quot;pic01.png&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\15863\\Desktop\\tmp.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;下载成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下载失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用IOUtils简化代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFileTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;testbucket&quot;</span>)</span><br><span class="line">                .object(<span class="string">&quot;pic01.png&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\15863\\Desktop\\tmp.png&quot;</span>);</span><br><span class="line">        IOUtils.copy(inputStream,fileOutputStream);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下载失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>校验文件的完整性：</strong></p><p>对文件计算出md5值，比较原始文件的md5和目标文件的md5，一致则说明完整</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//校验文件的完整性对文件的内容进行md5</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\develop\\upload\\1.mp4&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">source_md5</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream1);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\develop\\upload\\1a.mp4&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">local_md5</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line"><span class="keyword">if</span>(source_md5.equals(local_md5))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;下载成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="上传图片-1"><a href="#上传图片-1" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="业务流程-1"><a href="#业务流程-1" class="headerlink" title="业务流程"></a>业务流程</h3><ul><li>我们在新增课程的时候，需要上传课程图片</li><li>课程图片上传至分布式文件系统，在课程信息中保存课程图片路径，流程如下</li></ul><ol><li>前端进入上传图片界面</li><li>上传图片，请求媒资管理服务</li><li>媒资管理服务将图片文件存储在MinIO</li><li>媒资管理记录文件信息到数据库</li><li>保存课程信息，在内容管理数据库保存图片地址</li></ol><p><img src="/adanpro/adanblog/./../pic/202306160038643.png" alt="img"></p><ul><li>媒资管理服务由接口层和业务层共同完成，具体分工如下<ul><li>用户上传图片请求至媒资管理的接口层，接口层解析文件信息，通过业务层将文件保存至minio和数据库</li></ul></li></ul><h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><ul><li>涉及到的数据表主要是媒资信息<br><img src="/adanpro/adanblog/./../pic/pSHc4bR.png" alt="img"></li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li><p>在minio中配置bucket，创建一个名为mediafiles的bucket，并将其权限设置为public</p></li><li><p>在nacos中配置minio的相关信息，在nacos的开发环境下新增配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-service-dev.yaml</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//127.0.0.1:3306/xc_media?serverTimezone=UTC&amp;userUnicode=true&amp;useSSL=false</span></span><br><span class="line">    username: root</span><br><span class="line">    password: A10ne,tillde<span class="meta">@th</span>.</span><br><span class="line">  cloud:</span><br><span class="line">   config:</span><br><span class="line">    override-none: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">minio:</span><br><span class="line">  endpoint: http:<span class="comment">//127.0.0.1:9000</span></span><br><span class="line">  accessKey: minioadmin</span><br><span class="line">  secretKey: minioadmin</span><br><span class="line">  bucket:</span><br><span class="line">    files: mediafiles</span><br><span class="line">    videofiles: video</span><br></pre></td></tr></table></figure></li><li><p>在media-service工程下配置bootstrap.yml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: media-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8848</span></span><br><span class="line">      discovery:</span><br><span class="line">        namespace: $&#123;spring.profiles.active&#125;</span><br><span class="line">        group: xuecheng-plus-project</span><br><span class="line">      config:</span><br><span class="line">        namespace: $&#123;spring.profiles.active&#125;</span><br><span class="line">        group: xuecheng-plus-project</span><br><span class="line">        file-extension: yaml</span><br><span class="line">        refresh-enabled: <span class="literal">true</span></span><br><span class="line">      shared-configs:</span><br><span class="line">        - data-id: logging-$&#123;spring.profiles.active&#125;.yaml</span><br><span class="line">          group: xuecheng-plus-common</span><br><span class="line">          refresh: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">#profiles默认为dev</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure></li><li><p>在media-service工程下编写minio的配置类</p><ul><li><p>该配置类中药根据yaml中的minio配置信息，创建一个MinioClient对象，并声明为bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.accessKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.secretKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MinioClient <span class="title function_">minioClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MinioClient.builder().</span><br><span class="line">                endpoint(endpoint).</span><br><span class="line">                credentials(accessKey, secretKey).</span><br><span class="line">                build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><ul><li><p>根据需求分析，下面进行接口定义。</p></li><li><p>此接口定义为一个通用的上传文件的接口，可以上传图片或其他文件</p></li><li><p>首先分析接口</p><ul><li><p>请求地址：&#x2F;media&#x2F;upload&#x2F;coursefile</p></li><li><p>请求参数：Content-Type: multipart&#x2F;form-data;boundary&#x3D;….. FormData: filedata&#x3D;??, folder&#x3D;?, objectName&#x3D;?</p></li><li><p>响应参数：文件信息，如下，其内容与media_files表中的字段完全一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>: <span class="string">&quot;a16da7a132559daf9e1193166b3e7f52&quot;</span>,</span><br><span class="line"><span class="string">&quot;companyId&quot;</span>: <span class="number">1232141425</span>,</span><br><span class="line"><span class="string">&quot;companyName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;filename&quot;</span>: <span class="string">&quot;1.jpg&quot;</span>,</span><br><span class="line"><span class="string">&quot;fileType&quot;</span>: <span class="string">&quot;001001&quot;</span>,</span><br><span class="line"><span class="string">&quot;tags&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;bucket&quot;</span>: <span class="string">&quot;/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg&quot;</span>,</span><br><span class="line"><span class="string">&quot;fileId&quot;</span>: <span class="string">&quot;a16da7a132559daf9e1193166b3e7f52&quot;</span>,</span><br><span class="line"><span class="string">&quot;url&quot;</span>: <span class="string">&quot;/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg&quot;</span>,</span><br><span class="line"><span class="string">&quot;timelength&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;createDate&quot;</span>: <span class="string">&quot;2022-09-12T21:57:18&quot;</span>,</span><br><span class="line"><span class="string">&quot;changeDate&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;status&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="string">&quot;remark&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;auditStatus&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;auditMind&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="string">&quot;fileSize&quot;</span>: <span class="number">248329</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义模型类，虽然响应结果与MediaFiles表中的字段完全一致，但最好不要直接用MediaFiles类。因为该类属于PO类，如果后期我们要对响应结果进行修改，那么模型类也需要进行修改，但是MediaFiles是PO类，我们不能动。所以可以直接用一个类继承MediaFiles，里面什么属性都不用加</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadFileResultDto</span> <span class="keyword">extends</span> <span class="title class_">MediaFiles</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义接口，其中folder和objectName这两个参数不一定传，所以将其required设为false</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;上传文件&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/upload/coursefile&quot;,consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> UploadFileResultDto <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile upload,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;folder&quot;, required = false)</span> String folder,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;objectName&quot;, required = false)</span> String objectName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口开发"><a href="#接口开发" class="headerlink" title="接口开发"></a>接口开发</h2><h3 id="DAO开发"><a href="#DAO开发" class="headerlink" title="DAO开发"></a>DAO开发</h3><ul><li>根据需求分析，DAO层实现向media_file表中插入一条记录，使用media_files表生成的mapper即可</li></ul><h3 id="Service开发"><a href="#Service开发" class="headerlink" title="Service开发"></a>Service开发</h3><ul><li><p>Service方法需要听歌一个更加通用的保存文件的方法</p></li><li><p>定义请求参数类，上传文件，我们需要文件名称、文件的content-type、文件类型（文档、视频、图片等，对应数据字典表中的类型）、文件大小、标签、上传人、备注</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Data</span></span><br><span class="line"> <span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadFileParamsDto</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件名称</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件content-type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> String contentType;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件类型（文档，图片，视频）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String fileType;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> Long fileSize;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 标签</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String tags;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 上传人</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 备注</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String remark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义service方法，MultipartFile是SpringMVC提供简化上传操作的工具类，不使用框架之前，都是使用原生的HttpServletRequest来接收上传的数据,文件是以二进制流传递到后端的。为了使接口更通用，我们可以用字节数组代替MultpartFile类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 上传文件的通用接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uploadFileParamsDto 文件信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes               文件字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> folder              桶下边的子目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.xuecheng.media.model.dto.UploadFileResultDto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UploadFileResultDto <span class="title function_">uploadFile</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, <span class="type">byte</span>[] bytes, String folder, String objectName)</span>;</span><br></pre></td></tr></table></figure></li><li><p>实现方法如下，主要分为两部分</p><ol><li>将文件上传到minio</li><li>将文件信息写入media_file表中</li></ol></li><li><p>完整方法</p></li><li><p>将文件上传到minio</p></li><li><p>前面我们上传文件是用的uploadObject方法，是从本地磁盘上传文件，为了使方法更通用，这里使用putObject</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">putObject和uploadObject方法都是上传文件至云存储的方法，但是有些许差别。</span><br><span class="line"></span><br><span class="line">putObject方法是直接把文件上传至云存储，具体操作为：</span><br><span class="line"></span><br><span class="line">1. 打开待存储文件；</span><br><span class="line">2. 建立连接；</span><br><span class="line">3. 上传文件；</span><br><span class="line">4. 关闭连接。</span><br><span class="line"></span><br><span class="line">putObject方法适合上传小文件，上传速度快，但如果要上传大文件，该方法会消耗较多的系统资源，可能会导致系统卡顿或崩溃。</span><br><span class="line"></span><br><span class="line">uploadObject方法是把文件拆成多个固定大小的分片进行上传，具体操作为：</span><br><span class="line"></span><br><span class="line">1. 打开待存储文件；</span><br><span class="line">2. 建立连接；</span><br><span class="line">3. 计算文件大小，将文件分成多个固定大小的分片；</span><br><span class="line">4. 依次上传每个分片，可同时上传多个分片，提高上传效率；</span><br><span class="line">5. 合并多个分片，形成完整的文件；</span><br><span class="line">6. 关闭连接。</span><br><span class="line"></span><br><span class="line">uploadObject方法适合上传大文件，可分片上传，上传速度较快，且可控制上传进度和暂停继续上传。但是该方法会增加代码复杂度，需要开发者自行处理分片上传和合并分片的逻辑。</span><br><span class="line"></span><br><span class="line">总的来说，如果要上传小文件，建议使用putObject方法进行上传；如果要上传大文件，建议使用uploadObject方法，提高上传效率。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MediaFilesMapper mediaFilesMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MinioClient minioClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;minio.bucket.files&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String bucket_files;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uploadFileParamsDto 文件信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes               文件字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> folder              桶下边的子目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> UploadFileResultDto <span class="title function_">uploadFile</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, <span class="type">byte</span>[] bytes, String folder, String objectName)</span> &#123;</span><br><span class="line">    <span class="comment">// 上传图片文件使用putObject</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileMD5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(bytes);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(folder)) &#123;</span><br><span class="line">        <span class="comment">// 文件目录不存在，自动生成目录</span></span><br><span class="line">        folder = getFileFolder(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!folder.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果目录末尾没有 / ,则添加/</span></span><br><span class="line">        folder = folder + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断文件名</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(objectName)) &#123;</span><br><span class="line">        <span class="comment">// 如果文件名为空，则设置其默认文件名为文件的md5码 + 文件后缀名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">        objectName = fileMD5 + filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件存储地址</span></span><br><span class="line">    objectName = folder + objectName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.上传到minio</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">                .bucket(bucket_files)</span><br><span class="line">                .object(objectName)     <span class="comment">// 存储桶里的对象名称。</span></span><br><span class="line">                .stream(inputStream, inputStream.available(), -<span class="number">1</span>) <span class="comment">// 要上传的流、大小</span></span><br><span class="line">                .contentType(uploadFileParamsDto.getContentType())</span><br><span class="line">                .build();</span><br><span class="line">        minioClient.putObject(putObjectArgs);</span><br><span class="line">        <span class="comment">// 2.保持到数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(fileMD5);</span><br><span class="line">        <span class="keyword">if</span> (mediaFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            mediaFile = <span class="keyword">new</span> <span class="title class_">MediaFiles</span>();</span><br><span class="line">            BeanUtils.copyProperties(uploadFileParamsDto, mediaFile);</span><br><span class="line">            mediaFile.setId(fileMD5);</span><br><span class="line">            mediaFile.setFileId(fileMD5);</span><br><span class="line">            mediaFile.setCompanyId(companyId);</span><br><span class="line">            mediaFile.setBucket(bucket_files);</span><br><span class="line">            mediaFile.setCreateDate(LocalDateTime.now());</span><br><span class="line">            mediaFile.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            mediaFile.setFilePath(objectName);</span><br><span class="line">            mediaFile.setUrl(<span class="string">&quot;/&quot;</span> + bucket_files + <span class="string">&quot;/&quot;</span> + objectName);</span><br><span class="line">            <span class="comment">// 查阅数据字典，002003表示审核通过</span></span><br><span class="line">            mediaFile.setAuditStatus(<span class="string">&quot;002003&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> <span class="built_in">this</span>.save(mediaFile);</span><br><span class="line">        <span class="keyword">if</span> (!save) &#123;</span><br><span class="line">            XcPlusException.cast(<span class="string">&quot;保存文件信息失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UploadFileResultDto</span> <span class="variable">resultDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileResultDto</span>();</span><br><span class="line">        BeanUtils.copyProperties(mediaFile, resultDto);</span><br><span class="line">        <span class="keyword">return</span> resultDto;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;上传过程中出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动生成目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> year  是否包含年</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> month 是否包含月</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> day   是否包含日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFileFolder</span><span class="params">(<span class="type">boolean</span> year, <span class="type">boolean</span> month, <span class="type">boolean</span> day)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    String[] split = dateString.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (year) &#123;</span><br><span class="line">        stringBuffer.append(split[<span class="number">0</span>]).append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (month) &#123;</span><br><span class="line">        stringBuffer.append(split[<span class="number">1</span>]).append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (day) &#123;</span><br><span class="line">        stringBuffer.append(split[<span class="number">2</span>]).append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件默认存储目录路径 年/月/日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFileFolder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()).replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="完善Controller"><a href="#完善Controller" class="headerlink" title="完善Controller"></a>完善Controller</h3><ul><li><p>完善接口层代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;上传文件&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/upload/coursefile&quot;,consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> UploadFileResultDto <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile upload,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@RequestParam(value = &quot;folder&quot;, required = false)</span> String folder,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@RequestParam(value = &quot;objectName&quot;, required = false)</span> String objectName)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> <span class="number">1232141425L</span>;</span><br><span class="line">        <span class="comment">// 构建接受请求类</span></span><br><span class="line">        <span class="type">UploadFileParamsDto</span> <span class="variable">uploadFileParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileParamsDto</span>();</span><br><span class="line">        <span class="comment">//文件大小</span></span><br><span class="line">        uploadFileParams.setFileSize(upload.getSize());</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> upload.getContentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType.contains(<span class="string">&quot;image&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//图片</span></span><br><span class="line">            uploadFileParams.setFileType(<span class="string">&quot;001001&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他</span></span><br><span class="line">            uploadFileParams.setFileType(<span class="string">&quot;001003&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件名称</span></span><br><span class="line">        uploadFileParams.setFilename(upload.getOriginalFilename());</span><br><span class="line">        <span class="comment">//文件类型</span></span><br><span class="line">        uploadFileParams.setContentType(upload.getContentType());</span><br><span class="line">        <span class="comment">//文件字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bytes = upload.getBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            XcPlusException.cast(<span class="string">&quot;获取文件字节数组失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.uploadFile(companyId, uploadFileParams, bytes, folder, objectName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用HTTP Client测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">### 上传文件</span><br><span class="line">POST &#123;&#123;media_host&#125;&#125;/media/upload/coursefile</span><br><span class="line">Content-Type: multipart/form-data; boundary=WebAppBoundary</span><br><span class="line"></span><br><span class="line">--WebAppBoundary</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;filedata&quot;</span>; filename=<span class="string">&quot;test01.jpg&quot;</span></span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt; C:\Users\kyle\Desktop\Picture\photo\bg01.jpg</span><br><span class="line"></span><br><span class="line"># 响应结果如下</span><br><span class="line">POST http:<span class="comment">//localhost:53050/media/upload/coursefile</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> </span><br><span class="line">Content-Type: application/json</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, <span class="number">16</span> Feb <span class="number">2023</span> 09:<span class="number">57</span>:<span class="number">48</span> GMT</span><br><span class="line">Keep-Alive: timeout=<span class="number">60</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;632fb34166d91865da576032b9330ced&quot;</span>,</span><br><span class="line">  <span class="string">&quot;companyId&quot;</span>: <span class="number">1232141425</span>,</span><br><span class="line">  <span class="string">&quot;companyName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;test01.jpg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fileType&quot;</span>: <span class="string">&quot;001003&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;bucket&quot;</span>: <span class="string">&quot;mediafiles&quot;</span>,</span><br><span class="line">  <span class="string">&quot;filePath&quot;</span>: <span class="string">&quot;2023/57/16/632fb34166d91865da576032b9330ced.jpg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fileId&quot;</span>: <span class="string">&quot;632fb34166d91865da576032b9330ced&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/mediafiles/2023/57/16/632fb34166d91865da576032b9330ced.jpg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;createDate&quot;</span>: <span class="string">&quot;2023-02-16 17:57:48&quot;</span>,</span><br><span class="line">  <span class="string">&quot;changeDate&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remark&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;auditStatus&quot;</span>: <span class="string">&quot;002003&quot;</span>,</span><br><span class="line">  <span class="string">&quot;auditMind&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;fileSize&quot;</span>: <span class="number">22543</span></span><br><span class="line">&#125;</span><br><span class="line">响应文件已保存。</span><br><span class="line">&gt; <span class="number">2023</span>-<span class="number">02</span>-16T175748<span class="number">.200</span>.json</span><br></pre></td></tr></table></figure></li><li><p>在对应的bucket中也可以查看到上传的图片</p></li></ul><h3 id="Service代码优化"><a href="#Service代码优化" class="headerlink" title="Service代码优化"></a>Service代码优化</h3><ul><li><p>在上传文件的方法中包括两部分</p><ol><li>向MinIO存储文件</li><li>向数据库存储文件信息</li></ol></li><li><p>下面将这两部分抽取出来，后期可供其他Service方法调用</p></li><li><p>为了跟方便的获取content-type，我们可以添加simplemagic依赖，它提供的方法可以根据文件扩展名，得到资源的content-type</p></li><li><p>在base工程中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.j256.simplemagic&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;simplemagic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.17</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>可通过如下代码得到资源的content-type</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ContentInfo</span> <span class="variable">extensionMatch</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(扩展名);</span><br><span class="line"><span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> extensionMatch.getMimeType();</span><br></pre></td></tr></table></figure></li><li><p>IDEA中使用</p><p>Ctrl+Alt+M</p><p>可以快速重构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> UploadFileResultDto <span class="title function_">uploadFile</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, <span class="type">byte</span>[] bytes, String folder, String objectName)</span> &#123;</span><br><span class="line">    <span class="comment">// 上传图片文件使用putObject</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileMD5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(bytes);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(folder)) &#123;</span><br><span class="line">        <span class="comment">// 文件目录不存在，自动生成目录</span></span><br><span class="line">        folder = getFileFolder(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!folder.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果目录末尾没有 / ,则添加/</span></span><br><span class="line">        folder = folder + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断文件名</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(objectName)) &#123;</span><br><span class="line">        <span class="comment">// 如果文件名为空，则设置其默认文件名为文件的md5码 + 文件后缀名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">        objectName = fileMD5 + filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件存储地址</span></span><br><span class="line">    objectName = folder + objectName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.上传文件到minio</span></span><br><span class="line">        uploadFileToMinio(bytes, objectName, bucket_files);</span><br><span class="line">        <span class="comment">// 2.保持到数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> saveFileToDB(companyId, uploadFileParamsDto, objectName, fileMD5, bucket_files);</span><br><span class="line">        <span class="comment">// 3.封装返回数据</span></span><br><span class="line">        <span class="type">UploadFileResultDto</span> <span class="variable">resultDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileResultDto</span>();</span><br><span class="line">        BeanUtils.copyProperties(mediaFile, resultDto);</span><br><span class="line">        <span class="keyword">return</span> resultDto;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;上传过程中出错&quot;</span>, e.getMessage());</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;上传过程中出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>上传文件到minio方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传文件到minio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 文件字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName 存储桶里的对象名称。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket 桶对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">uploadFileToMinio</span><span class="params">(<span class="type">byte</span>[] bytes, String objectName, String bucket)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认contentType为未知二进制流</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> MediaType.APPLICATION_OCTET_STREAM_VALUE;</span><br><span class="line">    <span class="comment">// 判断对象名是否包含 .</span></span><br><span class="line">    <span class="keyword">if</span> (objectName.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 有,则划分出扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> objectName.substring(objectName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">// 根据扩展名得到contentType，如果为未知扩展名，例如 .abc之类的东西，则会返回null</span></span><br><span class="line">        <span class="type">ContentInfo</span> <span class="variable">extensionInfo</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(extension);</span><br><span class="line">        <span class="keyword">if</span> (extensionInfo!= <span class="literal">null</span>) &#123;</span><br><span class="line">            contentType = extensionInfo.getMimeType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.上传到minio</span></span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">    <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">            .bucket(bucket)</span><br><span class="line">            .object(objectName)     <span class="comment">// 存储桶里的对象名称。</span></span><br><span class="line">            .stream(inputStream, inputStream.available(), -<span class="number">1</span>) <span class="comment">// 要上传的流、大小</span></span><br><span class="line">            .contentType(contentType)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        minioClient.putObject(putObjectArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;上传到文件系统出错:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;上传到文件系统出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>保存到数据库方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p>优化后使用HTTP Client进行测试</p></li><li><p>同时，根据文件扩展名获取content-type的方法可以进一步抽取，可以在base工程中创建一个工具类，供其他微服务使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getContentType</span><span class="params">(String objectName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> MediaType.APPLICATION_OCTET_STREAM_VALUE; <span class="comment">// 默认content-type为未知二进制流</span></span><br><span class="line">    <span class="keyword">if</span> (objectName.indexOf(<span class="string">&quot;.&quot;</span>) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 判断对象名是否包含 .</span></span><br><span class="line">        <span class="comment">// 有 .  则划分出扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> objectName.substring(objectName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">// 根据扩展名得到content-type，如果为未知扩展名，例如 .abc之类的东西，则会返回null</span></span><br><span class="line">        <span class="type">ContentInfo</span> <span class="variable">extensionMatch</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(extension);</span><br><span class="line">        <span class="comment">// 如果得到了正常的content-type，则重新赋值，覆盖默认类型</span></span><br><span class="line">        <span class="keyword">if</span> (extensionMatch != <span class="literal">null</span>) &#123;</span><br><span class="line">            contentType = extensionMatch.getMimeType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contentType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Service事务优化"><a href="#Service事务优化" class="headerlink" title="Service事务优化"></a>Service事务优化</h3><ul><li><p>我们现在思考一下，updateFile方法是否应该开启事务</p></li><li><p>目前如果在updateFile方法上添加<code>@Transactional</code>，当调用updateFile方法前会开启数据库事务，如果上传文件过程时间较长（例如用户在上传超大视频文件），那么数据库的食物持续时间也会变长（因为在updateFile方法中，我们即要将文件上传到minio，又要将文件信息写入数据库），这样数据库连接释放就慢，最终导致数据库链接不够用</p></li><li><p>那么解决办法也显而易见，那就是只在<code>addMediaFilesToDB</code>方法上添加事务控制即可，同时将uploadFile方法上的<code>@Transactional</code>注解去掉</p></li><li><p>但事情并不是那么简单，首先我们来看一下Spring的事务控制</p></li><li><p>判断方法能否被事务控制</p><ol><li>是不是通过代理对象调用的方法</li><li>该方法上是否添加了<code>@Transactional</code>注解</li></ol></li><li><p>现在只满足了添加事务注解，那么如何判断是不是通过代理对象调用的方法呢？</p><ul><li>我们可以打个断点看一下</li></ul></li><li><p>当我们在一个不能被事务控制的方法里（uploadFile），调用一个被事务控制的方法（addMediaFilesToDB），那么该方法（addMediaFilesToDB）也不会被事务控制</p></li><li><p>那么如何解决呢？</p><ul><li>我们需要通过代理对象去调用addMediaFilesToDB方法</li></ul></li><li><p>在MediaFileService的实现类中注入MediaFileService的代理对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">MediaFileService currentProxy;</span><br></pre></td></tr></table></figure></li><li><p>将addMediaFilesToDB方法提取成接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将文件信息添加到文件表</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> uploadFileParamsDto 上传文件的信息</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> fileMD5             文件md5码</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> bucket              桶</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> MediaFiles <span class="title function_">addMediaFilesToDB</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket)</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过代理对象调用addMediaFilesToDB</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> currentProxy.addMediaFilesToDB(companyId, uploadFileParamsDto, objectName, fileMD5, bucket_files);</span><br></pre></td></tr></table></figure></li><li><p>再次测试事务是否可以正常控制</p><ul><li>打断点看到这次是代理对象调用的方法<br><img src="/adanpro/adanblog/./../pic/202306160038179.png" alt="img"></li></ul></li></ul><h2 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h2><ul><li><p>修改前段的图片服务器地址为自己的minio地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 图片服务器地址</span><br><span class="line">VUE_APP_SERVER_PICSERVER_URL=http://127.0.0.1:9000</span><br></pre></td></tr></table></figure></li><li><p>在新增课程、编辑课程界面上传图片，保存课程信息后再次进入编辑课程界面，查看是否可以正常保存图片信息<br><img src="/adanpro/adanblog/./../pic/202306160038599.png" alt="img"></p></li><li><p>上传图片完成后，进入媒资管理，查看文件列表中是否有刚刚上传的图片信息<br><img src="/adanpro/adanblog/./../pic/202306160038690.png" alt="img"></p></li></ul><h2 id="bug修复"><a href="#bug修复" class="headerlink" title="bug修复"></a>bug修复</h2><ul><li><p>在媒资列表可以查看到刚刚上传的图片信息，但是通过条件查询不起作用</p></li><li><p>原因：没有使用查询条件</p></li><li><p>解决：修改MediaFileServiceImpl中的queryMediaFiles方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PageResult&lt;MediaFiles&gt; <span class="title function_">queryMediaFiles</span><span class="params">(Long companyId, PageParams pageParams, QueryMediaParamsDto queryMediaParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建查询条件对象</span></span><br><span class="line">        LambdaQueryWrapper&lt;MediaFiles&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">+       queryWrapper.like(!StringUtils.isEmpty(queryMediaParamsDto.getFilename()), MediaFiles::getFilename, queryMediaParamsDto.getFilename());</span><br><span class="line">+       queryWrapper.eq(!StringUtils.isEmpty(queryMediaParamsDto.getFileType()), MediaFiles::getFileType, queryMediaParamsDto.getFileType());</span><br><span class="line">        <span class="comment">//分页对象</span></span><br><span class="line">        Page&lt;MediaFiles&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">        <span class="comment">// 查询数据内容获得结果</span></span><br><span class="line">        Page&lt;MediaFiles&gt; pageResult = mediaFilesMapper.selectPage(page, queryWrapper);</span><br><span class="line">        <span class="comment">// 获取数据列表</span></span><br><span class="line">        List&lt;MediaFiles&gt; list = pageResult.getRecords();</span><br><span class="line">        <span class="comment">// 获取数据总数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> pageResult.getTotal();</span><br><span class="line">        <span class="comment">// 构建结果集</span></span><br><span class="line">        PageResult&lt;MediaFiles&gt; mediaListResult = <span class="keyword">new</span> <span class="title class_">PageResult</span>&lt;&gt;(list, total, pageParams.getPageNo(), pageParams.getPageSize());</span><br><span class="line">        <span class="keyword">return</span> mediaListResult;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重启服务，测试是否能正常查询<br><img src="/adanpro/adanblog/./../pic/202306160038415.png" alt="img"></p></li></ul><h1 id="上传视频-1"><a href="#上传视频-1" class="headerlink" title="上传视频"></a>上传视频</h1><h2 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>教学机构人员进入媒资管理列表查询自己上传的媒资文件</li><li>教育机构人员在<code>媒资管理</code>页面中点击<code>上传视频</code>按钮，打开上传界面</li><li>选择要上传的文件，自动执行文件上传</li><li>视频上传成功会自动处理，处理完成后可以预览视频</li></ol><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><h3 id="什么是断点续传"><a href="#什么是断点续传" class="headerlink" title="什么是断点续传"></a>什么是断点续传</h3><ul><li>通常视频文件都比较大，所以对于媒资系统上传文件的需求要满足大文件的上传需求。HTTP协议本身对上传文件大小没有限制，但是客户的网络环境之类、电脑硬件环境等参差不齐，如果一个大文件快上传完了，但是突然断网了，没有上传完成，需要客户重新上传，那么用户体验就非常差。所以对于大文件上传的最基本要求就是断点续传</li><li>流程如下<ol><li>前端上传前先把文件分成块</li><li>一块一块的上传，上传中断后重新上传。已上传的分块则不用再上传</li><li>各分块上传完成后，在服务端合并文件</li></ol></li></ul><h3 id="分块与合并测试"><a href="#分块与合并测试" class="headerlink" title="分块与合并测试"></a>分块与合并测试</h3><ul><li><p>为了更好的理解文件分块上传的原理，下面用Java代码测试文件的分块与合并</p></li><li><p>文件分块的流程如下</p><ol><li>获取源文件长度</li><li>根据设定的分块文件大小，计算出块数（向上取整，例如33.4M的文件，块大小为1M，则需要34块）</li><li>从源文件读取数据，并依次向每一个块文件写数据</li></ol></li><li><p>文件分块测试代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大文件断点续传  objectUpload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bigFileUploadTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 源文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\adan\\Videos\\lb2.MP4&quot;</span>);</span><br><span class="line">    <span class="comment">// 块文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\projects\\xc-plus-font-end\\testFile\\chunk\\&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">chunkFolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(chunkPath);</span><br><span class="line">    <span class="keyword">if</span> (!chunkFolder.exists()) &#123;</span><br><span class="line">        <span class="comment">// 如果文件夹不存在，则创建文件夹</span></span><br><span class="line">        chunkFolder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置分块大小（分块文件个数。Math.ceil是向上取整）5M</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">chunkSize</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 计算块数，向上取整</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">chunkNum</span> <span class="operator">=</span> (<span class="type">long</span>) Math.ceil(sourceFile.length() * <span class="number">1.0</span> / chunkSize);</span><br><span class="line">    <span class="comment">// 缓冲区大小</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 使用RandomAccessFile访问文件</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf_read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(sourceFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历分块，依次向每一个分块写入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chunkNum; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建分块文件，默认文件名 path + i，例如chunk\1  chunk\2</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(chunkPath + i);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">        <span class="keyword">if</span> (newFile) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">raf_write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            <span class="comment">// 向分块文件写入数据，每次写满一个字节数组</span></span><br><span class="line">            <span class="keyword">while</span> ((len = raf_read.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                raf_write.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                <span class="comment">// 当分块大小超过5m时停止在这一块写数据。不加这句的话会出现第一块大小和源文件一样，其余块大小都为0</span></span><br><span class="line">                <span class="keyword">if</span> (file.length() &gt;= chunkSize)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            raf_write.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raf_read.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;写入分块完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件合并流程</p><ol><li>找到要合并的文件并按文件分块的先后顺序排序</li><li>创建合并文件</li><li>依次从合并的文件中读取数据冰箱合并文件写入数据</li></ol></li><li><p>文件合并的测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大文件合并测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bigFileMergeTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 块文件目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">chunkFolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\projects\\xc-plus-font-end\\testFile\\chunk&quot;</span>);</span><br><span class="line">    <span class="comment">// 源文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\adan\\Videos\\lb2.MP4&quot;</span>);</span><br><span class="line">    <span class="comment">// 合并后的文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">mergeFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\adan\\Videos\\lb2-1.MP4&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.取出所有分块文件</span></span><br><span class="line">    File[] files = chunkFolder.listFiles();</span><br><span class="line">    <span class="comment">//2.将数组转成list，以便于排序</span></span><br><span class="line">    List&lt;File&gt; fileList = Arrays.asList(files);</span><br><span class="line">    <span class="comment">//3.对分块文件排序</span></span><br><span class="line">    fileList.sort(Comparator.comparingInt(o -&gt; Integer.parseInt(o.getName())));</span><br><span class="line">    <span class="comment">//向合并文件写的流</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf_rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(mergeFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">//缓存区</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span> (File file : fileList) &#123;</span><br><span class="line">        <span class="comment">//读分块的流</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf_r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf_r.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf_rw.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        raf_r.close();</span><br><span class="line">    &#125;</span><br><span class="line">    raf_rw.close();</span><br><span class="line">    <span class="comment">// 判断合并后的文件是否与源文件相同</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">mergeFileStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mergeFile);</span><br><span class="line">    <span class="comment">//取出原始文件的md5</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalMd5</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line">    <span class="comment">//取出合并文件的md5进行比较</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergeFileMd5</span> <span class="operator">=</span> DigestUtils.md5Hex(mergeFileStream);</span><br><span class="line">    <span class="keyword">if</span> (originalMd5.equals(mergeFileMd5)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;合并文件成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;合并文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="上传视频流程"><a href="#上传视频流程" class="headerlink" title="上传视频流程"></a>上传视频流程</h3><p><img src="/adanpro/adanblog/./../pic/202306160038642.png" alt="img"></p><ol><li><p>前端上传文件前，请求媒资接口层检查文件是否存在</p><ul><li>若存在，则不再上传</li><li>若不存在，则开始上传，首先对视频文件进行分块</li></ul></li><li><p>前端分块进行上传，上传前首先检查分块是否已经存在</p><ul><li>若分块已存在，则不再上传</li><li>若分块不存在，则开始上传分块</li></ul></li><li><p>前端请求媒资管理接口层，请求上传分块</p></li><li><p>接口层请求服务层上传分块</p></li><li><p>服务端将分块信息上传到MinIO</p><p><strong>注意：</strong>minio文件和文件的分块存储路径都应该尽量<strong>避免存在根目录</strong>下，这里将文件名前两位设成路径。</p><p><img src="/adanpro/adanblog/./../pic/914f34cbb90b46b59ffbe7014713d2b2.png" alt="img"></p></li><li><p>前端将分块上传完毕，请求接口层合并分块</p></li><li><p>接口层请求服务层合并分块</p></li><li><p>服务层根据文件信息找到MinIO中的分块文件，下载到本地临时目录，将所有分块下载完毕后开始合并</p></li><li><p>合并完成后，将合并后的文件上传至MinIO</p></li><li><p>合并完成<strong>校验合并后的文件是否完整</strong>，如果完整则<strong>上传完成并删除分块</strong>，否则删除文件。</p></li></ol><h2 id="接口定义-1"><a href="#接口定义-1" class="headerlink" title="接口定义"></a>接口定义</h2><ul><li><p>根据上传视频流程，定义接口</p></li><li><p>与前端的约定是</p><ul><li><p>操作成功返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作失败返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在base工程的model包下新建RestResponse类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestResponse</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相应编码 0为正常 -1为错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应提示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RestResponse</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RestResponse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误信息的封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">validfail</span><span class="params">()</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">validfail</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(-<span class="number">1</span>);</span><br><span class="line">        response.setMsg(msg);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">validfail</span><span class="params">(String msg, T result)</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setCode(-<span class="number">1</span>);</span><br><span class="line">        response.setMsg(msg);</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常信息的封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T result)</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(String msg, T result)</span> &#123;</span><br><span class="line">        RestResponse&lt;T&gt; response = <span class="keyword">new</span> <span class="title class_">RestResponse</span>&lt;&gt;();</span><br><span class="line">        response.setMsg(msg);</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义接口如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;大文件上传接口&quot;, tags = &quot;大文件上传接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigFilesController</span> &#123;</span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;文件上传前检查文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/checkfile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;分块文件上传前检查分块&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/checkchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;上传分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/uploadchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, <span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;合并分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/mergechunks&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;fileName&quot;)</span> String fileName, <span class="meta">@RequestParam(&quot;chunkTotal&quot;)</span> <span class="type">int</span> chunkTotal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口开发-1"><a href="#接口开发-1" class="headerlink" title="接口开发"></a>接口开发</h2><h3 id="DAO开发-1"><a href="#DAO开发-1" class="headerlink" title="DAO开发"></a>DAO开发</h3><ul><li>向媒资数据库的文件表插入记录，使用自动生成的Mapper接口即可满足要求</li></ul><h3 id="Service开发-1"><a href="#Service开发-1" class="headerlink" title="Service开发"></a>Service开发</h3><h4 id="检查文件和分块"><a href="#检查文件和分块" class="headerlink" title="检查文件和分块"></a>检查文件和分块</h4><ul><li><p>首先实现检查文件方法和检查分块方法</p></li><li><p>定义Service接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查文件是否存在</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5 文件的md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(String fileMd5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查分块是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5       文件的MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkIndex    分块序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunkIndex)</span>;</span><br></pre></td></tr></table></figure></li><li><p>判断文件是否存在</p><ul><li><p>首先判断数据库中是否存在该文件</p></li><li><p>其次判断minio的bucket中是否存在该文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(String fileMd5)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.首先判断数据库中是否存在该文件</span></span><br><span class="line">    <span class="comment">// 查询文件信息</span></span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(fileMd5);</span><br><span class="line">    <span class="keyword">if</span> (mediaFile == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若数据库中存在，根据数据库中的文件信息，则继续判断minio中是否存在</span></span><br><span class="line">    <span class="comment">// 2.其次判断minio的bucket中是否存在该文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> mediaFile.getBucket();  <span class="comment">// 桶</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> mediaFile.getFilePath();  <span class="comment">// 存储目录</span></span><br><span class="line">    <span class="comment">// 文件流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 查询minio, 调用statObject()来判断对象是否存在。</span></span><br><span class="line">        stream = minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(filePath)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="keyword">if</span> (stream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 文件已存在</span></span><br><span class="line">            <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在, statObject()抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件不存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>判断分块是否存在</p><ul><li><p>分块是否存在，只需要判断minio对应的目录下是否存在分块文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunkIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//得到分块文件目录</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="comment">//得到分块文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> chunkFileFolderPath + chunkIndex;</span><br><span class="line">    <span class="comment">//文件流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = minioClient.getObject(</span><br><span class="line">                GetObjectArgs.builder()</span><br><span class="line">                        .bucket(bucket_videoFiles)</span><br><span class="line">                        .object(chunkFilePath)</span><br><span class="line">                        .build());</span><br><span class="line">        <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//分块已存在</span></span><br><span class="line">            <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">//分块未存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分块未存在</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//得到分块文件的目录</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getChunkFileFolderPath</span><span class="params">(String fileMd5)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fileMd5.substring(<span class="number">0</span>, <span class="number">1</span>) + <span class="string">&quot;/&quot;</span> + fileMd5.substring(<span class="number">1</span>, <span class="number">2</span>) + <span class="string">&quot;/&quot;</span> + fileMd5 + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;chunk&quot;</span> + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>优化代码</p></li><li><p>检查文件和分块文件在minio是否存在提取方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断文件在minio是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket 桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkFilePath 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存在 true； 不存在false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkMinioFile</span><span class="params">(String bucket, String chunkFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">//文件流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(chunkFilePath)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//分块已存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优化检查文件和分块文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(String fileMd5)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.首先判断数据库中是否存在该文件</span></span><br><span class="line">    <span class="comment">// 查询文件信息</span></span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(fileMd5);</span><br><span class="line">    <span class="keyword">if</span> (mediaFile == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若数据库中存在，根据数据库中的文件信息，则继续判断minio中是否存在</span></span><br><span class="line">    <span class="comment">// 2.其次判断minio的bucket中是否存在该文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> mediaFile.getBucket();  <span class="comment">// 桶</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> mediaFile.getFilePath();  <span class="comment">// 存储目录</span></span><br><span class="line">    <span class="comment">// 判断文件是否在minio存在</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> checkMinioFile(bucket, filePath);</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunkIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 分块是否存在，只需要判断minio对应的目录下是否存在分块文件</span></span><br><span class="line">    <span class="comment">// 获取得到分块文件所在目录。“abcde”-&gt;“a/b/abcde”</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="comment">// 得到分块文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> chunkFileFolderPath + chunkIndex;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> checkMinioFile(bucket_video, chunkFilePath);</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="上传分块"><a href="#上传分块" class="headerlink" title="上传分块"></a>上传分块</h4><ul><li><p>定义Service接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传分块(putObjectArgs)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5   文件MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunk     分块序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes     文件字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5,<span class="type">int</span> chunk,<span class="type">byte</span>[] bytes)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传分块(UploadObjectArgs)推荐使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5   文件MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunk     分块序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localChunkFilePath    本地文件绝对路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5,<span class="type">int</span> chunk, String localChunkFilePath)</span>;</span><br></pre></td></tr></table></figure></li><li><p>接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunk, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">    <span class="comment">// 分块文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5) + chunk;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        addMediaFilesToMinIO(bytes, video_files, chunkFilePath);</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;上传分块文件：&#123;&#125;失败：&#123;&#125;&quot;</span>, chunkFilePath, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;上传文件失败&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用UploadObjectArgs方法上传mino（<strong>推荐</strong>）</p></li><li><p>uploadChunk方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5   文件MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunk     分块序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localChunkFilePath    本地文件绝对路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(String fileMd5, <span class="type">int</span> chunk, String localChunkFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">//获取文件扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> localChunkFilePath.substring(localChunkFilePath.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取文件类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> getMimeType(extension);</span><br><span class="line">    <span class="comment">// 获取文件在minio的存储路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolderPath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="comment">// 上传文件到minio</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> uploadFileToMinio(bucket_video, mimeType, chunkFileFolderPath, localChunkFilePath);</span><br><span class="line">    <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;上传分块文件失败:&#123;&#125;&quot;</span>, chunkFileFolderPath);</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;上传分块失败&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;上传分块文件成功:&#123;&#125;&quot;</span>,chunkFileFolderPath);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uploadFileToMinio方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传分块文件到minio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket 桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mimeType 文件类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkFileFolderPath 上传对象名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localChunkFilePath 本地文件地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 上传成功true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">uploadFileToMinio</span><span class="params">(String bucket, String mimeType, String chunkFileFolderPath, String localChunkFilePath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">UploadObjectArgs</span> <span class="variable">uploadObjectArgs</span> <span class="operator">=</span> UploadObjectArgs.builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(chunkFileFolderPath)</span><br><span class="line">                .filename(localChunkFilePath)</span><br><span class="line">                .contentType(mimeType)</span><br><span class="line">                .build();</span><br><span class="line">        minioClient.uploadObject(uploadObjectArgs);</span><br><span class="line">        log.debug(<span class="string">&quot;上传文件到 minio 成功,bucket:&#123;&#125;,objectName:&#123;&#125;&quot;</span>,bucket,chunkFileFolderPath);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;上传文件到 minio 出错,bucket:&#123;&#125;,objectName:&#123;&#125;,错误原因:&#123;&#125;&quot;</span>,bucket,chunkFileFolderPath,e.getMessage(),e);</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;上传文件到文件系统失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="上传分块测试"><a href="#上传分块测试" class="headerlink" title="上传分块测试"></a>上传分块测试</h4><ul><li><p>完善Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;文件上传前检查文件&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/checkfile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mediaFileService.checkFile(fileMd5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;分块文件上传前检查分块&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/checkchunk&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mediaFileService.checkChunk(fileMd5, chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;上传分块文件&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/uploadchunk&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, <span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line">    <span class="comment">// return mediaFileService.uploadChunk(fileMd5, chunk, file.getBytes());</span></span><br><span class="line">    <span class="comment">// 方法二</span></span><br><span class="line">    <span class="comment">// 创建临时文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">tempFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        tempFile = File.createTempFile(<span class="string">&quot;minio&quot;</span>, <span class="string">&quot;temp&quot;</span>);</span><br><span class="line">        <span class="comment">// 拷贝文件到临时文件</span></span><br><span class="line">        file.transferTo(tempFile);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;创建临时文件失败&quot;</span>);</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;创建临时文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取文件绝对路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> tempFile.getAbsolutePath();</span><br><span class="line">    <span class="keyword">return</span> mediaFileService.uploadChunk(fileMd5, chunk, absolutePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="合并前下载分块"><a href="#合并前下载分块" class="headerlink" title="合并前下载分块"></a>合并前下载分块</h4><p><strong>service 接口</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在合并分块前，我们需要先下载分块，在ServiceImpl中定义下载分块方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5       文件的MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal    总块数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分块文件数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> File[] checkChunkStatus(String fileMd5, <span class="type">int</span> chunkTotal) &#123;</span><br><span class="line">    <span class="comment">// 作为结果返回</span></span><br><span class="line">    File[] files = <span class="keyword">new</span> <span class="title class_">File</span>[chunkTotal];</span><br><span class="line">    <span class="comment">// 获取分块文件目录</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFileFolder</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chunkTotal; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取分块文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> chunkFileFolder + i;</span><br><span class="line">        <span class="type">File</span> <span class="variable">chunkFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建临时的分块文件</span></span><br><span class="line">            chunkFile = File.createTempFile(<span class="string">&quot;chunk&quot;</span> + i, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;创建临时分块文件出错：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下载分块文件</span></span><br><span class="line">        chunkFile = downloadFileFromMinio(chunkFile, video_files, chunkFilePath);</span><br><span class="line">        <span class="comment">// 组成结果</span></span><br><span class="line">        files[i] = chunkFile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Minio中下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file          目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket        桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName    桶内文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> File <span class="title function_">downloadFileFromMinio</span><span class="params">(File file, String bucket, String objectName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">         <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs</span><br><span class="line">                 .builder()</span><br><span class="line">                 .bucket(bucket)</span><br><span class="line">                 .object(objectName)</span><br><span class="line">                 .build())) &#123;</span><br><span class="line">        IOUtils.copy(inputStream, fileOutputStream);</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;查询文件分块出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="合并分块"><a href="#合并分块" class="headerlink" title="合并分块"></a>合并分块</h4><ul><li><p>合并分块的实现代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(Long companyId, String fileMd5, <span class="type">int</span> chunkTotal, UploadFileParamsDto uploadFileParamsDto)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 下载分块文件</span></span><br><span class="line">    File[] chunkFiles = checkChunkStatus(fileMd5, chunkTotal);</span><br><span class="line">    <span class="comment">// 获取源文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">    <span class="comment">// 获取源文件扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建出临时文件，准备合并</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">mergeFile</span> <span class="operator">=</span> File.createTempFile(fileName, extension);</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 写入流，向临时文件写入</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf_write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(mergeFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历分块文件数组</span></span><br><span class="line">    <span class="keyword">for</span> (File chunkFile : chunkFiles) &#123;</span><br><span class="line">        <span class="comment">// 读取流，读分块文件</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf_read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(chunkFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf_read.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            raf_write.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uploadFileParamsDto.setFileSize(mergeFile.length());</span><br><span class="line">    <span class="comment">// 对文件进行校验，通过MD5值比较</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">mergeInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mergeFile);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mergeMd5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(mergeInputStream);</span><br><span class="line">    <span class="keyword">if</span> (!fileMd5.equals(mergeMd5)) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;合并文件校验失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接合并文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergeFilePath</span> <span class="operator">=</span> getFilePathByMd5(fileMd5, extension);</span><br><span class="line">    <span class="comment">// 将本地合并好的文件，上传到minio中，这里重载了一个方法</span></span><br><span class="line">    addMediaFilesToMinIO(mergeFile.getAbsolutePath(), video_files, mergeFilePath);</span><br><span class="line">    <span class="comment">// 将文件信息写入数据库</span></span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> addMediaFilesToDB(companyId, uploadFileParamsDto, mergeFilePath, mergeMd5, video_files);</span><br><span class="line">    <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span>) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;媒资文件入库出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将本地文件上传到minio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath      本地文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket        桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectName    对象名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addMediaFilesToMinIO</span><span class="params">(String filePath, String bucket, String objectName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> getContentType(objectName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        minioClient.uploadObject(UploadObjectArgs</span><br><span class="line">                .builder()</span><br><span class="line">                .bucket(bucket)</span><br><span class="line">                .object(objectName)</span><br><span class="line">                .filename(filePath)</span><br><span class="line">                .contentType(contentType)</span><br><span class="line">                .build());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;上传到文件系统出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据MD5和文件扩展名，生成文件路径，例 /2/f/2f6451sdg/2f6451sdg.mp4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5       文件MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> extension     文件扩展名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getFilePathByMd5</span><span class="params">(String fileMd5, String extension)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fileMd5.substring(<span class="number">0</span>, <span class="number">1</span>) + <span class="string">&quot;/&quot;</span> + fileMd5.substring(<span class="number">1</span>, <span class="number">2</span>) + <span class="string">&quot;/&quot;</span> + fileMd5 + <span class="string">&quot;/&quot;</span> + fileMd5 + extension;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基本的业务逻辑就是这些，但是现在还少了点东西，我们没有做异常处理，简单的throw出去而已，并且创建的临时文件，也需要删除，完善后的代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(Long companyId, String fileMd5, <span class="type">int</span> chunkTotal, UploadFileParamsDto uploadFileParamsDto)</span> &#123;</span><br><span class="line">    <span class="comment">// 下载分块文件</span></span><br><span class="line">    File[] chunkFiles = checkChunkStatus(fileMd5, chunkTotal);</span><br><span class="line">    <span class="comment">// 获取源文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">    <span class="comment">// 获取源文件扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建出临时文件，准备合并</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">mergeFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mergeFile = File.createTempFile(fileName, extension);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;创建合并临时文件出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 缓冲区</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写入流，向临时文件写入</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">raf_write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(mergeFile, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历分块文件数组</span></span><br><span class="line">            <span class="keyword">for</span> (File chunkFile : chunkFiles) &#123;</span><br><span class="line">                <span class="comment">// 读取流，读分块文件</span></span><br><span class="line">                <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">raf_read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(chunkFile, <span class="string">&quot;r&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = raf_read.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        raf_write.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;合并文件过程中出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        uploadFileParamsDto.setFileSize(mergeFile.length());</span><br><span class="line">        <span class="comment">// 对文件进行校验，通过MD5值比较</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">mergeInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mergeFile)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">mergeMd5</span> <span class="operator">=</span> org.apache.commons.codec.digest.DigestUtils.md5Hex(mergeInputStream);</span><br><span class="line">            <span class="keyword">if</span> (!fileMd5.equals(mergeMd5)) &#123;</span><br><span class="line">                XueChengPlusException.cast(<span class="string">&quot;合并文件校验失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;合并文件校验通过：&#123;&#125;&quot;</span>, mergeFile.getAbsolutePath());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;合并文件校验异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mergeFilePath</span> <span class="operator">=</span> getFilePathByMd5(fileMd5, extension);</span><br><span class="line">        <span class="comment">// 将本地合并好的文件，上传到minio中，这里重载了一个方法</span></span><br><span class="line">        addMediaFilesToMinIO(mergeFile.getAbsolutePath(), video_files, mergeFilePath);</span><br><span class="line">        log.debug(<span class="string">&quot;合并文件上传至MinIO完成&#123;&#125;&quot;</span>, mergeFile.getAbsolutePath());</span><br><span class="line">        <span class="comment">// 将文件信息写入数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> addMediaFilesToDB(companyId, uploadFileParamsDto, mergeFilePath, fileMd5, video_files);</span><br><span class="line">        <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span>) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;媒资文件入库出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;媒资文件入库完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> RestResponse.success();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (File chunkFile : chunkFiles) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                chunkFile.delete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;临时分块文件删除错误：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mergeFile.delete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;临时合并文件删除错误：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="合并分块（新）"><a href="#合并分块（新）" class="headerlink" title="合并分块（新）"></a>合并分块（新）</h3><h4 id="定义-service-接口"><a href="#定义-service-接口" class="headerlink" title="定义 service 接口"></a>定义 service 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> companyId 机构 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5 文件 md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal 分块总和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uploadFileParamsDto 文件信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RestResponse <span class="title function_">mergeChunks</span><span class="params">(Long companyId,String fileMd5,<span class="type">int</span> chunkTotal,UploadFileParamsDto uploadFileParamsDto)</span>;</span><br></pre></td></tr></table></figure><h4 id="service-实现："><a href="#service-实现：" class="headerlink" title="service 实现："></a>service 实现：</h4><p><strong>业务流程</strong></p><ul><li>合并最后一个文件操作</li><li>合并整个文件操作</li><li>验证文件</li><li>保存文件信息</li><li>删除分块文件</li></ul><h5 id="合并最后一个文件操作"><a href="#合并最后一个文件操作" class="headerlink" title="合并最后一个文件操作"></a>合并最后一个文件操作</h5><p>目前，<code>composeObject</code>方法合并的分块文件大小必须大于等于5242880字节，否则会出现上述报错信息<strong>source testbucket&#x2F;chunk&#x2F;4: size 3819300 must be greater than 5242880</strong>。为了解决这个问题，您可以按以下步骤进行操作：</p><ol><li>找出最后一个分块文件，获取它的大小。假设您的分块总数为n，最后一个分块文件名称为<code>part-n</code>，则可以使用以下代码获取最后一个分块文件的大小：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">partSize</span> <span class="operator">=</span> client.statObject(StatObjectArgs.builder().bucket(<span class="string">&quot;testbucket&quot;</span>).object(<span class="string">&quot;chunk/part-&quot;</span> + n).build()).size();</span><br></pre></td></tr></table></figure><ol start="2"><li>将最后一个分块文件合并到上一个分块文件中。如果最后一个分块文件大小小于5242880字节，则可以将最后一个分块文件和前一个分块文件合并为一个文件，使得合并后的文件大小大于等于5242880字节。可以使用以下代码将最后一个分块文件合并到前一个分块文件中：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将最后一个分块文件合并到上一个分块文件中</span></span><br><span class="line"><span class="comment"> * 使得合并后的文件大小大于等于5MB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buket 桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileFolderPath 文件所在目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> contentType 文件类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunk 分块数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 合并失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeLastChunkFile</span><span class="params">(String buket, String fileFolderPath, String contentType, <span class="type">int</span> chunk)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 最后一个文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lastFilePath</span> <span class="operator">=</span> fileFolderPath.concat(Integer.toString(chunk));</span><br><span class="line">    <span class="comment">// 上一个文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">preFilePath</span> <span class="operator">=</span> fileFolderPath.concat(Integer.toString(chunk - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 1.获取最后一个分块文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">lastFilesize</span> <span class="operator">=</span> minioClient.statObject(StatObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(lastFilePath)</span><br><span class="line">            .build()).size();</span><br><span class="line">    <span class="comment">// 1.1 获取上一个分块文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">preFilesize</span> <span class="operator">=</span> minioClient.statObject(StatObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(preFilePath)</span><br><span class="line">            .build()).size();</span><br><span class="line">    <span class="comment">// 2.获取合并后的分块文件大小，使得合并后的文件大小大于等于5242880字节</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> lastFilesize + preFilesize;</span><br><span class="line">    <span class="comment">// 3.获取到最后一个分块文件的内容流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">lastInputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(lastFilePath)</span><br><span class="line">            .build());</span><br><span class="line">    <span class="comment">// 4.获取到前一个分块文件的内容流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">preInputStream</span> <span class="operator">=</span> minioClient.getObject(GetObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(preFilePath)</span><br><span class="line">            .build());</span><br><span class="line">    <span class="comment">// 5.合并文件流生成新的输入流</span></span><br><span class="line">    <span class="type">SequenceInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceInputStream</span>(preInputStream, lastInputStream);</span><br><span class="line">    <span class="comment">// 6.上传新的文件到上一个分块文件</span></span><br><span class="line">    <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(preFilePath)</span><br><span class="line">            .stream(inputStream, fileSize, -<span class="number">1</span>)</span><br><span class="line">            .contentType(contentType)</span><br><span class="line">            .build();</span><br><span class="line">    minioClient.putObject(putObjectArgs);</span><br><span class="line">    <span class="comment">/*File tempFile = File.createTempFile(&quot;minio&quot;, &quot;lastChunk&quot;);</span></span><br><span class="line"><span class="comment">    FileOutputStream outputStream = new FileOutputStream(tempFile);</span></span><br><span class="line"><span class="comment">    IoUtils.copy(inputStream, outputStream);</span></span><br><span class="line"><span class="comment">    // 使用uploadObject方法</span></span><br><span class="line"><span class="comment">    minioClient.uploadObject(UploadObjectArgs.builder()</span></span><br><span class="line"><span class="comment">            .bucket(buket)</span></span><br><span class="line"><span class="comment">            .object(preFilePath)</span></span><br><span class="line"><span class="comment">            .filename(tempFile.getAbsolutePath())</span></span><br><span class="line"><span class="comment">            .build());</span></span><br><span class="line"><span class="comment">    tempFile.delete();*/</span></span><br><span class="line">    <span class="comment">// 7. 删除最后一个分块文件</span></span><br><span class="line">    minioClient.removeObject(RemoveObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(lastFilePath)</span><br><span class="line">            .build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="合并整个文件操作"><a href="#合并整个文件操作" class="headerlink" title="合并整个文件操作"></a>合并整个文件操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buket 桶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileFolderPath 分块文件所在目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mergeFilePath 合并文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal 分块总数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 合并成功true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeChunkFile</span><span class="params">(String buket, String fileFolderPath, String mergeFilePath, <span class="type">int</span> chunkTotal)</span>&#123;</span><br><span class="line">    <span class="comment">// Stream.iterate 是 Java 8 中的一个方法，用于创建一个无限流</span></span><br><span class="line">    <span class="comment">// 第一个元素是初始值，后续每个元素都是前一个元素加1</span></span><br><span class="line">    <span class="comment">// 需要注意的是，由于 Stream.iterate 创建的是无限流，因此需要通过 limit() 或其他终止操作来限制流的大小</span></span><br><span class="line">    List&lt;ComposeSource&gt; sources = Stream.iterate(<span class="number">0</span>, i -&gt; ++i).limit(chunkTotal)</span><br><span class="line">            .map(i -&gt; ComposeSource.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(fileFolderPath.concat(Integer.toString(i)))</span><br><span class="line">            .build()</span><br><span class="line">    ).collect(Collectors.toList());</span><br><span class="line">    <span class="type">ComposeObjectArgs</span> <span class="variable">composeObject</span> <span class="operator">=</span> ComposeObjectArgs.builder()</span><br><span class="line">            .bucket(buket)</span><br><span class="line">            .object(mergeFilePath)</span><br><span class="line">            .sources(sources)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        minioClient.composeObject(composeObject);</span><br><span class="line">        log.info(<span class="string">&quot;合并文件成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;合并文件失败&quot;</span>);</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;合并文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="验证文件"><a href="#验证文件" class="headerlink" title="验证文件"></a>验证文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  =================3. 验证文件===============</span></span><br><span class="line"><span class="comment">// 验证md5合并后的文件和源文件是否一致，从而判断是否上传成功</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> downloadFileFromMinIO(bucket_video, mergeFilePath);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">null</span>)&#123;</span><br><span class="line">    log.error(<span class="string">&quot;下载合并后文件失败,mergeFilePath:&#123;&#125;&quot;</span>,mergeFilePath);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;下载合并后文件失败。&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 校验文件md5</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">// minio上文件的md5值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">md5Hex</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line">    <span class="comment">//比较md5值，不一致则说明文件不完整</span></span><br><span class="line">    <span class="keyword">if</span> (!fileMd5.equals(md5Hex))&#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;文件合并校验失败&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置文件大小</span></span><br><span class="line">    uploadFileParamsDto.setFileSize(file.length());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>)&#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="保存文件信息"><a href="#保存文件信息" class="headerlink" title="保存文件信息"></a>保存文件信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 保持文件到数据库</span><br><span class="line"> *</span><br><span class="line"> * @param companyId           机构id</span><br><span class="line"> * @param uploadFileParamsDto 上传文件的信息</span><br><span class="line"> * @param objectName          对象名称</span><br><span class="line"> * @param fileMD5             文件的md5码</span><br><span class="line"> * @param bucket              桶</span><br><span class="line"> * @return MediaFiles</span><br><span class="line"> */</span><br><span class="line">@Transactional</span><br><span class="line">public MediaFiles saveFileToDB(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket) &#123;</span><br><span class="line">    MediaFiles mediaFile = this.getById(fileMD5);</span><br><span class="line">    if (mediaFile == null) &#123;</span><br><span class="line">        mediaFile = new MediaFiles();</span><br><span class="line">        BeanUtils.copyProperties(uploadFileParamsDto, mediaFile);</span><br><span class="line">        mediaFile.setId(fileMD5);</span><br><span class="line">        mediaFile.setFileId(fileMD5);</span><br><span class="line">        mediaFile.setCompanyId(companyId);</span><br><span class="line">        mediaFile.setBucket(bucket);</span><br><span class="line">        mediaFile.setCreateDate(LocalDateTime.now());</span><br><span class="line">        mediaFile.setStatus(&quot;1&quot;);</span><br><span class="line">        mediaFile.setFilePath(objectName);</span><br><span class="line">        mediaFile.setUrl(&quot;/&quot; + bucket + &quot;/&quot; + objectName);</span><br><span class="line">        // 查阅数据字典，002003表示审核通过</span><br><span class="line">        mediaFile.setAuditStatus(&quot;002003&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean save = this.save(mediaFile);</span><br><span class="line">    if (!save) &#123;</span><br><span class="line">        XcPlusException.cast(&quot;保存文件信息失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return mediaFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除分块文件"><a href="#删除分块文件" class="headerlink" title="删除分块文件"></a>删除分块文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除分块文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkFilePath 分块文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal 分块数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearChunkFiles</span><span class="params">(String bucket, String chunkFilePath, <span class="type">int</span> chunkTotal)</span> &#123;</span><br><span class="line">    Iterable&lt;DeleteObject&gt; object = Stream.iterate(<span class="number">0</span>, i -&gt; ++i).limit(chunkTotal)</span><br><span class="line">            .map(i -&gt; <span class="keyword">new</span> <span class="title class_">DeleteObject</span>(chunkFilePath.concat(Integer.toString(i))))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="type">RemoveObjectsArgs</span> <span class="variable">args</span> <span class="operator">=</span> RemoveObjectsArgs.builder()</span><br><span class="line">            .bucket(bucket)</span><br><span class="line">            .objects(object)</span><br><span class="line">            .build();</span><br><span class="line">    Iterable&lt;Result&lt;DeleteError&gt;&gt; results = minioClient.removeObjects(args);</span><br><span class="line">    <span class="keyword">for</span> (Result&lt;DeleteError&gt; result : results) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeleteError</span> <span class="variable">error</span> <span class="operator">=</span> result.get();</span><br><span class="line">            log.error( <span class="string">&quot;清楚分块文件出错&quot;</span> + error.objectName() + <span class="string">&quot;; &quot;</span> + error.message());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并分块接口实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> companyId           机构 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileMd5             文件 md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chunkTotal          分块总和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uploadFileParamsDto 文件信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(Long companyId, String fileMd5, <span class="type">int</span> chunkTotal, UploadFileParamsDto uploadFileParamsDto)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.下载分块文件</span></span><br><span class="line">    <span class="comment">// 获取minio分块文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> getChunkFileFolderPath(fileMd5);</span><br><span class="line">    <span class="comment">//获取文件类型mimeType</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> getMimeType(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// =================1. 合并最后一个文件操作===============</span></span><br><span class="line">    <span class="comment">// 将最后一个分块文件合并到上一个分块文件中</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mergeLastChunkFile(bucket_video, chunkFilePath, mimeType, chunkTotal - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;合并最后一个分块文件失败&quot;</span>);</span><br><span class="line">        XcPlusException.cast(<span class="string">&quot;合并最后一个分块文件失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =================2. 合并整个文件操作===============</span></span><br><span class="line">    <span class="comment">// 文件名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">    <span class="comment">// 文件扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">//合并文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergeFilePath</span> <span class="operator">=</span> getFilePathByMd5(fileMd5, extension);</span><br><span class="line">    <span class="comment">// 合并分块文件</span></span><br><span class="line">    mergeChunkFile(bucket_video, chunkFilePath, mergeFilePath, chunkTotal-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//  =================3. 验证文件===============</span></span><br><span class="line">    <span class="comment">// 验证md5合并后的文件和源文件是否一致，从而判断是否上传成功</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> downloadFileFromMinIO(bucket_video, mergeFilePath);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">null</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;下载合并后文件失败,mergeFilePath:&#123;&#125;&quot;</span>,mergeFilePath);</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;下载合并后文件失败。&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 校验文件md5</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// minio上文件的md5值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">md5Hex</span> <span class="operator">=</span> DigestUtils.md5Hex(fileInputStream);</span><br><span class="line">        <span class="comment">//比较md5值，不一致则说明文件不完整</span></span><br><span class="line">        <span class="keyword">if</span> (!fileMd5.equals(md5Hex))&#123;</span><br><span class="line">            <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;文件合并校验失败&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置文件大小</span></span><br><span class="line">        uploadFileParamsDto.setFileSize(file.length());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">null</span>)&#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  =================4.保存文件信息===============</span></span><br><span class="line">    mediaFileService.saveFileToDB(companyId, uploadFileParamsDto, mergeFilePath, fileMd5, bucket_video);</span><br><span class="line">    <span class="comment">//  =================5. 删除分块文件===============</span></span><br><span class="line">    clearChunkFiles(bucket_video,chunkFilePath,chunkTotal);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接口层完善"><a href="#接口层完善" class="headerlink" title="接口层完善"></a>接口层完善</h3><ul><li><p>下面完善接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;大文件上传接口&quot;, tags = &quot;大文件上传接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigFilesController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaFileService mediaFileService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;文件上传前检查文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/checkfile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkFile</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.checkFile(fileMd5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;分块文件上传前检查分块&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/checkchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title function_">checkChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.checkChunk(fileMd5, chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用putObject方法上传分块文件</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;上传分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/uploadchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, <span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.uploadChunk(fileMd5, chunk, file.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用uploadObject方法上传分块文件</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;上传分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/uploadchunk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">uploadChunk</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;chunk&quot;)</span> <span class="type">int</span> chunk)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建临时文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">tempFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tempFile = File.createTempFile(<span class="string">&quot;minio&quot;</span>, <span class="string">&quot;temp&quot;</span>);</span><br><span class="line">            <span class="comment">// 拷贝文件到临时文件</span></span><br><span class="line">            file.transferTo(tempFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">&quot;创建临时文件失败&quot;</span>);</span><br><span class="line">            XcPlusException.cast(<span class="string">&quot;创建临时文件失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取文件绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> tempFile.getAbsolutePath();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> mediaFileService.uploadChunk(fileMd5, chunk, absolutePath);</span><br><span class="line">        tempFile.delete();</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> RestResponse.success(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.validfail(<span class="string">&quot;上传分块失败&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;合并分块文件&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/mergechunks&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestResponse <span class="title function_">mergeChunks</span><span class="params">(<span class="meta">@RequestParam(&quot;fileMd5&quot;)</span> String fileMd5, <span class="meta">@RequestParam(&quot;fileName&quot;)</span> String fileName, <span class="meta">@RequestParam(&quot;chunkTotal&quot;)</span> <span class="type">int</span> chunkTotal)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> <span class="number">1232141425L</span>;</span><br><span class="line">        <span class="type">UploadFileParamsDto</span> <span class="variable">uploadFileParamsDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileParamsDto</span>();</span><br><span class="line">        uploadFileParamsDto.setFileType(<span class="string">&quot;001002&quot;</span>);</span><br><span class="line">        uploadFileParamsDto.setTags(<span class="string">&quot;课程视频&quot;</span>);</span><br><span class="line">        uploadFileParamsDto.setRemark(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        uploadFileParamsDto.setFilename(fileName);</span><br><span class="line">        <span class="keyword">return</span> mediaFileService.mergeChunks(companyId, fileMd5, chunkTotal, uploadFileParamsDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><ul><li>前后端联调，上传视频进行测试<br><img src="/adanpro/adanblog/./../pic/202306160048701.png" alt="img"></li><li>数据库和MinIO中均能看到对应的数据<br><img src="/adanpro/adanblog/./../pic/202306160038552.png" alt="img"></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="文件预览"><a href="#文件预览" class="headerlink" title="文件预览"></a>文件预览</h1><h2 id="需求分析-2"><a href="#需求分析-2" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>图片上传成功、视频上传成功后，可以通过预览按钮查看文件内容</li><li>预览的方式是通过浏览器直接打开文件，对于图片和浏览器支持的视频格式可以直接浏览<br><img src="/adanpro/adanblog/./../pic/202306160038438.png" alt="img"></li><li>说明<ol><li>前端请求接口层预览文件</li><li>接口层将文件id传递给服务层</li><li>服务层使用文件id查询媒资数据库文件表，获取文件的URL</li><li>接口层将文件url返回给前端，通过浏览器打开URL</li></ol></li></ul><h2 id="接口定义-2"><a href="#接口定义-2" class="headerlink" title="接口定义"></a>接口定义</h2><ul><li><p>根据需求分析，定义的接口如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;预览文件&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/preview/&#123;mediaId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;String&gt; <span class="title function_">getPlayUrlByMediaId</span><span class="params">(<span class="meta">@PathVariable</span> String mediaId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口开发-2"><a href="#接口开发-2" class="headerlink" title="接口开发"></a>接口开发</h2><h3 id="设置URL"><a href="#设置URL" class="headerlink" title="设置URL"></a>设置URL</h3><ul><li><p>有一些浏览器不支持的视频格式，不能在浏览器中直接浏览，所以我们要修改保存媒资信息到数据库的方法</p><ul><li>当文件是图片时，设置URL字段</li><li>当视频是MP4格式时，设置URL字段</li><li>其他情况暂不设置URL，需要文件处理后再设置URL字段</li></ul></li><li><p>修改保存媒资信息的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文件信息添加到文件表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uploadFileParamsDto 上传文件的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileMD5             文件的md5码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket              桶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> MediaFiles <span class="title function_">addMediaFilesToDB</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存到数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> mediaFilesMapper.selectById(fileMD5);</span><br><span class="line">        <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span>) &#123;</span><br><span class="line">            mediaFiles = <span class="keyword">new</span> <span class="title class_">MediaFiles</span>();</span><br><span class="line">            BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles);</span><br><span class="line">            mediaFiles.setId(fileMD5);</span><br><span class="line">            mediaFiles.setFileId(fileMD5);</span><br><span class="line">            mediaFiles.setCompanyId(companyId);</span><br><span class="line">            mediaFiles.setBucket(bucket);</span><br><span class="line">            mediaFiles.setCreateDate(LocalDateTime.now());</span><br><span class="line">            mediaFiles.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            mediaFiles.setFilePath(objectName);</span><br><span class="line">+           <span class="comment">// 获取源文件名的contentType</span></span><br><span class="line">+           <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> getContentType(objectName);</span><br><span class="line">+           <span class="comment">// 如果是图片格式或者mp4格式，则设置URL属性，否则不设置</span></span><br><span class="line">+           <span class="keyword">if</span> (contentType.contains(<span class="string">&quot;image&quot;</span>) || contentType.contains(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">+               mediaFiles.setUrl(<span class="string">&quot;/&quot;</span> + bucket + <span class="string">&quot;/&quot;</span> + objectName);</span><br><span class="line">+           &#125;</span><br><span class="line">            <span class="comment">// 查阅数据字典，002003表示审核通过</span></span><br><span class="line">            mediaFiles.setAuditStatus(<span class="string">&quot;002003&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> mediaFilesMapper.insert(mediaFiles);</span><br><span class="line">        <span class="keyword">if</span> (insert &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;保存文件信息失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mediaFiles;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="DAO开发-2"><a href="#DAO开发-2" class="headerlink" title="DAO开发"></a>DAO开发</h3><ul><li>使用自动生成的Mapper接口即可</li></ul><h3 id="Service开发-2"><a href="#Service开发-2" class="headerlink" title="Service开发"></a>Service开发</h3><ul><li><p>定义根据id查询媒资文件接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MediaFiles <span class="title function_">getFileById</span><span class="params">(String mediaId)</span>;</span><br></pre></td></tr></table></figure></li><li><p>方法实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MediaFiles <span class="title function_">getFileById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> mediaFilesMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span> || StringUtils.isEmpty(mediaFiles.getUrl())) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;视频还没有转码处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mediaFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="完善Controller-1"><a href="#完善Controller-1" class="headerlink" title="完善Controller"></a>完善Controller</h3><ul><li><p>完善接口层代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;预览文件&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/preview/&#123;mediaId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;String&gt; <span class="title function_">getPlayUrlByMediaId</span><span class="params">(<span class="meta">@PathVariable</span> String mediaId)</span> &#123;</span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFile</span> <span class="operator">=</span> mediaFileService.getFileById(mediaId);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.success(mediaFile.getUrl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接口测试-1"><a href="#接口测试-1" class="headerlink" title="接口测试"></a>接口测试</h3><ul><li>前后端联调<ul><li>上传MP4视频文件，并预览</li><li>上传图片文件，并预览</li><li>上传.avi格式的视频文件，尝试预览，观察错误提示信息，稍后通过视频处理对视频转码</li></ul></li></ul><h1 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h1><h2 id="分布式任务处理"><a href="#分布式任务处理" class="headerlink" title="分布式任务处理"></a>分布式任务处理</h2><h3 id="什么是分布式任务调度"><a href="#什么是分布式任务调度" class="headerlink" title="什么是分布式任务调度"></a>什么是分布式任务调度</h3><ul><li><p>视频上传成功需要对视频格式进行处理，如何用Java程序对视频进行处理呢？</p><ul><li>这里有一个关键的需求就是：当视频比较多的时候，我们如何高效的处理</li></ul></li><li><p>如何去高效的处理一批任务呢？</p><ol><li>多线程<ul><li>多线程是充分利用单机的资源</li></ul></li><li>分布式+多线程<ul><li>充分利用多台计算机，每台计算机使用多线程处理</li></ul></li></ol></li><li><p>方案2的可扩展性更强，同时方案二也是一种分布式任务调度的处理方案</p></li><li><p>什么是分布式任务调度?</p><ul><li><p>我们可以先思考一下下面业务场景的解决方案</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">某电商系统需要在每天上午10点，下午3点，晚上8点发放一批优惠券</span><br><span class="line"></span><br><span class="line">某财务系统需要在每天上午10天谴结算前一天的账单数据，统计汇总</span><br><span class="line"></span><br><span class="line">某电商平台每天凌晨3点，要对订单中的无效订单进行处理</span><br><span class="line"></span><br><span class="line">12306网站会根据车次不同，设置几个时间点分批放票</span><br><span class="line"></span><br><span class="line">电商正点抢购，商品价格某天上午8点整开始优惠</span><br><span class="line"></span><br><span class="line">商品成功发货后，需要向客户发送短信提醒</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类似的场景还有很多，我们该如何实现呢？</p><ul><li>以上这些场景，就是任务调度所需要解决的问题</li></ul></li><li><p>任务调度，顾名思义就是对任务的调度，它是指系统为了完成特定业务，基于给定时间点，给定时间间隔或者给定执行次数自动执行任务</p></li><li><p>如何实现任务调度？</p><ul><li><p>多线程方式实现</p><ul><li><p>我们可以开启一个线程，每sleep一段时间，就去检查是否已经到预期执行时间，下面代码简单实现了任务调度的功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 任务执行时间间隔</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeInterval</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> something</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(timeInterval);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>上面的代码实现了按一定时间间隔，执行任务调度的功能</p></li><li><p>JDK也为我们提供了相关支持，如Timer、ScheduledExecutor，下面我们了解下</p><ul><li><p>Timer</p></li><li><p>ScheduledExecutor</p></li><li><p>Timer方式实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="number">2000</span>); <span class="comment">// 1秒后开始调度，每2秒执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Timer的优点在于简单易用，每个Timer对应一个线程，因此可以同时启动多个Timer并行执行多个任务，同一个Timer中的任务是串行执行</p></li></ul></li><li><p>Timer和ScheduledExecutor都仅能提供基于开始时间与重复间隔的任务调度，不能胜任更加复杂的调度需求。比如，设置每个月第一天凌晨1点执行任务、复杂调度任务的管理、任务键传递数据等等</p></li><li><p>Quartz是一个功能强大的任务调度框架，它可以满足更多更复杂的调度需求</p><ul><li><p>Quartz设计的核心类包括Job，Trigger以及Scheduler。</p><ul><li>Job负责定义需要执行的任务</li><li>Trigger负责设置调度策略</li><li>Scheduler将二者组装在一起，并触发任务开始执行。</li></ul></li><li><p>Quartz支持简单的按时间间隔调度，还支持按日历调度方式，通过设置CronTrigger表达式（包括：秒、分、时、日、月、周、年）进行任务调度</p></li><li><p>第三方Quartz方式实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] agrs)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">    <span class="comment">//创建一个Scheduler</span></span><br><span class="line">    <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">    <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">    <span class="comment">//创建JobDetail</span></span><br><span class="line">    <span class="type">JobBuilder</span> <span class="variable">jobDetailBuilder</span> <span class="operator">=</span> JobBuilder.newJob(MyJob.class);</span><br><span class="line">    jobDetailBuilder.withIdentity(<span class="string">&quot;jobName&quot;</span>,<span class="string">&quot;jobGroupName&quot;</span>);</span><br><span class="line">    <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> jobDetailBuilder.build();</span><br><span class="line">    <span class="comment">//创建触发的CronTrigger 支持按日历调度</span></span><br><span class="line">    <span class="type">CronTrigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">            .withIdentity(<span class="string">&quot;triggerName&quot;</span>, <span class="string">&quot;triggerGroupName&quot;</span>)</span><br><span class="line">            .startNow()</span><br><span class="line">            .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/2 * * * * ?&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//创建触发的SimpleTrigger 简单的间隔调度</span></span><br><span class="line">    <span class="comment">/*SimpleTrigger trigger = TriggerBuilder.newTrigger()</span></span><br><span class="line"><span class="comment">            .withIdentity(&quot;triggerName&quot;,&quot;triggerGroupName&quot;)</span></span><br><span class="line"><span class="comment">            .startNow()</span></span><br><span class="line"><span class="comment">            .withSchedule(SimpleScheduleBuilder</span></span><br><span class="line"><span class="comment">                    .simpleSchedule()</span></span><br><span class="line"><span class="comment">                    .withIntervalInSeconds(2)</span></span><br><span class="line"><span class="comment">                    .repeatForever())</span></span><br><span class="line"><span class="comment">            .build();*/</span></span><br><span class="line">    scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line">    scheduler.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;todo something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>什么是分布式任务调度</p><ul><li>通常任务调度的程序是集成在应用中的，比如<ul><li>优惠券服务汇总包括了定时发布优惠券的调度程序</li><li>结算服务中包括了定期生成报表的任务调度程序</li></ul></li><li>由于采用分布式架构，一个服务通常会部署在多个冗余实例来运行我们的业务</li><li>在这种分布式环境下运行任务调度，就称之为分布式业务调度<br><img src="/adanpro/adanblog/./../pic/202306160049197.png" alt="img"></li></ul></li><li><p>分布式调度要实现的目标</p><ul><li>不管是任务调度程序集成在应用程序中，还是单独构建的任务调度系统，如果采用分布式调度任务的方式，就相当于将任务调度程序分布式构建，这样就可以具有分布式系统的特点，并且提高任务的调度处理能力</li></ul><ol><li>并行任务调度<ul><li>并行任务调度实现靠多线程，如果有大量任务需要调度，此时光靠多线程就会有瓶颈了，因为一台计算机的CPU处理能力是有限的</li><li>如果将任务调度程序分布式部署，每个节点还可以部署为集群，这样就可以让多台计算机共同去完成任务调度，我们可以将任务分割为若干个分片，由不同的实例并行执行，来提高任务调度的处理效率</li></ul></li><li>高可用<ul><li>若某一个实例宕机，不影响其他实例来执行任务</li></ul></li><li>弹性扩容<ul><li>当集群中增加实例就可以提高并执行任务的处理效率</li></ul></li><li>任务管理与检测<ul><li>对系统中存在的定时任进行统一的管理及监测，让开发人员及运维人员能够及时了解任务执行情况，从而做出快速应急处理响应</li></ul></li><li>避免任务重复执行<ul><li>当任务调度以集群方式部署，同一个任务调度可能会执行多次，比如上面提到的电商系统中定时发放优惠券的例子，就会发放多次优惠券，对公司造成很多损失，所以我们需要控制相同的任务在多个运行实例上只执行一次</li></ul></li></ol></li></ul><h3 id="XXL-JOB介绍"><a href="#XXL-JOB介绍" class="headerlink" title="XXL-JOB介绍"></a>XXL-JOB介绍</h3><ul><li><p>XXL-JOB是一个轻量级分布式任务调度平台，其核心设计是开发迅速、学习简单、轻量级、易扩展，现已开放源代码并接入多家公司线上产品线，开箱即用</p></li><li><p>官网：<a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p></li><li><p>XXL-JOB主要由调度中心、执行器、任务</p><p><img src="/adanpro/adanblog/./../pic/202306160038334.png" alt="img"></p><ul><li>调度中心<ul><li>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码</li><li>主要职责为执行器管理、任务管理、监控运维、日志管理等</li></ul></li><li>任务执行器<ul><li>负责接收调度请求并执行任务逻辑</li><li>知道职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等</li></ul></li><li>任务<ul><li>负责执行具体的业务逻辑</li></ul></li></ul></li><li><p>调度中心与执行器之间的工作流程如下</p><p><img src="/adanpro/adanblog/./../pic/202306160054757.png" alt="img"></p></li><li><p>执行流程</p><ol><li>任务执行器根据配置的调度中心的地址，自动注册到调度中心</li><li>达到任务出发条件，调度中心下发任务</li><li>执行器基于线程池执行任务，并把执行结果放入内存队列、把执行日志写入日志文件中</li><li>执行器消费内存队列中的执行结果，主动上报给调度中心</li><li>当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情</li></ol></li></ul><h3 id="搭建XXL-JOB"><a href="#搭建XXL-JOB" class="headerlink" title="搭建XXL-JOB"></a>搭建XXL-JOB</h3><h4 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h4><ul><li><p>首先下载XXL-JOB</p><ul><li>GitHub：<a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></li><li>GitEE：<a href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></li><li>项目使用2.3.1版本： <a href="https://github.com/xuxueli/xxl-job/releases/tag/2.3.1">https://github.com/xuxueli/xxl-job/releases/tag/2.3.1</a></li></ul></li><li><p>使用IDEA打开项目</p><ul><li>xxl-job-admin：调度中心</li><li>xxl-job-core：公共依赖</li><li>xxj-job-executor-samples：执行器Sample示例<ul><li>xxl-job-executor-sample-springboot：SpringBoot版本，通过SpringBoot管理执行器</li><li>xxl-job-executor-sample-frameless：无框架版本</li></ul></li></ul></li><li><p>根据数据库脚本创建数据库，修改数据库连接信息和端口，启动xxl-job-admin，访问</p><p><a href="http://local:18088/xxl-job-admin/">http://local:18088/xxl-job-admin/</a></p><ul><li>账号密码：admin&#x2F;123456<br><img src="/adanpro/adanblog/./../pic/202306160038789.png" alt="img"></li></ul></li><li><p>启动成功之后，可以选择在Linux上运行</p><ul><li><p>使用maven命令，将xxl-job-admin打包，然后将其上传至Linux中，使用命令启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar /绝对路径/xxl-job-admin-2.3.1.jar &amp;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><ul><li><p>下面配置执行器，执行器负责与调度中心通信，接收调度中心发起的任务调度请求</p><ol><li><p>首先在media-service工程中添加依赖（父工程中完成了版本控制，这里的版本是2.3.1）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在nacos下的media-service-dev.yaml下配置xxl-job</p><ul><li><p>注意这里配置的appname是执行器的应用名，稍后会在调度中心配置执行器的时候使用</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">xxl</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">job</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">admin</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">addresses</span>: <span class="string">http://192.168.101.128:18088/xxl-job-admin/</span></span><br><span class="line">    <span class="attr">executor</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">appname</span>: <span class="string">media-process-service</span></span><br><span class="line">      <span class="attr">address</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">ip</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">port</span>: <span class="string">9999</span></span><br><span class="line">      <span class="attr">logpath</span>: <span class="string">/data/applogs/xxl-job-jobhandler</span></span><br><span class="line">      <span class="attr">logretentiondays</span>: <span class="string">30</span></span><br><span class="line">    <span class="attr">accessToken</span>: <span class="string">default_token</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置xxl-job的执行器</p><ul><li><p>将示例工程下的配置类拷贝到media-service工程下，该类中的属性就是获取配置文件中的配置得到的，同时提供了一个执行器的Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 针对多网卡、容器内部署等情况，可借助 &quot;spring-cloud-commons&quot; 提供的 &quot;InetUtils&quot; 组件灵活定制注册IP；</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *      1、引入依赖：</span></span><br><span class="line"><span class="comment">    *          &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    *             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    *             &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    *             &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    *         &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *      2、配置文件，或者容器启动变量</span></span><br><span class="line"><span class="comment">    *          spring.cloud.inetutils.preferred-networks: &#x27;xxx.xxx.xxx.&#x27;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *      3、获取IP</span></span><br><span class="line"><span class="comment">    *          String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>进入调度中心，添加执行器<br><img src="/adanpro/adanblog/./../pic/202306160055001.png" alt="img"></p></li></ol></li><li><p>重启媒资管理服务模块，可以看到执行器在调入中心注册成功<br><img src="/adanpro/adanblog/./../pic/202306160038308.png" alt="img"></p></li></ul><h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><ul><li><p>下面编写任务，任务类的编写方法参考示例工程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxl.job.executor.service.jobhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.context.XxlJobHelper;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XxlJob开发示例（Bean模式）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开发步骤：</span></span><br><span class="line"><span class="comment"> *      1、任务开发：在Spring Bean实例中，开发Job方法；</span></span><br><span class="line"><span class="comment"> *      2、注解配置：为Job方法添加注解 &quot;<span class="doctag">@XxlJob</span>(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。</span></span><br><span class="line"><span class="comment"> *      3、执行日志：需要通过 &quot;XxlJobHelper.log&quot; 打印执行日志；</span></span><br><span class="line"><span class="comment"> *      4、任务结果：默认任务结果为 &quot;成功&quot; 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 &quot;XxlJobHelper.handleFail/handleSuccess&quot; 自主设置任务结果；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuxueli 2019-12-11 21:52:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleXxlJob</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SampleXxlJob.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、简单任务示例（Bean模式）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;XXL-JOB, Hello World.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;beat at:&quot;</span> + i);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// default success</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、分片广播任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分片参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shardTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == shardIndex) &#123;</span><br><span class="line">                XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 命中分片开始处理&quot;</span>, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 忽略&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、命令行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;commandJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commandJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> XxlJobHelper.getJobParam();</span><br><span class="line">        <span class="type">int</span> <span class="variable">exitValue</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// command process</span></span><br><span class="line">            <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">            processBuilder.command(command);</span><br><span class="line">            processBuilder.redirectErrorStream(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">            <span class="comment">//Process process = Runtime.getRuntime().exec(command);</span></span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(process.getInputStream());</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(bufferedInputStream));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// command log</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                XxlJobHelper.log(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// command exit</span></span><br><span class="line">            process.waitFor();</span><br><span class="line">            exitValue = process.exitValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XxlJobHelper.log(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exitValue == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// default success</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            XxlJobHelper.handleFail(<span class="string">&quot;command exit value(&quot;</span>+exitValue+<span class="string">&quot;) is failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、跨平台Http任务</span></span><br><span class="line"><span class="comment">     *  参数示例：</span></span><br><span class="line"><span class="comment">     *      &quot;url: http://www.baidu.com\n&quot; +</span></span><br><span class="line"><span class="comment">     *      &quot;method: get\n&quot; +</span></span><br><span class="line"><span class="comment">     *      &quot;data: content\n&quot;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;httpJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">httpJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// param parse</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> XxlJobHelper.getJobParam();</span><br><span class="line">        <span class="keyword">if</span> (param==<span class="literal">null</span> || param.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;param[&quot;</span>+ param +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] httpParams = param.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String httpParam: httpParams) &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpParam.startsWith(<span class="string">&quot;url:&quot;</span>)) &#123;</span><br><span class="line">                url = httpParam.substring(httpParam.indexOf(<span class="string">&quot;url:&quot;</span>) + <span class="number">4</span>).trim();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (httpParam.startsWith(<span class="string">&quot;method:&quot;</span>)) &#123;</span><br><span class="line">                method = httpParam.substring(httpParam.indexOf(<span class="string">&quot;method:&quot;</span>) + <span class="number">7</span>).trim().toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (httpParam.startsWith(<span class="string">&quot;data:&quot;</span>)) &#123;</span><br><span class="line">                data = httpParam.substring(httpParam.indexOf(<span class="string">&quot;data:&quot;</span>) + <span class="number">5</span>).trim();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// param valid</span></span><br><span class="line">        <span class="keyword">if</span> (url==<span class="literal">null</span> || url.trim().length()==<span class="number">0</span>) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;url[&quot;</span>+ url +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method==<span class="literal">null</span> || !Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>).contains(method)) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;method[&quot;</span>+ method +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isPostMethod</span> <span class="operator">=</span> method.equals(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// request</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// connection</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">realUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">            connection = (HttpURLConnection) realUrl.openConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// connection setting</span></span><br><span class="line">            connection.setRequestMethod(method);</span><br><span class="line">            connection.setDoOutput(isPostMethod);</span><br><span class="line">            connection.setDoInput(<span class="literal">true</span>);</span><br><span class="line">            connection.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">            connection.setReadTimeout(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            connection.setConnectTimeout(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Accept-Charset&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do connection</span></span><br><span class="line">            connection.connect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// data</span></span><br><span class="line">            <span class="keyword">if</span> (isPostMethod &amp;&amp; data!=<span class="literal">null</span> &amp;&amp; data.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(connection.getOutputStream());</span><br><span class="line">                dataOutputStream.write(data.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                dataOutputStream.flush();</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// valid StatusCode</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> connection.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (statusCode != <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Http Request StatusCode(&quot;</span> + statusCode + <span class="string">&quot;) Invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// result</span></span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(connection.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                result.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">responseMsg</span> <span class="operator">=</span> result.toString();</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.log(responseMsg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XxlJobHelper.log(e);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                    connection.disconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                XxlJobHelper.log(e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5、生命周期任务示例：任务初始化与销毁时，支持自定义相关逻辑；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;demoJobHandler2&quot;, init = &quot;init&quot;, destroy = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;XXL-JOB, Hello World.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们现在参考简单示例自己编写代码，在media-service下新建包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.xuecheng.media.service.jobhandler</span><br></pre></td></tr></table></figure><p>，在该包下定义我们的任务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.media.service.jobhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;testJob&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始执行.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后进入调度中心添加任务，进入任务管理，新增任务信息<br><img src="/adanpro/adanblog/./../pic/202306160055168.png" alt="img"></p></li><li><p>其中JobHandler中填写@XxlJob注解中的名称</p></li><li><p>随后启动任务，控制台可以看到执行器的方法执行<br><img src="/adanpro/adanblog/./../pic/202306160055252.png" alt="img"></p></li></ul><h3 id="分片广播"><a href="#分片广播" class="headerlink" title="分片广播"></a>分片广播</h3><ul><li><p>前面我们了解了一下xxl-job的基本使用，下面思考如何进行分布式任务处理呢？</p><ul><li>我们需要启动多个执行器组成一个集群，去执行任务<br><img src="/adanpro/adanblog/./../pic/pSjh7QA.png" alt="img"></li></ul></li><li><p>执行器在集群部署下调度中心有哪些调度策略呢？</p><ul><li><p>查看xxl-job官方文档</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 高级配置：</span><br><span class="line">    - 路由策略：当执行器集群部署时，提供丰富的路由策略，包括；</span><br><span class="line">        - FIRST（第一个）：固定选择第一个机器；</span><br><span class="line">        - LAST（最后一个）：固定选择最后一个机器；</span><br><span class="line">        - ROUND（轮询）：；</span><br><span class="line">        - RANDOM（随机）：随机选择在线的机器；</span><br><span class="line">        - CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</span><br><span class="line">        - LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</span><br><span class="line">        - LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</span><br><span class="line">        - FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</span><br><span class="line">        - BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</span><br><span class="line">        - SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</span><br></pre></td></tr></table></figure></li></ul></li><li><p>我们这里重点要说的是<code>SHARDING_BROADCAST(分片广播)</code>，分片是指调度中心将集群汇总的执行器标上序号：0、1、2、3…，广播是指每次调度会向集群中的所有执行器发送调度请求，请求中携带分片参数<br><img src="/adanpro/adanblog/./../pic/202306160038663.png" alt="img"></p></li><li><p>每个执行器收到调度请求，根据分片参数自行决定是否执行任务</p></li><li><p>另外xxl-job还支持动态分片，当执行器数量有变更时，调度中心会动态修改分片的数量</p></li><li><p>作业分片适用于哪些场景呢？</p><ul><li>分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍</li><li>广播任务场景：广播执行器同时运行shell脚本、广播集群节点进行缓存更新等</li></ul></li><li><p>所以广播分片方式不仅可以充分发挥每个执行器的能力，并且根据分片参数可以控制任务是否执行，最终灵活控制了执行器集群的分布式处理任务</p></li><li><p>使用说明</p><ul><li><p>分片广播和普通任务开发流程一致，不同之处在于可以获取分片参数进行分片业务处理</p></li><li><p>获取分片参数方式，参考示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、分片广播任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">    XxlJobHelper.log(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shardTotal; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == shardIndex) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 命中分片开始处理&quot;</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 忽略&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>下面测试作业分片</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@XxlJob(&quot;shardingJobHandler&quot;)</span><br><span class="line">public void shardingJob() &#123;</span><br><span class="line">    int shardIndex = XxlJobHelper.getShardIndex();</span><br><span class="line">    int shardTotal = XxlJobHelper.getShardTotal();</span><br><span class="line">    log.debug(&quot;shardIndex:&#123;&#125;, shardTotal:&#123;&#125;&quot;, shardIndex, shardTotal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在调度中心添加任务，注意路由策略选择分片广播</p><p><img src="/adanpro/adanblog/./../pic/202306160056689.png" alt="img"></p><ul><li>高级配置说明<ul><li>子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度，通过子任务可以实现一个任务执行完成去执行另一个任务。<ul><li>调度过期策略：<ul><li>忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；</li><li>立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；</li></ul></li><li>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；<ul><li>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</li><li>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</li><li>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</li></ul></li><li>任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；</li><li>失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；</li></ul></li></ul></li></ul></li><li><p>下面我们需要启动两个执行器实例，观察每个实例的执行情况</p></li><li><p>首先我们需要在nacos中编辑media-service的配置，设置本地配置优先</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">   config:</span><br><span class="line">    override-none: true</span><br></pre></td></tr></table></figure></li><li><p>将media-service启动两个实例，添加的vm选项就是用本地配置覆盖nacos中的配置，主要是修改端口号和xxl执行器端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dserver.port=53051 -Dxxl.job.executor.port=9998  对应如下配置项</span><br><span class="line">server: </span><br><span class="line">  port: 53051</span><br><span class="line">xxl:</span><br><span class="line">  job:</span><br><span class="line">    executor:</span><br><span class="line">      port: 9998</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/202306160038759.png" alt="img"></p></li><li><p>将两个服务启动，观察任务调度中心，可以看到有两个执行器<br><img src="/adanpro/adanblog/./../pic/202306160056615.png" alt="img"></p></li><li><p>启动任务，可以从日志中看到，两个实例的分片序号不同</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 实例1</span><br><span class="line">[SimpleJob.java:25] - shardIndex:0, shardTotal:2</span><br><span class="line"></span><br><span class="line"># 实例2</span><br><span class="line">[SimpleJob.java:25] - shardIndex:1, shardTotal:2</span><br></pre></td></tr></table></figure></li><li><p>到此作业分片任务调试完成，此时我们来思考一下</p><ul><li>当一次分片广播到来，各执行器如何根据分片参数去分布式执行任务，保证执行器之间执行的任务不重复呢？</li></ul></li></ul><h2 id="需求分析-3"><a href="#需求分析-3" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="作业分片方案"><a href="#作业分片方案" class="headerlink" title="作业分片方案"></a>作业分片方案</h3><ul><li>任务添加成功后，对于要处理的任务，会添加到待处理任务表中，现在启动多个执行器实例去查询这些待处理任务，此时如何保证多个执行器不会重复执行任务？<br><img src="/adanpro/adanblog/./../pic/202306160057472.png" alt="img"></li><li>在上一小节的测试中，每个执行器收到广播任务有两个参数，分片序号和分片总数<ul><li>每个执行器从数据表取任务时，可以用<code>任务id</code>对<code>分片总数</code>取<code>模</code>，如果等于该执行器的分片序号，则执行此任务</li><li>例如<ul><li>1 % 2 &#x3D; 1，执行器2执行</li><li>2 % 2 &#x3D; 0，执行器1执行</li><li>3 % 2 &#x3D; 1，执行器2执行</li><li>4 % 2 &#x3D; 1，执行器1执行</li><li>以此类推</li></ul></li></ul></li></ul><h3 id="保证任务不重复执行"><a href="#保证任务不重复执行" class="headerlink" title="保证任务不重复执行"></a>保证任务不重复执行</h3><ul><li><p>通过作业分片方案，保证了执行器之间分配的任务不重复执行</p></li><li><p>但是如果同一个执行器，在处理一个视频的时候，还没有处理完，此时调度中心又来了一次请求调度，为了不重复处理同一个视频，该怎么办？</p></li><li><p>首先配置调度过期策略</p><ul><li>调度过期策略：<ul><li>忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；</li><li>立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；</li></ul></li></ul></li><li><p>这里我们选择<code>忽略</code>，如果立即执行一次，可能会重复调度</p></li><li><p>其次，我们在看阻塞处理策略。</p></li><li><p>阻塞处理策略就是当前执行器正在执行任务还没有结束时，调度中心又请求调度，此时该如何处理</p><ul><li>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；<ul><li>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；</li><li>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</li><li>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</li></ul></li></ul></li><li><p>这里选择<code>丢弃后续调度</code>，避免重复调度</p></li><li><p>最后，也就是要注意保证任务处理的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">幂等性</span><br></pre></td></tr></table></figure><p>，什么是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务的幂等性</span><br></pre></td></tr></table></figure><p>？</p><ul><li>任务的幂等性是指：对于数据的操作不论多少次，操作的结果始终是一致的。</li></ul></li><li><p>执行器接收调度请求去执行任务，要有办法去判断该任务是否处理完成，如果处理完则不再处理，即使重复调度处理相同的任务也不能重复处理相同的视频。</p></li><li><p>什么是幂等性？</p><ul><li>它描述了一次和多次请求某一个资源，对于资源本身应该具有相同的结果</li></ul></li><li><p>幂等性是为了解决重复提交问题，比如：恶意刷单、重复支付等</p></li><li><p>解决幂等性常用的方案</p><ol><li>数据库约束，例如：唯一索引、主键</li><li>乐观锁，长用户数据库，更新数据时根据乐观锁状态去更新</li><li>唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等，则执行</li></ol></li><li><p>这里我们在数据库视频处理表中添加状态处理字段，视频处理完成更新状态为完成，执行视频前判断状态是否完成，如果完成则不再处理</p></li></ul><h3 id="业务流程-2"><a href="#业务流程-2" class="headerlink" title="业务流程"></a>业务流程</h3><ul><li><p>确定了分片方案，下面梳理哼歌视频上传以及处理的业务流程<br><img src="/adanpro/adanblog/./../pic/202306160109212.png" alt="image-20230616010916018"></p></li><li><p>上传视频成功，向视频待处理表中添加记录，视频处理的详细流程如下</p><p><img src="/adanpro/adanblog/./../pic/202306160109375.png" alt="img"></p></li></ul><ol><li>任务调度中心广播作业分片</li><li>执行器收到广播作业分片，从数据库读取待处理任务</li><li>执行器根据任务内容MinIO下载要处理的文件</li><li>执行器启动多线程去处理任务</li><li>任务处理完成，上传处理后的视频到MinIO</li><li>将更新任务处理结果，如果视频处理完成，除了更新任务处理结果之外，还要将文件的访问地址更新至任务处理表及文件中，最后将任务完成记录写入历史表</li></ol><ul><li>下面是待处理任务表<img src="/adanpro/adanblog/./../pic/pSva4sJ.png" alt="img"></li></ul><h2 id="查询待处理任务"><a href="#查询待处理任务" class="headerlink" title="查询待处理任务"></a>查询待处理任务</h2><h3 id="添加待处理任务"><a href="#添加待处理任务" class="headerlink" title="添加待处理任务"></a>添加待处理任务</h3><ul><li>上传视频成功，向视频处理待处理表添加记录，暂时只添加.avi类型视频的处理记录</li><li>根据Mime Type去判断，是否为avi视频，下面列出部分Mime Type</li></ul><table><thead><tr><th align="center">Video Type</th><th align="center">Extension</th><th align="center">MIME Type</th></tr></thead><tbody><tr><td align="center">Flash</td><td align="center">fl</td><td align="center">video&#x2F;x-flv</td></tr><tr><td align="center">MPEG-4</td><td align="center">.mp4</td><td align="center">video&#x2F;mp4</td></tr><tr><td align="center">iPhone Index</td><td align="center">.m3u8</td><td align="center">application&#x2F;x-mpegURL</td></tr><tr><td align="center">iPhone Segment</td><td align="center">.ts</td><td align="center">video&#x2F;MP2T</td></tr><tr><td align="center">3GP Mobile</td><td align="center">.3gp</td><td align="center">video&#x2F;3gpp</td></tr><tr><td align="center">QuickTime</td><td align="center">.mov</td><td align="center">video&#x2F;quicktime</td></tr><tr><td align="center">A&#x2F;V Interleave</td><td align="center">.avi</td><td align="center">video&#x2F;x-msvideo</td></tr><tr><td align="center">Windows Media</td><td align="center">.wmv</td><td align="center">video&#x2F;x-ms-wmv</td></tr></tbody></table><ul><li><p>avi视频的Mine Type是video&#x2F;x-msvideo</p></li><li><p>修改addMediaFilesToDB方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文件信息添加到文件表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> companyId           机构id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uploadFileParamsDto 上传文件的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName          对象名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileMD5             文件的md5码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket              桶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> MediaFiles <span class="title function_">addMediaFilesToDB</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, String objectName, String fileMD5, String bucket)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据文件名获取Content-Type</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> getContentType(objectName);</span><br><span class="line">        <span class="comment">// 保存到数据库</span></span><br><span class="line">        <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> mediaFilesMapper.selectById(fileMD5);</span><br><span class="line">        <span class="keyword">if</span> (mediaFiles == <span class="literal">null</span>) &#123;</span><br><span class="line">            mediaFiles = <span class="keyword">new</span> <span class="title class_">MediaFiles</span>();</span><br><span class="line">            BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles);</span><br><span class="line">            mediaFiles.setId(fileMD5);</span><br><span class="line">            mediaFiles.setFileId(fileMD5);</span><br><span class="line">            mediaFiles.setCompanyId(companyId);</span><br><span class="line">            mediaFiles.setBucket(bucket);</span><br><span class="line">            mediaFiles.setCreateDate(LocalDateTime.now());</span><br><span class="line">            mediaFiles.setStatus(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            mediaFiles.setFilePath(objectName);</span><br><span class="line">            <span class="keyword">if</span> (contentType.contains(<span class="string">&quot;image&quot;</span>) || contentType.contains(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">                mediaFiles.setUrl(<span class="string">&quot;/&quot;</span> + bucket + <span class="string">&quot;/&quot;</span> + objectName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查阅数据字典，002003表示审核通过</span></span><br><span class="line">            mediaFiles.setAuditStatus(<span class="string">&quot;002003&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> mediaFilesMapper.insert(mediaFiles);</span><br><span class="line">        <span class="keyword">if</span> (insert &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            XueChengPlusException.cast(<span class="string">&quot;保存文件信息失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">+       <span class="comment">// 如果是avi视频，则额外添加至视频待处理表</span></span><br><span class="line">+       <span class="keyword">if</span> (<span class="string">&quot;video/x-msvideo&quot;</span>.equals(contentType)) &#123;</span><br><span class="line">+           <span class="type">MediaProcess</span> <span class="variable">mediaProcess</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaProcess</span>();</span><br><span class="line">+           BeanUtils.copyProperties(mediaFiles, mediaProcess);</span><br><span class="line">+           mediaProcess.setStatus(<span class="string">&quot;1&quot;</span>); <span class="comment">// 未处理</span></span><br><span class="line">+           <span class="type">int</span> <span class="variable">processInsert</span> <span class="operator">=</span> mediaProcessMapper.insert(mediaProcess);</span><br><span class="line">+           <span class="keyword">if</span> (processInsert &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">+               XueChengPlusException.cast(<span class="string">&quot;保存avi视频到待处理表失败&quot;</span>);</span><br><span class="line">+           &#125;</span><br><span class="line">+       &#125;</span><br><span class="line">        <span class="keyword">return</span> mediaFiles;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询待处理任务-1"><a href="#查询待处理任务-1" class="headerlink" title="查询待处理任务"></a>查询待处理任务</h3><ul><li><p>如何保证查询到的待处理视频记录不重复？</p><ul><li><p>解决方案我们前面已经给出了，用<strong>任务id</strong>对<strong>分片总数</strong>取模，如果等于该执行器的<strong>分片序号</strong>，则执行，同时为了避免同一个任务被执行两次，我们需要额外指定任务状态为未处理，即</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status = 1</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> media_process <span class="keyword">WHERE</span> id <span class="operator">%</span> #&#123;shareTotal&#125; <span class="operator">=</span> #&#123;shareIndex&#125; <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> LIMIT #&#123;count&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写根据分片参数获取待处理任务的DAO方法，定义DAO接口如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据分片参数获取待处理任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shardTotal    分片总数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shardIndex    分片序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count         任务数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM media_process WHERE id % #&#123;shardTotal&#125; = #&#123;shardIndex&#125; AND status = &#x27;1&#x27; LIMIT #&#123;count&#125;&quot;)</span></span><br><span class="line">List&lt;MediaProcess&gt; <span class="title function_">selectListByShardIndex</span><span class="params">(<span class="meta">@Param(&quot;shardTotal&quot;)</span> <span class="type">int</span> shardTotal, <span class="meta">@Param(&quot;shardIndex&quot;)</span> <span class="type">int</span> shardIndex, <span class="meta">@Param(&quot;count&quot;)</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure></li><li><p>定义Service接口，查询待处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaFileProcessService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取待处理任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardIndex    分片序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardTotal    分片总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count         获取记录数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  待处理任务集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;MediaProcess&gt; <span class="title function_">getMediaProcessList</span><span class="params">(<span class="type">int</span> shardIndex, <span class="type">int</span> shardTotal, <span class="type">int</span> count)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaFileProcessServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MediaFileProcessService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaProcessMapper mediaProcessMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MediaProcess&gt; <span class="title function_">getMediaProcessList</span><span class="params">(<span class="type">int</span> shardIndex, <span class="type">int</span> shardTotal, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mediaProcessMapper.selectListByShardIndex(shardTotal, shardIndex, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更新任务状态"><a href="#更新任务状态" class="headerlink" title="更新任务状态"></a>更新任务状态</h2><ul><li><p>任务处理完成后，需要更新任务处理结果，任务执行成功，则更新视频的URL、及任务处理结果，将待处理任务记录删除，同时向历史任务表添加记录</p></li><li><p>定义Service接口，更新任务状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">saveProcessFinishStatus</span><span class="params">(Long taskId, String status, String fileId, String url, String errorMsg)</span>;</span><br></pre></td></tr></table></figure></li><li><p>Service接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveProcessFinishStatus</span><span class="params">(Long taskId, String status, String fileId, String url, String errorMsg)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询这个任务</span></span><br><span class="line">    <span class="type">MediaProcess</span> <span class="variable">mediaProcess</span> <span class="operator">=</span> mediaProcessMapper.selectById(taskId);</span><br><span class="line">    <span class="keyword">if</span> (mediaProcess == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;更新任务状态时，此任务：&#123;&#125;，为空&quot;</span>, taskId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LambdaQueryWrapper&lt;MediaProcess&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;MediaProcess&gt;().eq(MediaProcess::getId, taskId);</span><br><span class="line">    <span class="comment">// 如果任务失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;3&quot;</span>.equals(status)) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;任务失败：&#123;&#125;&quot;</span>, taskId);</span><br><span class="line">        <span class="type">MediaProcess</span> <span class="variable">mediaProcess_u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaProcess</span>();</span><br><span class="line">        mediaProcess_u.setStatus(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        mediaProcess_u.setErrormsg(errorMsg);</span><br><span class="line">        mediaProcess_u.setFinishDate(LocalDateTime.now());</span><br><span class="line">        mediaProcessMapper.update(mediaProcess_u, queryWrapper);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务成功，将其从待处理任务表中删除，同时新增历史处理表记录</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;2&quot;</span>.equals(status)) &#123;</span><br><span class="line">        mediaProcess.setStatus(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        mediaProcess.setUrl(url);</span><br><span class="line">        mediaProcess.setFinishDate(LocalDateTime.now());</span><br><span class="line">        mediaProcessMapper.update(mediaProcess, queryWrapper);</span><br><span class="line">        <span class="type">MediaProcessHistory</span> <span class="variable">mediaProcessHistory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaProcessHistory</span>();</span><br><span class="line">        <span class="comment">// 两张表的属性完全一致，直接拷贝</span></span><br><span class="line">        BeanUtils.copyProperties(mediaProcess, mediaProcessHistory);</span><br><span class="line">        <span class="comment">// 向历史处理表新增数据</span></span><br><span class="line">        mediaProcessHistoryMapper.insert(mediaProcessHistory);</span><br><span class="line">        <span class="comment">// 同时删除待处理任务表中的数据</span></span><br><span class="line">        mediaProcessMapper.deleteById(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="视频处理-1"><a href="#视频处理-1" class="headerlink" title="视频处理"></a>视频处理</h2><h3 id="什么是视频编码"><a href="#什么是视频编码" class="headerlink" title="什么是视频编码"></a>什么是视频编码</h3><ul><li><p>视频上传成功后，需要对视频进行转码处理</p></li><li><p>什么是视频编码？百度百科的定义如下</p><ul><li>所谓视频编码方式就是指通过压缩技术，将原始视频格式的文件转换成另一种视频格式文件的方式。视频流传输中最为重要的编解码标准有国际电联的H.261、H.263、H.264，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，此外在互联网上被广泛应用的还有Real-Networks的RealVideo、微软公司的WMV以及Apple公司的QuickTime等。</li></ul></li><li><p>首先我们要分清文件格式和编码格式</p><ul><li><code>文件格式</code>是指：<code>.mp4</code>、<code>.avi</code>、<code>.rmvb</code>等这些不同扩展名的视频文件的文件格式。视频文件的内容主要包括视频、音频，其文件格式是按照一定的编码格式去编码，并且按照该文件所规定的的封装格式，将视频、音频、字幕等信息封装到一起，播放器会根据他们的封装个事去提取出编码，然后由播放器解码，最终播放音视频</li><li><code>编码格式</code>是指：通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输。比如一个.avi的视频文件原来的编码是a，通过编码后编码格式变为b</li></ul></li><li><p>音视频编码格式种类繁多，主要由以下几类</p><ul><li><pre><code>MPEG系列<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （由ISO下属的MPEG开发）</span><br><span class="line"></span><br><span class="line">  - 视频编码方面主要是Mpeg1（VCD）、Mpeg2（DVD）、Mpeg4（divx，xvid）、Mpeg4 AVC</span><br><span class="line">  - 音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3（MP3）、MPEG-2 AAC 、MPEG-4 AAC</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  H.26X系列</span><br></pre></td></tr></table></figure>（由ITU主导，侧重网络传输，注意：只是视频编码）- 包括H.261、H.262、H.263、H.263+、H.263++、H.264</code></pre></li></ul></li><li><p>目前最常用的编码标准是</p><ul><li>视频：H.264</li><li>音频：AAC</li></ul></li></ul><h3 id="FFmpeg的基本使用"><a href="#FFmpeg的基本使用" class="headerlink" title="FFmpeg的基本使用"></a>FFmpeg的基本使用</h3><ul><li><p>我们将视频录制完成后，使用视频编码软件第视频进行编码，本项目使用FFmpeg对视频进行编码</p></li><li><p>什么是FFmpeg？</p><ul><li>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频&#x2F;视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。</li><li>FFmpeg在Linux平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括Windows、Mac OS X等。这个项目最早由Fabrice Bellard发起，2004年至2015年间由Michael Niedermayer主要负责维护。许多FFmpeg的开发人员都来自MPlayer项目，而且当前FFmpeg也是放在MPlayer项目组的服务器上。项目的名称来自MPEG视频编码标准，前面的”FF”代表”Fast Forward”。FFmpeg编码库可以使用GPU加速。</li></ul></li><li><p>下载：<a href="https://www.ffmpeg.org/download.html#build-windows">FFmpeg</a>，并将其加入环境变量</p></li><li><p>测试是否正常：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -v</span><br></pre></td></tr></table></figure></li><li><p>安装成功后，做一下简单测试，将.mp4文件转为.avi，再将.avi转为.gif等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 胶水.mp4 胶水.avi</span><br><span class="line"></span><br><span class="line">ffmpeg -i 胶水.avi 胶水.gif</span><br></pre></td></tr></table></figure></li><li><p>胶水是我家的猫猫</p></li></ul><h3 id="视频处理工具类"><a href="#视频处理工具类" class="headerlink" title="视频处理工具类"></a>视频处理工具类</h3><ul><li><p>导入黑马提供的工具类，将其拷贝至base工程</p></li><li><p>其中Mp4VideoUtil类是用于将视频转为mp4格式，是我们项目要使用的工具类</p></li><li><p>下面我们来简单了解一下该类的使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//ffmpeg的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ffmpeg_path</span> <span class="operator">=</span> <span class="string">&quot;D:\\SoftWare\\ffmpeg\\ffmpeg.exe&quot;</span>;<span class="comment">//ffmpeg的安装位置</span></span><br><span class="line">    <span class="comment">//源avi视频的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">video_path</span> <span class="operator">=</span> <span class="string">&quot;D:\\BaiduNetdiskDownload\\星际牛仔1998\\胶水.avi&quot;</span>;</span><br><span class="line">    <span class="comment">//转换后mp4文件的名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mp4_name</span> <span class="operator">=</span> <span class="string">&quot;胶水_mp4.mp4&quot;</span>;</span><br><span class="line">    <span class="comment">//转换后mp4文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mp4_path</span> <span class="operator">=</span> <span class="string">&quot;D:\\BaiduNetdiskDownload\\星际牛仔1998\\胶水_mp4.mp4&quot;</span>;</span><br><span class="line">    <span class="comment">//创建工具类对象</span></span><br><span class="line">    <span class="type">Mp4VideoUtil</span> <span class="variable">videoUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mp4VideoUtil</span>(ffmpeg_path,video_path,mp4_name,mp4_path);</span><br><span class="line">    <span class="comment">//开始视频转换，成功将返回success</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> videoUtil.generateMp4();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行main方法，最终在控制台输出<code>success</code>表示执行成功</p></li></ul><h3 id="任务类"><a href="#任务类" class="headerlink" title="任务类"></a>任务类</h3><ul><li><p>视频采用并发处理，每个视频使用一个线程去处理，每次处理的视频数量不要超过cpu核心数</p></li><li><p>所有视频处理完成后，结束本次执行，为了防止代码出现异常而无限等待，添加超时设置，到达超时时间还没有处理完成，仍结束任务</p></li><li><p>代码思路如下</p><ol><li>根据分片序号和分片总数，查询待处理任务</li><li>启动多线程去处理</li><li>将原始视频下载到本地</li><li>调用工具类将avi转为mp4</li><li>上传到MinIO</li><li>记录任务处理结果url</li></ol></li><li><p>定义任务类VideoTask如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoTask</span> &#123;</span><br><span class="line">    <span class="comment">// 从配置文件中获取ffmpeg的安装位置</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;videoprocess.ffmpegpath&#125;&quot;)</span></span><br><span class="line">    String ffmpegPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaProcessMapper mediaProcessMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaFileService mediaFileService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaFileProcessService mediaFileProcessService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(&quot;videoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">videoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 分片序号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">        <span class="comment">// 分片总数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">        <span class="comment">// 查询待处理任务，一次处理的任务数与cpu核心数相同</span></span><br><span class="line">        List&lt;MediaProcess&gt; mediaProcessList = mediaFileProcessService.getMediaProcessList(shardTotal, shardIndex, <span class="number">12</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(mediaProcessList.size());</span><br><span class="line">        <span class="comment">// 未查询到待处理任务，结束方法</span></span><br><span class="line">        <span class="keyword">if</span> (mediaProcessList == <span class="literal">null</span> || mediaProcessList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;查询到的待处理任务数为0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要处理的任务数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mediaProcessList.size();</span><br><span class="line">        <span class="comment">// 查询到任务，创建size个线程去处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(size);</span><br><span class="line">        mediaProcessList.forEach(mediaProcess -&gt; threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> mediaProcess.getStatus();</span><br><span class="line">            <span class="comment">// 避免重复执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;2&quot;</span>.equals(status)) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;该视频已经被处理，无需再次处理。视频信息：&#123;&#125;&quot;</span>, mediaProcess);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 桶</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> mediaProcess.getBucket();</span><br><span class="line">            <span class="comment">// 文件路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> mediaProcess.getFilePath();</span><br><span class="line">            <span class="comment">// 原始文件的md5</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileId</span> <span class="operator">=</span> mediaProcess.getFileId();</span><br><span class="line">            <span class="type">File</span> <span class="variable">originalFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">File</span> <span class="variable">mp4File</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将原始视频下载到本地，创建临时文件</span></span><br><span class="line">                originalFile = File.createTempFile(<span class="string">&quot;original&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 处理完成后的文件</span></span><br><span class="line">                mp4File = File.createTempFile(<span class="string">&quot;mp4&quot;</span>, <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理视频前创建临时文件失败&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                XueChengPlusException.cast(<span class="string">&quot;处理视频前创建临时文件失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mediaFileService.downloadFileFromMinio(originalFile, bucket, filePath);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;下载原始文件过程中出错：&#123;&#125;，文件信息：&#123;&#125;&quot;</span>, e.getMessage(), mediaProcess);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                XueChengPlusException.cast(<span class="string">&quot;下载原始文件过程出错&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用工具类将avi转为mp4</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Mp4VideoUtil</span> <span class="variable">videoUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mp4VideoUtil</span>(ffmpegPath, originalFile.getAbsolutePath(), mp4File.getName(), mp4File.getAbsolutePath());</span><br><span class="line">                <span class="comment">// 获取转换结果，转换成功返回success 转换失败返回错误信息</span></span><br><span class="line">                result = videoUtil.generateMp4();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理视频失败，视频地址：&#123;&#125;，错误信息：&#123;&#125;&quot;</span>, originalFile.getAbsolutePath(), e.getMessage());</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                XueChengPlusException.cast(<span class="string">&quot;处理视频失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 转换成功，上传到MinIO</span></span><br><span class="line">            <span class="comment">// 设置默认状态为失败</span></span><br><span class="line">            status = <span class="string">&quot;3&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;success&quot;</span>.equals(result)) &#123;</span><br><span class="line">                <span class="comment">// 根据文件md5，生成objectName</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> mediaFileService.getFilePathByMd5(fileId, <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mediaFileService.addMediaFilesToMinIO(mp4File.getAbsolutePath(), bucket, objectName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;上传文件失败：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                    XueChengPlusException.cast(<span class="string">&quot;上传文件失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理成功，将状态设为成功</span></span><br><span class="line">                status = <span class="string">&quot;2&quot;</span>;   </span><br><span class="line">                <span class="comment">// 拼接url，准备更新数据</span></span><br><span class="line">                url = <span class="string">&quot;/&quot;</span> + bucket + <span class="string">&quot;/&quot;</span> + objectName;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录任务处理结果url</span></span><br><span class="line">            mediaFileProcessService.saveProcessFinishStatus(mediaProcess.getId(), status, fileId, url, result);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">// 等待，为了防止无线等待，这里设置一个超时时间为30分钟（很充裕了），若到时间还未处理完，则结束任务</span></span><br><span class="line">        countDownLatch.await(<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在media-service-dev.yaml中新增配置，指定ffmpeg安装位置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">videoprocess:</span><br><span class="line">  ffmpegpath: D:\SoftWare\ffmpeg\ffmpeg.exe</span><br></pre></td></tr></table></figure></li></ul><h2 id="视频处理测试"><a href="#视频处理测试" class="headerlink" title="视频处理测试"></a>视频处理测试</h2><ul><li>进入xxl-job调度中心添加执行器和视频处理任务</li><li>在xxl-job配置任务调度策略<ul><li>配置阻塞处理策略为：丢弃后续调度</li><li>配置视频处理调度时间间隔不用根据视频处理时间去确定，可以配置的小一些<ul><li>如：5分钟，即使到达调度时间，如果视频没有处理完成，仍丢弃调度请求</li></ul></li></ul></li><li>配置完成后开始测试视频处理<ol><li>首先上传至少4个视频，非mp4格式</li><li>在xxl-job启动视频处理任务</li><li>观察媒资管理服务后台日志</li></ol></li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="XXL-JOB工作原理"><a href="#XXL-JOB工作原理" class="headerlink" title="XXL-JOB工作原理"></a>XXL-JOB工作原理</h3><ol><li><p>xxl-job的工作原理是什么？xxl-job是什么？</p><ul><li><p>xxl-job分布式任务调度服务由调度中心和执行器组成，调度中心负责按任务调度策略向执行器下发任务，执行器负责接收任务，执行任务</p><ol><li><p>首先部署并启动xxl-job调度中心（一个java工程，打成jar包可以放到虚拟机上运行）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar xxl-job-admin...  &amp; </span><br></pre></td></tr></table></figure></li><li><p>在微服务中添加xxl-job依赖，在微服务中配置执行器</p><ul><li>依赖</li><li>yml配置</li><li>配置类</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动微服务，执行器向调度中心上报自己</p></li><li><p>在微服务中写一个任务方法，并用xxl-job的注解去标记执行任务的方法名称</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;testJob&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始执行.......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在调度中心配置任务调度策略，调度策略就是每个多长时间执行，又或者是每天&#x2F;每月的固定时间去执行等</p></li><li><p>在调度中心启动任务</p></li><li><p>调度中心根据任务调度策略，到达时间就开始下发任务给执行器</p></li><li><p>执行器收到任务就开始执行任务</p></li></ol></li></ul></li><li><p>如何保证任务不重复执行？</p><ol><li>调度中心按<code>分片广播</code>的方式去下发任务</li><li>执行器收到作业分片广播的参数：分片总数(shardTotal)和分片序号(shardIndex)，计算<code>任务id % 分片总数</code>(taskId % shardTotal)，如果结果等于分片序号，就去执行这个任务(taskId % shardTotal &#x3D; shardIndex)。这样就可以保证不同的执行器执行不同的任务</li><li>配置调度过期策略为<code>忽略</code>，避免同一个执行器多次重复执行同一个任务</li><li>配置任务阻塞处理策略为<code>丢弃后续调度</code>，注意：丢弃也没事，下一次调度还可以执行</li><li>另外还要保证任务处理的幂等性，执行过的任务可以打一个状态标记已完成（上面的代码设置status&#x3D;2即为完成），下次再次调度该任务时，判断该任务已完成，就不再执行</li></ol></li><li><p>任务幂等性如何保证？</p><ul><li>幂等性描述的是依次和多次请求某一个资源，对于资源本身，应该返回同样的结果</li><li>幂等性是为了解决重复提交问题，例如：恶意刷单，重复支付等</li><li>解决幂等性的常用方案<ol><li>数据库约束，例如：唯一索引、主键</li><li>乐观锁：常用于数据库，更新数据时，根据乐观锁的状态去更新</li><li>唯一序列号，请求前生成的唯一序列号，携带序列号去请求，执行是在redis记录该序列号，用于表示该序列号请求已经执行过了，如果相同的序列号再次来执行，则说明是重复执行。这里的解决方式是在数据库中添加状态处理字段，视频处理完成，则更新该字段为已完成，执行视频处理之前判断状态是否为已完成，若已完成则不处理</li></ol></li></ul></li></ol><h1 id="绑定媒资-1"><a href="#绑定媒资-1" class="headerlink" title="绑定媒资"></a>绑定媒资</h1><h2 id="需求分析-4"><a href="#需求分析-4" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="业务流程-3"><a href="#业务流程-3" class="headerlink" title="业务流程"></a>业务流程</h3><ul><li>截至目前，媒资管理已经完成文件上传、视频处理等基本功能。那么本小节就来讲解课程计划绑定媒资文件</li><li>如何将课程计划绑定媒资文件呢？<ul><li>进入课程计划界面，在小节中点击<code>添加视频/文档/作业</code>按钮，输入关键字搜索，进行绑定即可</li></ul></li></ul><h3 id="数据模型-2"><a href="#数据模型-2" class="headerlink" title="数据模型"></a>数据模型</h3><ul><li>课程计划绑定媒资文件后，存储至<code>课程计划绑定媒资表</code>，即<code>teachplan_media</code>表中<br><img src="/adanpro/adanblog/./../pic/202306160058526.png" alt="img"></li></ul><h2 id="接口定义-3"><a href="#接口定义-3" class="headerlink" title="接口定义"></a>接口定义</h2><ul><li><p>根据业务流程，用户进入课程计划列表，首先确定向哪个课程计划添加视频，点击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加视频</span><br></pre></td></tr></table></figure><p>按钮后，用户选择视频，点击提交，前端以json格式请求以下参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请求网址: http:<span class="comment">//localhost:8601/api/content/teachplan/association/media</span></span><br><span class="line">请求方法: POST</span><br><span class="line">载荷：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mediaId&quot;</span>: <span class="string">&quot;a92da96ebcf28dfe194a1e2c393dd860&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fileName&quot;</span>: <span class="string">&quot;胶水.avi&quot;</span>,</span><br><span class="line">  <span class="string">&quot;teachplanId&quot;</span>: <span class="number">293</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从请求网址可以看出，该接口在内容管理模块提供，即在content-api中提供</p></li><li><p>请求方式为POST，那么我们定义一个DTO类用来接收请求参数，里面只包含载荷中的三个属性即可，在content-model中新建BindTeachplanMediaDto模型类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;BindTeachplanMediaDto&quot;, description = &quot;教学计划-媒资绑定DTO&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BindTeachplanMediaDto</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;媒资文件id&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String mediaId;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;媒资文件名称&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程计划标识&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> Long teachplanId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在content-api下的TeachplanController中定义接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程计划与媒资信息绑定&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/teachplan/association/media&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(<span class="meta">@RequestBody</span> BindTeachplanMediaDto bindTeachplanMediaDto)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口开发-3"><a href="#接口开发-3" class="headerlink" title="接口开发"></a>接口开发</h2><h3 id="DAO开发-3"><a href="#DAO开发-3" class="headerlink" title="DAO开发"></a>DAO开发</h3><ul><li>使用自动生成的TeachplanMedia的Mapper即可</li></ul><h3 id="Service开发-3"><a href="#Service开发-3" class="headerlink" title="Service开发"></a>Service开发</h3><ul><li><p>根据需求定义Service接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 教学计划绑定媒资信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bindTeachplanMediaDto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(BindTeachplanMediaDto bindTeachplanMediaDto)</span>;</span><br></pre></td></tr></table></figure></li><li><p>定义接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(BindTeachplanMediaDto bindTeachplanMediaDto)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">teachplanId</span> <span class="operator">=</span> bindTeachplanMediaDto.getTeachplanId();</span><br><span class="line">    <span class="comment">// 先根据请求参数查询出对应的教学计划teachplan</span></span><br><span class="line">    <span class="type">Teachplan</span> <span class="variable">teachplan</span> <span class="operator">=</span> teachplanMapper.selectById(teachplanId);</span><br><span class="line">    <span class="keyword">if</span> (teachplan == <span class="literal">null</span>) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;教学计划不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取教学计划的层级，只有第二层级允许绑定媒资信息（第二层级为小节，第一层级为章节）</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">grade</span> <span class="operator">=</span> teachplan.getGrade();</span><br><span class="line">    <span class="keyword">if</span> (grade != <span class="number">2</span>) &#123;</span><br><span class="line">        XueChengPlusException.cast(<span class="string">&quot;只有小节允许绑定媒资信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定媒资，如果之前已经绑定过了媒资，再次绑定时为更新（例如该小节已经绑定了 星际牛仔.avi，现在改绑为 胶水.avi，其实现方式为先删再增）</span></span><br><span class="line">    LambdaQueryWrapper&lt;TeachplanMedia&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;TeachplanMedia&gt;().eq(TeachplanMedia::getTeachplanId, teachplanId);</span><br><span class="line">    teachplanMediaMapper.delete(queryWrapper);</span><br><span class="line">    <span class="type">TeachplanMedia</span> <span class="variable">teachplanMedia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeachplanMedia</span>();</span><br><span class="line">    teachplanMedia.setTeachplanId(bindTeachplanMediaDto.getTeachplanId());</span><br><span class="line">    teachplanMedia.setMediaFilename(bindTeachplanMediaDto.getFileName());</span><br><span class="line">    teachplanMedia.setMediaId(bindTeachplanMediaDto.getMediaId());</span><br><span class="line">    teachplanMedia.setCourseId(teachplan.getCourseId());</span><br><span class="line">    teachplanMedia.setCreateDate(LocalDateTime.now());</span><br><span class="line">    teachplanMediaMapper.insert(teachplanMedia);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接口层完善-1"><a href="#接口层完善-1" class="headerlink" title="接口层完善"></a>接口层完善</h3><ul><li><p>调用service层的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程计划与媒资信息绑定&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/teachplan/association/media&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">associationMedia</span><span class="params">(<span class="meta">@RequestBody</span> BindTeachplanMediaDto bindTeachplanMediaDto)</span> &#123;</span><br><span class="line">    teachplanService.associationMedia(bindTeachplanMediaDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接口测试-2"><a href="#接口测试-2" class="headerlink" title="接口测试"></a>接口测试</h3><ul><li>向指定课程计划添加视频，成功添加后，再次添加视频，则会替换掉原有的视频<br><img src="/adanpro/adanblog/./../pic/202306160038991.png" alt="img"></li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul><li><p>根据接口定义实现解除绑定功能</p><ul><li>点击已经绑定的视频名称即可解除绑定</li></ul></li><li><p>接口定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">delete /teachplan/association/media/&#123;teachPlanId&#125;/&#123;mediaId&#125;</span><br></pre></td></tr></table></figure></li><li><p>在TeachplanController中定义接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程计划解除媒资信息绑定&quot;)</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/teachplan/association/media/&#123;teachPlanId&#125;/&#123;mediaId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unassociationMedia</span><span class="params">(<span class="meta">@PathVariable</span> Long teachPlanId, <span class="meta">@PathVariable</span> Long mediaId)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据需求定义Service接口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 解绑教学计划与媒资信息</span><br><span class="line"> * @param teachPlanId       教学计划id</span><br><span class="line"> * @param mediaId           媒资信息id</span><br><span class="line"> */</span><br><span class="line">void unassociationMedia(Long teachPlanId, Long mediaId);</span><br></pre></td></tr></table></figure></li><li><p>定义接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unassociationMedia</span><span class="params">(Long teachPlanId, Long mediaId)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;TeachplanMedia&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(TeachplanMedia::getTeachplanId, teachPlanId)</span><br><span class="line">            .eq(TeachplanMedia::getMediaId, mediaId);</span><br><span class="line">    teachplanMediaMapper.delete(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完善接口层，调用service层的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程计划解除媒资信息绑定&quot;)</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/teachplan/association/media/&#123;teachPlanId&#125;/&#123;mediaId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unassociationMedia</span><span class="params">(<span class="meta">@PathVariable</span> Long teachPlanId, <span class="meta">@PathVariable</span> String mediaId)</span> &#123;</span><br><span class="line">    teachplanService.unassociationMedia(teachPlanId, mediaId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> xcplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker操作文档</title>
      <link href="/adanpro/adanblog/2023/06/28/docker%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3/"/>
      <url>/adanpro/adanblog/2023/06/28/docker%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a><strong>docker安装</strong></h1><h2 id="1-卸载（可选）"><a href="#1-卸载（可选）" class="headerlink" title="1.卸载（可选）"></a>1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">yum</span> <span class="string">remove docker \</span></span><br><span class="line"><span class="string">                  docker-client \</span></span><br><span class="line"><span class="string">                  docker-client-latest \</span></span><br><span class="line"><span class="string">                  docker-common \</span></span><br><span class="line"><span class="string">                  docker-latest \</span></span><br><span class="line"><span class="string">                  docker-latest-logrotate \</span></span><br><span class="line"><span class="string">                  docker-logrotate \</span></span><br><span class="line"><span class="string">                  docker-selinux \</span></span><br><span class="line"><span class="string">                  docker-engine-selinux \</span></span><br><span class="line"><span class="string">                  docker-engine \</span></span><br><span class="line"><span class="string">                  docker-ce</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2.安装docker"></a>2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置docker镜像源</span></span><br><span class="line"><span class="attr">yum-config-manager</span> <span class="string">\</span></span><br><span class="line"><span class="string">    --add-repo \</span></span><br><span class="line"><span class="string">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">sed</span> <span class="string">-i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">yum</span> <span class="string">makecache fast</span></span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="3-启动docker"><a href="#3-启动docker" class="headerlink" title="3.启动docker"></a>3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，<strong>一定要关闭防火墙</strong>后！！</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment">#查看是否关闭防火墙</span></span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker  <span class="comment">## 1.4.启动docker服务</span></span><br><span class="line"> </span><br><span class="line">systemctl stop docker  <span class="comment">## 1.4.停止docker服务</span></span><br><span class="line"> </span><br><span class="line">systemctl restart docker  <span class="comment">## 1.4.重启docker服务</span></span><br></pre></td></tr></table></figure><p>查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h2 id="4-配置镜像加速"><a href="#4-配置镜像加速" class="headerlink" title="4.配置镜像加速"></a>4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><p><strong>创建文件夹</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br></pre></td></tr></table></figure><p><strong>在文件夹内新建一个daemon.json文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://akchsmlh.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><strong>重新加载文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p><strong>重启docker</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>可以看见，多了个&#x2F;etc&#x2F;docker&#x2F;daemon.json文件：</p><h2 id="5-设置开机启动docker"><a href="#5-设置开机启动docker" class="headerlink" title="5 设置开机启动docker"></a>5 设置开机启动docker</h2><p>1、查看已经启动的服务</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">list-units --type=service</span></span><br></pre></td></tr></table></figure><p>2、查看是否设置开机启动</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">list-unit-files | grep docker</span></span><br></pre></td></tr></table></figure><p>3、设置开机启动</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">enable docker.service</span></span><br></pre></td></tr></table></figure><p>4、启动时加–restart&#x3D;always</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">--restart</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure><p>设置容器自启</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">update --restart=always 容器名称</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">update --restart=always mysql nginx</span></span><br></pre></td></tr></table></figure><p>如果已经启动的项目，则使用update更新：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">update --restart=always nginx</span></span><br></pre></td></tr></table></figure><h1 id="Docker-配置Elasticsearch"><a href="#Docker-配置Elasticsearch" class="headerlink" title="Docker 配置Elasticsearch"></a>Docker 配置Elasticsearch</h1><p>Elasticsearch 可以通过命令行参数或者通过 Docker 卷来挂载配置、日志、数据和插件文件。以下是通过 Docker 卷挂载这些文件的步骤：</p><ol><li><p>首先创建一个目录来存储 Elasticsearch 的配置、日志、数据和插件文件，比如 <code>/opt/elasticsearch/data</code>。</p></li><li><p>将 Elasticsearch 的配置文件复制到该目录，如：<code>/opt/elasticsearch/data/elasticsearch.yml</code>。</p></li><li><p>创建一个子目录，用于存储 Elasticsearch 的日志文件，如：<code>/opt/elasticsearch/data/logs</code>。</p></li><li><p>创建另一个子目录，用于存储 Elasticsearch 的数据文件，如：<code>/opt/elasticsearch/data/data</code>。</p></li><li><p>创建另一个子目录，用于存储 Elasticsearch 的插件文件，如：<code>/opt/elasticsearch/data/plugins</code>。</p></li><li><p>运行以下命令来启动 Elasticsearch 容器，并将数据、日志、配置和插件目录都挂载到容器中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name es \</span><br><span class="line"> -p 9200:9200 \</span><br><span class="line"> -p 9300:9300 \</span><br><span class="line"> -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line"> -e ES_JAVA_OPTS=<span class="string">&quot;-Xms256m -Xmx256m&quot;</span> \</span><br><span class="line"> -v /docker/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line"> -v /docker/elasticsearch/data/:/usr/share/elasticsearch/data \</span><br><span class="line"> -v /docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line"> --privileged \</span><br><span class="line"> --network es-net \</span><br><span class="line"> -d elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><ul><li>-e “cluster.name&#x3D;es-docker-cluster”：设置集群名称</li><li>-e “http.host&#x3D;0.0.0.0”：监听的地址，可以外网访问</li><li>-e “ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m”：内存大小</li><li>-e “discovery.type&#x3D;single-node”：非集群模式</li><li>-v &#x2F;mydata&#x2F;elasticsearch&#x2F;data&#x2F;:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data：挂载逻辑卷，绑定es的数据目录</li><li>-v &#x2F;mydata&#x2F;elasticsearch&#x2F;logs&#x2F;:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;logs：挂载逻辑卷，绑定es的日志目录</li><li>-v &#x2F;mydata&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins：挂载逻辑卷，绑定es的插件目录</li><li>–privileged：授予逻辑卷访问权</li><li>–network es-net ：加入一个名为es-net的网络中</li><li>-p 9200:9200：端口映射配置，这里是9200是暴露的http协议端口，用于用户访问</li><li>-p 9300:9300：es各个容器之间互联的端口，暂时用不到，不暴露也行，</li></ul></li><li><p>运行命令 <code>docker ps</code> 来确认 Elasticsearch 容器已经启动。</p></li></ol><p>​docker以挂载配置文件启动elasticsearch的时候会报如下错误：</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-1.png" alt="img"></p><p>看错误我们会以为是es容器里的&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data&#x2F;nodes文件夹目录没有读写权限，其实给提示误导了，实际是挂载的目录没有读写权限。比如我们宿主主机的配置目录为:&#x2F;usr&#x2F;local&#x2F;es&#x2F;data，那么我们需要赋予它读写权限：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">chmod</span> <span class="string">777 /usr/local/es/data</span></span><br></pre></td></tr></table></figure><p>重新启动，问题不再存在。</p><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><p>Kibana 可以使用命令行参数或者通过 Docker 卷来挂载配置文件。以下是通过 Docker 卷挂载配置文件的步骤：</p><ol><li><p>首先创建一个配置文件目录，如：<code>/docker/kibana/config</code>。</p></li><li><p>将 Kibana 的配置文件复制到该目录中，如：<code>/docker/kibana/config/kibana.yml</code>。</p></li><li><p>使用以下命令来运行 Kibana，同时将配置文件目录挂载到容器中：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run -d \</span></span><br><span class="line"><span class="string">--name kibana \</span></span><br><span class="line"><span class="string">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span></span><br><span class="line"><span class="string">--network=es-net \</span></span><br><span class="line"><span class="string">-p 5601:5601  \</span></span><br><span class="line"><span class="string">kibana:7.12.1</span></span><br></pre></td></tr></table></figure><p>上述命令会将本地目录 <code>/opt/kibana/config</code> 挂载到容器内的 <code>/usr/share/kibana/config</code>，以便 Kibana 能够访问该目录下的配置文件。</p><ul><li>–network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li>-e ELASTICSEARCH_HOSTS&#x3D;<a href="http://es:9200"：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch">http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</a></li><li>-p 5601:5601：端口映射配置</li><li>运行命令 <code>docker ps</code> 来确认 Kibana 容器已经启动。</li><li>访问 <code>http://localhost:5601</code> 来验证 Kibana 是否能够正常访问并加载配置文件。</li></ul></li></ol><h2 id="Kibana中文配置"><a href="#Kibana中文配置" class="headerlink" title="Kibana中文配置"></a>Kibana中文配置</h2><p>我们发现<code>Kibana</code>是英文面板，看起来不是很方便，但<code>Kibana</code>是支持中文配置，所以我们可以把<code>Kibana</code>配置成中文版，便于我们操作。</p><p>切换中文操作如下:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码#进入容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">exec -it kibana /bin/bash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#进入配置文件目录</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">/usr/share/kibana/config</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#编辑文件kibana.yml</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">kibana.yml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#在最后一行添加如下配置</span></span><br><span class="line"><span class="attr">i18n.locale</span>: <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保存退出</span></span><br><span class="line"><span class="attr">exit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#并重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart kibana</span></span><br></pre></td></tr></table></figure><h2 id="IK分词器安装"><a href="#IK分词器安装" class="headerlink" title="IK分词器安装"></a>IK分词器安装</h2><p>我们打开<code>Kibana</code>，点击开发工具，操作如下：</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-2.png" alt="img"></p><p>输入如下操作，用于查询分词：</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-3.png" alt="img"></p><p>上图测试代码如下:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;IT门徒，带你打开通往梦想的门！&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>表示使用<code>standard</code>对<code>IT门徒，带你打开通往梦想的门！</code>进行分词。</p><p><code>分词</code>：提取一句话或者一篇文章中的词语。</p><p>我们在使用<code>ElasticSearch</code>的时候，默认用<code>standard</code>分词器，但<code>standard</code>分词器使用的是按空格分词，这种分词操作方法不符合中文分词标准，我们需要额外安装中文分词器。</p><p> </p><h3 id="IK分词器介绍"><a href="#IK分词器介绍" class="headerlink" title="IK分词器介绍"></a>IK分词器介绍</h3><p><code>IK Analyzer</code>是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始， <code>IKAnalyzer</code>已经推出了多个大版本。最初，它是以开源项目<code>Luence</code>为应用主体的，结合词典分词和文法分析算法的中文分词组件。<code>IK Analyzer</code>则发展为面向<code>Java</code>的公用分词组件，独立于<code>Lucen</code>e项目，同时提供了对<code>Lucene</code>的默认优化实现。</p><h3 id="IK分词器下载"><a href="#IK分词器下载" class="headerlink" title="IK分词器下载"></a>IK分词器下载</h3><h3 id="下载方式一"><a href="#下载方式一" class="headerlink" title="下载方式一"></a><strong>下载方式一</strong></h3><p><strong>离线安装ik插件（推荐）</strong></p><p><code>ElasticSearch</code>内核其实就是基于<code>Lucene</code>，所以我们可以直接在<code>ElasticSearch</code>中集成IK分词器，<code>IK</code>分词器集成<code>ElasticSearch</code>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/pic/1687790038060-4.png)">https://github.com/medcl/elasticsearch-analysis-ik/releases![img](./../pic/1687790038060-4.png)</a></p><p><strong>查看数据卷目录(已经挂载指定数据卷无需查看)</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">volume inspect es</span></span><br></pre></td></tr></table></figure><p>显示结果： </p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2022-05-06T10:06:34+08:00&quot;,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span>: <span class="string">null,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;es-plugins&quot;,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span>: <span class="string">null,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">]</span></span><br></pre></td></tr></table></figure><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data</code>这个目录中。</p><p>2）解压缩分词器安装包</p><p>下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-5.png" alt="img"></p><p>3）上传到es容器的插件数据卷中</p><p>也就是&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;es-plugins&#x2F;_data：</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-6.png" alt="img"></p><p>4）重启容器</p><p><strong>已经挂载指定数据卷</strong></p><p><img src="/adanpro/adanblog/./../pic/1687790038060-7.png" alt="img"></p><p>进入挂载目录，上传ik分词器</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-8.png" alt="img"></p><p><strong>重启es服务</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">restart es</span></span><br></pre></td></tr></table></figure><p><strong>查看es日志</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">logs -f es</span></span><br></pre></td></tr></table></figure><h3 id="下载方式二"><a href="#下载方式二" class="headerlink" title="下载方式二"></a><strong>下载方式二</strong></h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在线下载并安装</span></span><br><span class="line"><span class="attr">./bin/elasticsearch-plugin</span>  <span class="string">install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span></span><br></pre></td></tr></table></figure><h3 id="下载方式三"><a href="#下载方式三" class="headerlink" title="下载方式三"></a><strong>下载方式三</strong></h3><p>下载安装包<code>elasticsearch-analysis-ik-7.12.1.zip</code>后，并解压，目录如下：</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-9.png" alt="img"></p><p>我们只需要将上面<code>elasticsearch-analysis-ik-7.12.1</code>拷贝到<code>ElasticSearch</code>的<code>plugins</code>目录中即可，但由于当前服务采用的是<code>docker</code>安装，所以需要将文件拷贝到<code>docker</code>容器的<code>plugins</code>目录才行。</p><p>操作如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码#为了方便配置，我们将elasticsearch-analysis-ik-7.12.1改成ik文件夹</span></span><br><span class="line"><span class="attr">mv</span> <span class="string">elasticsearch-analysis-ik-7.12.1 ik</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#将ik文件夹拷贝到elasticsearch容器中</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp ik elasticsearch:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br></pre></td></tr></table></figure><p>操作效果如下：</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-11.png" alt="img"></p><p> </p><h3 id="分词测试"><a href="#分词测试" class="headerlink" title="分词测试"></a>分词测试</h3><p><code>IK</code>分词器包含两种模式：</p><ul><li><code>ik_smart</code>：最少切分</li><li><code>ik_max_word</code>：最细切分</li></ul><p> </p><p>前面使用默认的<code>standard</code>分词器，对中文分词非常难用，安装IK分词器后，我们可以使用IK分词器测试，测试代码如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;IT门徒，带你打开通往梦想的门！&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>测试效果如下：</p><p><img src="/adanpro/adanblog/./../pic/1687790038060-10.png" alt="img"></p><p>我们可以发现对中文的分词效果是比较不错的，但也存在一些不足，比如<code>梦想的门</code>我们希望它是一个词，而<code>带你</code>我们希望它不被识别一个词，又该如何实现呢？</p><p> </p><h3 id="IK扩展词词典"><a href="#IK扩展词词典" class="headerlink" title="IK扩展词词典"></a>IK扩展词词典</h3><p>IK分词器支持自定义词典，包括自定义分词，也包含自定义停用分词，操作起来也非常简单。我们接下来实现一下自定义词典和停用词典。</p><p> 1）打开IK分词器config目录：</p><p><img src="/adanpro/adanblog/./../pic/16877900380620.png" alt="img"></p><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;?xml</span> <span class="string">version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="attr">&lt;!DOCTYPE</span> <span class="string">properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span></span><br><span class="line"><span class="attr">&lt;properties&gt;</span></span><br><span class="line">        <span class="attr">&lt;comment&gt;IK</span> <span class="string">Analyzer 扩展配置&lt;/comment&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--用户可以在这里配置自己的扩展字典</span> <span class="string">*** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="attr">&lt;entry</span> <span class="string">key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;</span></span><br><span class="line"><span class="attr">&lt;/properties&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）在<code>config</code>中创建自己的词典, 新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">传智播客</span></span><br><span class="line"><span class="attr">奥力给</span></span><br></pre></td></tr></table></figure><p><strong>4）重启elasticsearch</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">restart es</span></span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">logs -f elasticsearch</span></span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../../../blog02/pic/1687790038060.png" alt="img"></p><p>日志中已经成功加载ext.dic配置文件</p><p>5）测试效果：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;传智播客Java就业超过90%,奥力给！&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p><h3 id="停用词词典"><a href="#停用词词典" class="headerlink" title="停用词词典"></a>停用词词典</h3><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p><p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p><p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;?xml</span> <span class="string">version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="attr">&lt;!DOCTYPE</span> <span class="string">properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span></span><br><span class="line"><span class="attr">&lt;properties&gt;</span></span><br><span class="line">        <span class="attr">&lt;comment&gt;IK</span> <span class="string">Analyzer 扩展配置&lt;/comment&gt;</span></span><br><span class="line">        <span class="attr">&lt;!--用户可以在这里配置自己的扩展字典--&gt;</span></span><br><span class="line">        <span class="attr">&lt;entry</span> <span class="string">key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;</span></span><br><span class="line">         <span class="attr">&lt;!--用户可以在这里配置自己的扩展停止词字典</span>  <span class="string">*** 添加停用词词典--&gt;</span></span><br><span class="line">        <span class="attr">&lt;entry</span> <span class="string">key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;</span></span><br><span class="line"><span class="attr">&lt;/properties&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;properties&gt;</span></span><br><span class="line"><span class="attr">&lt;comment&gt;IK</span> <span class="string">Analyzer 扩展配置&lt;/comment&gt;</span></span><br><span class="line"><span class="attr">&lt;!--用户可以在这里配置自己的扩展字典</span> <span class="string">--&gt;</span></span><br><span class="line"><span class="attr">&lt;entry</span> <span class="string">key=&quot;ext_dict&quot;&gt;itmentu_ext.dic&lt;/entry&gt;</span></span><br><span class="line"> <span class="attr">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="attr">&lt;entry</span> <span class="string">key=&quot;ext_stopwords&quot;&gt;itmentu_stop.dic&lt;/entry&gt;</span></span><br><span class="line"><span class="attr">&lt;!--用户可以在这里配置远程扩展字典</span> <span class="string">--&gt;</span></span><br><span class="line"><span class="attr">&lt;!--</span> <span class="string">&lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="attr">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line"><span class="attr">&lt;!--</span> <span class="string">&lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="attr">&lt;/properties&gt;</span></span><br></pre></td></tr></table></figure><p>3）在 stopword.dic 添加停用词</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">只因你太美</span></span><br></pre></td></tr></table></figure><p><strong>4）重启elasticsearch</strong></p><p>重启服务</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart kibana</span></span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">logs -f elasticsearch</span></span><br></pre></td></tr></table></figure><p>日志中已经成功加载stopword.dic配置文件</p><p><strong>5）测试效果：</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;只因你太美都点赞,奥力给！&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</strong></p><h1 id="部署es集群"><a href="#部署es集群" class="headerlink" title="部署es集群"></a>部署es集群</h1><p>部署es集群可以直接使用docker-compose来完成，不过要求你的Linux虚拟机至少有4G的内存空间</p><p>首先编写一个docker-compose文件，内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">version</span>: <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">es01</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">image</span>: <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name</span>: <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">memlock</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">soft</span>: <span class="string">-1</span></span><br><span class="line">        <span class="attr">hard</span>: <span class="string">-1</span></span><br><span class="line">    <span class="attr">volumes</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">9200:9200</span></span><br><span class="line">    <span class="attr">networks</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">image</span>: <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name</span>: <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">memlock</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">soft</span>: <span class="string">-1</span></span><br><span class="line">        <span class="attr">hard</span>: <span class="string">-1</span></span><br><span class="line">    <span class="attr">volumes</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">image</span>: <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name</span>: <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="attr">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">memlock</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">soft</span>: <span class="string">-1</span></span><br><span class="line">        <span class="attr">hard</span>: <span class="string">-1</span></span><br><span class="line">    <span class="attr">volumes</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">data01</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">driver</span>: <span class="string">local</span></span><br><span class="line">  <span class="attr">data02</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">driver</span>: <span class="string">local</span></span><br><span class="line">  <span class="attr">data03</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">driver</span>: <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">elastic</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">driver</span>: <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>Run docker-compose to bring up the cluster:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker-compose</span> <span class="string">up</span></span><br></pre></td></tr></table></figure><h1 id="搭建-Minio-容器"><a href="#搭建-Minio-容器" class="headerlink" title="搭建 Minio 容器"></a>搭建 Minio 容器</h1><h3 id="下载Minio镜像"><a href="#下载Minio镜像" class="headerlink" title="下载Minio镜像"></a>下载Minio镜像</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>docker pull minio&#x2F;minio</td><td>下载最新版Minio镜像 (其实此命令就等同于 : docker pull minio&#x2F;minio:latest )</td></tr><tr><td>docker pull minio&#x2F;minio:RELEASE.2022-06-20T23-13-45Z.fips</td><td>下载指定版本的Minio镜像 (xxx指具体版本号)</td></tr></tbody></table><p> 检查当前所有<strong>Docker</strong>下载的镜像</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">images</span></span><br></pre></td></tr></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>一个用来存放配置，一个用来存储上传文件的目录</p><p>启动前需要先创建Minio外部挂载的配置文件（ &#x2F;home&#x2F;minio&#x2F;config）,和存储上传文件的目录（ &#x2F;home&#x2F;minio&#x2F;data）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/minio/config</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/minio/data</span></span><br></pre></td></tr></table></figure><h3 id="创建Minio容器并运行"><a href="#创建Minio容器并运行" class="headerlink" title="创建Minio容器并运行"></a>创建Minio容器并运行</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run -p 9000:9000 -p 9090:9090 \</span></span><br><span class="line"><span class="string">     --name minio \</span></span><br><span class="line"><span class="string">     -d --restart=always \</span></span><br><span class="line"><span class="string">     -e &quot;MINIO_ACCESS_KEY=minioadmin&quot; \</span></span><br><span class="line"><span class="string">     -e &quot;MINIO_SECRET_KEY=minioadmin&quot; \</span></span><br><span class="line"><span class="string">     -v /docker/minio/data:/data \</span></span><br><span class="line"><span class="string">     -v /docker/minio/config:/root/.minio \</span></span><br><span class="line"><span class="string">     minio/minio server \</span></span><br><span class="line"><span class="string">     /data --console-address &quot;:9090&quot; -address &quot;:9000&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>-p 9000:9000 -p 9090:9090</code>：将容器内部的 9000 和 9090 端口映射到主机的对应端口。</p></li><li><p>新版minio有两个端口注意 9000给客户端使用,9090登录服务端使用</p></li><li><p>这两个端口一个是给接口调用的，还有一个就是浏览器访问的</p></li><li><p>-p 9000:9000：MinIO 服务会暴露 9000 端口来对外提供对象访问，也就是通过此端口运行的服务来访问资源</p></li><li><p>-p 9090:9090：MinIO 服务会提供一个可视化管理系统，默认在 9001 端口运行</p></li><li><p><code>--net=host</code>：使用主机的网络模式，这个选项会让容器使用主机的 IP 地址。</p></li><li><p><code>--name minio</code>：将容器命名为 minio。</p></li><li><p><code>-d</code>：以后台模式运行容器。</p></li><li><p><code>--restart=always</code>：容器退出时自动重启。</p></li><li><p><code>-e &quot;MINIO_ACCESS_KEY=minioadmin&quot;</code>：设置 MinIO 的 access key。</p></li><li><p><code>-e &quot;MINIO_SECRET_KEY=minioadmin&quot;</code>：设置 MinIO 的 secret key。</p></li><li><p><code>-v /home/minio/data:/data</code>：将本地的 <code>/home/minio/data</code> 目录挂载到容器中的 <code>/data</code> 目录。</p></li><li><p><code>-v /home/minio/config:/root/.minio</code>：将本地的 <code>/home/minio/config</code> 目录挂载到容器中的 <code>/root/.minio</code> 目录，用于存储 MinIO 的配置文件。</p></li><li><p><code>minio/minio server /data</code>：指定使用 MinIO 的镜像，并以 <code>/data</code> 目录作为数据目录启动 MinIO 服务。</p></li><li><p><code>--console-address &quot;:9090&quot; -address &quot;:9000&quot;</code>：分别指定在主机上监听的控制台地址和 MinIO 服务地址。</p></li><li><p><code>--console-address</code> 和 <code>-address</code> 选项用于指定 MinIO 控制台和服务的监听地址和端口。具体含义如下：</p><ul><li><code>--console-address &quot;:9090&quot;</code>：指定控制台的监听地址和端口，冒号后面为空表示使用默认的 IP 地址（0.0.0.0），端口号为 9090。这个地址和端口用于访问 MinIO 控制台。</li><li><code>-address &quot;:9000&quot;</code>：指定 MinIO 服务的监听地址和端口，冒号后面为空表示使用默认的 IP 地址（0.0.0.0），端口号为 9000。这个地址和端口用于访问 MinIO 服务。</li></ul><p>在这个命令中，控制台地址和端口为 <code>:9090</code>，服务地址和端口为 <code>:9000</code>，分别表示使用默认的 IP 地址 0.0.0.0。由于在命令中使用了 <code>-p</code> 选项将容器内部的端口映射到了主机上，所以实际访问时需要使用主机的 IP 地址和映射的端口。例如，在这个命令中将主机的 9000 端口映射到了容器的 9000 端口，所以需要通过 <code>http://your-server-ip:9000</code> 访问 MinIO 服务。</p></li></ul><h3 id="访问操作"><a href="#访问操作" class="headerlink" title="访问操作"></a>访问操作</h3><p>访问：<a href="http://192.168.124.132:9090/login">http://192.168.124.132:9090/login</a> 用户名：密码 <strong>minioadmin</strong>：<strong>minioadmin</strong></p><h1 id="Docker-安装Mysql"><a href="#Docker-安装Mysql" class="headerlink" title="Docker 安装Mysql"></a>Docker 安装Mysql</h1><h2 id="1、寻找Mysql镜像"><a href="#1、寻找Mysql镜像" class="headerlink" title="1、寻找Mysql镜像"></a>1、寻找Mysql镜像</h2><p>在<a href="https://so.csdn.net/so/search?q=Docker%E9%95%9C%E5%83%8F&spm=1001.2101.3001.7020">Docker镜像</a>仓库寻找Mysql镜像</p><p><a href="https://link.juejin.cn/?target=https://hub.docker.com/_/mysql">DockerHub–&gt;Mysql</a></p><h2 id="2、下载Mysql镜像"><a href="#2、下载Mysql镜像" class="headerlink" title="2、下载Mysql镜像"></a>2、下载Mysql镜像</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>docker pull mysql</td><td>下载最新版Mysql镜像 (其实此命令就等同于 : docker pull mysql:latest )</td></tr><tr><td>docker pull mysql:xxx</td><td>下载指定版本的Mysql镜像 (xxx指具体版本号)</td></tr></tbody></table><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">pull mysql:8.0</span></span><br></pre></td></tr></table></figure><blockquote><p> 检查当前所有Docker下载的镜像</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="3、创建目录"><a href="#3、创建目录" class="headerlink" title="3、创建目录"></a>3、创建目录</h2><p>一个用来存放配置，一个用来存储上传文件的目录</p><p>启动前需要先创建Minio外部挂载的配置文件（ &#x2F;home&#x2F;minio&#x2F;config）,和存储上传文件的目录（ &#x2F;home&#x2F;minio&#x2F;data）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/mysql/log</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/mysql/data</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/mysql/conf</span></span><br></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">vim</span> <span class="string">/docker/mysql/etc/my.cnf</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">bind-address</span>=<span class="string">0.0.0.0</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br><span class="line"><span class="comment">#user=mysql</span></span><br><span class="line"><span class="attr">character_set_server</span>=<span class="string">utf8mb4</span></span><br><span class="line"><span class="attr">collation-server</span>=<span class="string">utf8mb4_general_ci</span></span><br><span class="line"><span class="attr">symbolic-links</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">explicit_defaults_for_timestamp</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER</span></span><br><span class="line"><span class="attr">max-connections</span> = <span class="string">1000</span></span><br><span class="line"><span class="attr">max_user_connections</span> = <span class="string">1000</span></span><br><span class="line"><span class="comment">#innodb_buffer_pool_size=1G</span></span><br><span class="line"><span class="comment">#innodb_buffer_pool_chunk_size=128M</span></span><br><span class="line"><span class="comment">#innodb_buffer_pool_instances=8</span></span><br><span class="line"><span class="comment">#key_buffer_size = 1024M</span></span><br><span class="line"><span class="comment">#sort_buffer_size = 16M</span></span><br><span class="line"><span class="comment">#join_buffer_size = 16M</span></span><br><span class="line"><span class="comment">#read_buffer_size = 4M</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=<span class="string">utf8mb4</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="attr">default-character-set</span>=<span class="string">utf8mb4</span></span><br></pre></td></tr></table></figure><h2 id="4、创建mysql容器并运行"><a href="#4、创建mysql容器并运行" class="headerlink" title="4、创建mysql容器并运行"></a>4、创建mysql容器并运行</h2><h3 id="MySQL-5"><a href="#MySQL-5" class="headerlink" title="MySQL 5"></a>MySQL 5</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run \</span></span><br><span class="line"><span class="string">--name mysql \</span></span><br><span class="line"><span class="string">-d \</span></span><br><span class="line"><span class="string">-p 3306:3306 \</span></span><br><span class="line"><span class="string">--restart unless-stopped \</span></span><br><span class="line"><span class="string">-v /dockerData/xuecheng-data/mysql/log:/var/log/mysql \</span></span><br><span class="line"><span class="string">-v /dockerData/xuecheng-data/mysql/data:/var/lib/mysql \</span></span><br><span class="line"><span class="string">-v /dockerData/xuecheng-data/mysql/conf:/etc/mysql \</span></span><br><span class="line"><span class="string">-e MYSQL_ROOT_PASSWORD=123456 \</span></span><br><span class="line"><span class="string">mysql:5.7</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>docker run</td><td>创建一个新的容器 , 同时运行这个容器</td></tr><tr><td>–name mysql</td><td>启动容器的名字</td></tr><tr><td>-d</td><td>后台运行</td></tr><tr><td>-p 3306:3306</td><td>将容器的 3306 (后面那个) 端口映射到主机的 3306 (前面那个) 端口</td></tr><tr><td>–restart unless-stopped</td><td>容器重启策略</td></tr><tr><td>-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql</td><td>将日志文件夹挂载到主机</td></tr><tr><td>-v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</td><td>将mysql储存文件夹挂载到主机</td></tr><tr><td>-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql</td><td>将配置文件夹挂载到主机</td></tr><tr><td>-e MYSQL_ROOT_PASSWORD&#x3D;root</td><td>设置 root 用户的密码</td></tr><tr><td>mysql:5.7</td><td>启动哪个版本的 mysql (本地镜像的版本)</td></tr><tr><td>\</td><td>shell 命令换行符</td></tr></tbody></table><p> 注意 : 命令中所有 冒号 前面的是主机配置 , 冒号 后面的是mysql容器配置 。<br>–restart unless-stopped : 在docker重启时重启当前容器。但不包含docker重启时已停止的容器。</p><h3 id="MySQL-8"><a href="#MySQL-8" class="headerlink" title="MySQL 8"></a>MySQL 8</h3><p><strong>注：创建mysql8容器时需要加上映射目录mysql-files</strong></p><p>创建目录</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mkdir</span> <span class="string">/docker/mysql/mysql-files</span></span><br></pre></td></tr></table></figure><p>创建mysql容器</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run \</span></span><br><span class="line"><span class="string">--name mysql \</span></span><br><span class="line"><span class="string">--restart unless-stopped \</span></span><br><span class="line"><span class="string">-v /docker/mysql/conf/my.cnf:/etc/my.cnf \</span></span><br><span class="line"><span class="string">-v /docker/mysql/data:/var/lib/mysql \</span></span><br><span class="line"><span class="string">-v /docker/mysql/log:/var/log \</span></span><br><span class="line"><span class="string">-v /docker/mysql/mysql-files:/var/lib/mysql-files \</span></span><br><span class="line"><span class="string">-p 3306:3306 \</span></span><br><span class="line"><span class="string">-e MYSQL_ROOT_PASSWORD=&#x27;root&#x27; \</span></span><br><span class="line"><span class="string">-d mysql:latest</span></span><br></pre></td></tr></table></figure><p>进入mysql容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 通过Docker命令进入Mysql容器内部</span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line">## 或者</span><br><span class="line">docker exec -it mysql bash</span><br></pre></td></tr></table></figure><p><strong>连接mysql</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><h1 id="docker安装nacos"><a href="#docker安装nacos" class="headerlink" title="docker安装nacos"></a>docker安装nacos</h1><h3 id="一、下载Nacos镜像"><a href="#一、下载Nacos镜像" class="headerlink" title="一、下载Nacos镜像"></a>一、下载Nacos镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="二、创建日志、配置文件"><a href="#二、创建日志、配置文件" class="headerlink" title="二、创建日志、配置文件"></a>二、创建日志、配置文件</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">mkdir -p /docker/nacos/logs</span><br><span class="line">mkdir -p /docker/nacos/conf</span><br><span class="line">touch  /docker/nacos/conf/application.properties</span><br></pre></td></tr></table></figure><h3 id="三、创建数据库"><a href="#三、创建数据库" class="headerlink" title="三、创建数据库"></a><strong>三、创建数据库</strong></h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">数据库全名 = ibp-nacos   */</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">表名称 = config_info   */</span></span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `config_info` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span></span><br><span class="line">  <span class="attr">`data_id`</span> <span class="string">varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span></span><br><span class="line">  <span class="attr">`group_id`</span> <span class="string">varchar(255) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`content`</span> <span class="string">longtext NOT NULL COMMENT &#x27;content&#x27;,</span></span><br><span class="line">  <span class="attr">`md5`</span> <span class="string">varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_create`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_modified`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;,</span></span><br><span class="line">  <span class="attr">`src_user`</span> <span class="string">text COMMENT &#x27;source user&#x27;,</span></span><br><span class="line">  <span class="attr">`src_ip`</span> <span class="string">varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span></span><br><span class="line">  <span class="attr">`app_name`</span> <span class="string">varchar(128) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`tenant_id`</span> <span class="string">varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span></span><br><span class="line">  <span class="attr">`c_desc`</span> <span class="string">varchar(256) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`c_use`</span> <span class="string">varchar(64) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`effect`</span> <span class="string">varchar(64) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`type`</span> <span class="string">varchar(64) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`c_schema`</span> <span class="string">text,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`id`),</span></span><br><span class="line">  <span class="attr">UNIQUE</span> <span class="string">KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">数据库全名 = ibp-nacos   */</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">表名称 = config_info_aggr   */</span></span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `config_info_aggr` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span></span><br><span class="line">  <span class="attr">`data_id`</span> <span class="string">varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span></span><br><span class="line">  <span class="attr">`group_id`</span> <span class="string">varchar(255) NOT NULL COMMENT &#x27;group_id&#x27;,</span></span><br><span class="line">  <span class="attr">`datum_id`</span> <span class="string">varchar(255) NOT NULL COMMENT &#x27;datum_id&#x27;,</span></span><br><span class="line">  <span class="attr">`content`</span> <span class="string">longtext NOT NULL COMMENT &#x27;内容&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_modified`</span> <span class="string">datetime NOT NULL COMMENT &#x27;修改时间&#x27;,</span></span><br><span class="line">  <span class="attr">`app_name`</span> <span class="string">varchar(128) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`tenant_id`</span> <span class="string">varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`id`),</span></span><br><span class="line">  <span class="attr">UNIQUE</span> <span class="string">KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">数据库全名 = ibp-nacos   */</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">表名称 = config_info_beta   */</span></span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `config_info_beta` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span></span><br><span class="line">  <span class="attr">`data_id`</span> <span class="string">varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span></span><br><span class="line">  <span class="attr">`group_id`</span> <span class="string">varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span></span><br><span class="line">  <span class="attr">`app_name`</span> <span class="string">varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span></span><br><span class="line">  <span class="attr">`content`</span> <span class="string">longtext NOT NULL COMMENT &#x27;content&#x27;,</span></span><br><span class="line">  <span class="attr">`beta_ips`</span> <span class="string">varchar(1024) DEFAULT NULL COMMENT &#x27;betaIps&#x27;,</span></span><br><span class="line">  <span class="attr">`md5`</span> <span class="string">varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_create`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_modified`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;,</span></span><br><span class="line">  <span class="attr">`src_user`</span> <span class="string">text COMMENT &#x27;source user&#x27;,</span></span><br><span class="line">  <span class="attr">`src_ip`</span> <span class="string">varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span></span><br><span class="line">  <span class="attr">`tenant_id`</span> <span class="string">varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`id`),</span></span><br><span class="line">  <span class="attr">UNIQUE</span> <span class="string">KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">数据库全名 = ibp-nacos   */</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">表名称 = config_info_tag   */</span></span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `config_info_tag` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span></span><br><span class="line">  <span class="attr">`data_id`</span> <span class="string">varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span></span><br><span class="line">  <span class="attr">`group_id`</span> <span class="string">varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span></span><br><span class="line">  <span class="attr">`tenant_id`</span> <span class="string">varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span></span><br><span class="line">  <span class="attr">`tag_id`</span> <span class="string">varchar(128) NOT NULL COMMENT &#x27;tag_id&#x27;,</span></span><br><span class="line">  <span class="attr">`app_name`</span> <span class="string">varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span></span><br><span class="line">  <span class="attr">`content`</span> <span class="string">longtext NOT NULL COMMENT &#x27;content&#x27;,</span></span><br><span class="line">  <span class="attr">`md5`</span> <span class="string">varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_create`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_modified`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;,</span></span><br><span class="line">  <span class="attr">`src_user`</span> <span class="string">text COMMENT &#x27;source user&#x27;,</span></span><br><span class="line">  <span class="attr">`src_ip`</span> <span class="string">varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`id`),</span></span><br><span class="line">  <span class="attr">UNIQUE</span> <span class="string">KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">数据库全名 = ibp-nacos  */</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">表名称 = config_tags_relation   */</span></span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `config_tags_relation` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(20) NOT NULL COMMENT &#x27;id&#x27;,</span></span><br><span class="line">  <span class="attr">`tag_name`</span> <span class="string">varchar(128) NOT NULL COMMENT &#x27;tag_name&#x27;,</span></span><br><span class="line">  <span class="attr">`tag_type`</span> <span class="string">varchar(64) DEFAULT NULL COMMENT &#x27;tag_type&#x27;,</span></span><br><span class="line">  <span class="attr">`data_id`</span> <span class="string">varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span></span><br><span class="line">  <span class="attr">`group_id`</span> <span class="string">varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span></span><br><span class="line">  <span class="attr">`tenant_id`</span> <span class="string">varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span></span><br><span class="line">  <span class="attr">`nid`</span> <span class="string">bigint(20) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`nid`),</span></span><br><span class="line">  <span class="attr">UNIQUE</span> <span class="string">KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span></span><br><span class="line">  <span class="attr">KEY</span> <span class="string">`idx_tenant_id` (`tenant_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">数据库全名 = ibp-nacos   */</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">表名称 = group_capacity   */</span></span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `group_capacity` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,</span></span><br><span class="line">  <span class="attr">`group_id`</span> <span class="string">varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;,</span></span><br><span class="line">  <span class="attr">`quota`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,</span></span><br><span class="line">  <span class="attr">`usage`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,</span></span><br><span class="line">  <span class="attr">`max_size`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,</span></span><br><span class="line">  <span class="attr">`max_aggr_count`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;,</span></span><br><span class="line">  <span class="attr">`max_aggr_size`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,</span></span><br><span class="line">  <span class="attr">`max_history_count`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_create`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_modified`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`id`),</span></span><br><span class="line">  <span class="attr">UNIQUE</span> <span class="string">KEY `uk_group_id` (`group_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">数据库全名 = ibp-nacos   */</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">表名称 = his_config_info   */</span></span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `his_config_info` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(64) unsigned NOT NULL,</span></span><br><span class="line">  <span class="attr">`nid`</span> <span class="string">bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line">  <span class="attr">`data_id`</span> <span class="string">varchar(255) NOT NULL,</span></span><br><span class="line">  <span class="attr">`group_id`</span> <span class="string">varchar(128) NOT NULL,</span></span><br><span class="line">  <span class="attr">`app_name`</span> <span class="string">varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span></span><br><span class="line">  <span class="attr">`content`</span> <span class="string">longtext NOT NULL,</span></span><br><span class="line">  <span class="attr">`md5`</span> <span class="string">varchar(32) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`gmt_create`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_modified`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27;,</span></span><br><span class="line">  <span class="attr">`src_user`</span> <span class="string">text,</span></span><br><span class="line">  <span class="attr">`src_ip`</span> <span class="string">varchar(20) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`op_type`</span> <span class="string">char(10) DEFAULT NULL,</span></span><br><span class="line">  <span class="attr">`tenant_id`</span> <span class="string">varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`nid`),</span></span><br><span class="line">  <span class="attr">KEY</span> <span class="string">`idx_gmt_create` (`gmt_create`),</span></span><br><span class="line">  <span class="attr">KEY</span> <span class="string">`idx_gmt_modified` (`gmt_modified`),</span></span><br><span class="line">  <span class="attr">KEY</span> <span class="string">`idx_did` (`data_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">数据库全名 = ibp-nacos   */</span></span><br><span class="line"><span class="attr">/*</span>   <span class="string">表名称 = tenant_capacity   */</span></span><br><span class="line"><span class="attr">/******************************************/</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `tenant_capacity` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,</span></span><br><span class="line">  <span class="attr">`tenant_id`</span> <span class="string">varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;,</span></span><br><span class="line">  <span class="attr">`quota`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,</span></span><br><span class="line">  <span class="attr">`usage`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,</span></span><br><span class="line">  <span class="attr">`max_size`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,</span></span><br><span class="line">  <span class="attr">`max_aggr_count`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;,</span></span><br><span class="line">  <span class="attr">`max_aggr_size`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,</span></span><br><span class="line">  <span class="attr">`max_history_count`</span> <span class="string">int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_create`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_modified`</span> <span class="string">datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`id`),</span></span><br><span class="line">  <span class="attr">UNIQUE</span> <span class="string">KEY `uk_tenant_id` (`tenant_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `tenant_info` (</span></span><br><span class="line">  <span class="attr">`id`</span> <span class="string">bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span></span><br><span class="line">  <span class="attr">`kp`</span> <span class="string">varchar(128) NOT NULL COMMENT &#x27;kp&#x27;,</span></span><br><span class="line">  <span class="attr">`tenant_id`</span> <span class="string">varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span></span><br><span class="line">  <span class="attr">`tenant_name`</span> <span class="string">varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;,</span></span><br><span class="line">  <span class="attr">`tenant_desc`</span> <span class="string">varchar(256) DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;,</span></span><br><span class="line">  <span class="attr">`create_source`</span> <span class="string">varchar(32) DEFAULT NULL COMMENT &#x27;create_source&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_create`</span> <span class="string">bigint(20) NOT NULL COMMENT &#x27;创建时间&#x27;,</span></span><br><span class="line">  <span class="attr">`gmt_modified`</span> <span class="string">bigint(20) NOT NULL COMMENT &#x27;修改时间&#x27;,</span></span><br><span class="line">  <span class="attr">PRIMARY</span> <span class="string">KEY (`id`),</span></span><br><span class="line">  <span class="attr">UNIQUE</span> <span class="string">KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span></span><br><span class="line">  <span class="attr">KEY</span> <span class="string">`idx_tenant_id` (`tenant_id`)</span></span><br><span class="line"><span class="attr">)</span> <span class="string">ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE users (</span></span><br><span class="line"><span class="attr">username</span> <span class="string">varchar(50) NOT NULL PRIMARY KEY,</span></span><br><span class="line"><span class="attr">password</span> <span class="string">varchar(500) NOT NULL,</span></span><br><span class="line"><span class="attr">enabled</span> <span class="string">boolean NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE roles (</span></span><br><span class="line"><span class="attr">username</span> <span class="string">varchar(50) NOT NULL,</span></span><br><span class="line"><span class="attr">role</span> <span class="string">varchar(50) NOT NULL,</span></span><br><span class="line"><span class="attr">constraint</span> <span class="string">uk_username_role UNIQUE (username,role)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE permissions (</span></span><br><span class="line">    <span class="attr">role</span> <span class="string">varchar(50) NOT NULL,</span></span><br><span class="line">    <span class="attr">resource</span> <span class="string">varchar(512) NOT NULL,</span></span><br><span class="line">    <span class="attr">action</span> <span class="string">varchar(8) NOT NULL,</span></span><br><span class="line">    <span class="attr">constraint</span> <span class="string">uk_role_permission UNIQUE (role,resource,action)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO users (username, password, enabled) VALUES (&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, TRUE);</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO roles (username, role) VALUES (&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;);</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="四、配置application-properties"><a href="#四、配置application-properties" class="headerlink" title="四、配置application.properties"></a><strong>四、配置application.properties</strong></h3><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">vi /docker/nacos/conf/application.properties</span><br></pre></td></tr></table></figure><p>修改MySQL连接配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="attr">server.servlet.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8848</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://192.168.1.88:3307/ibp-nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="attr">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password</span>=<span class="string">Qakj123456</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">nacos.cmdb.dumpTaskInterval</span>=<span class="string">3600</span></span><br><span class="line"><span class="attr">nacos.cmdb.eventTaskInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">nacos.cmdb.labelTaskInterval</span>=<span class="string">300</span></span><br><span class="line"><span class="attr">nacos.cmdb.loadDataAtStart</span>=<span class="string">false</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">management.metrics.export.elastic.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">management.metrics.export.influx.enabled</span>=<span class="string">false</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">server.tomcat.accesslog.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.tomcat.accesslog.pattern</span>=<span class="string">%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;i</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">nacos.security.ignore.urls</span>=<span class="string">/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**</span></span><br><span class="line"><span class="attr">nacos.naming.distro.taskDispatchThreadCount</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">nacos.naming.distro.taskDispatchPeriod</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">nacos.naming.distro.batchSyncKeyCount</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">nacos.naming.distro.initDataRatio</span>=<span class="string">0.9</span></span><br><span class="line"><span class="attr">nacos.naming.distro.syncRetryDelay</span>=<span class="string">5000</span></span><br><span class="line"><span class="attr">nacos.naming.data.warmup</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">nacos.naming.expireInstance</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h3 id="五、docker运行命令"><a href="#五、docker运行命令" class="headerlink" title="五、docker运行命令"></a><strong>五、docker运行命令</strong></h3><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">docker run --name nacos -d \</span><br><span class="line">-p <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">--restart=always \</span><br><span class="line">-e JVM_XMS=<span class="number">256</span>m \</span><br><span class="line">-e JVM_XMX=<span class="number">256</span>m \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e TIME_ZONE=<span class="comment">&#x27;Asia/Shanghai&#x27; \</span></span><br><span class="line">-v /docker/nacos/logs:/home/nacos/logs \</span><br><span class="line">-v /docker/nacos/conf/application.properties:/home/nacos/conf/application.properties \</span><br><span class="line">nacos/nacos-<span class="built_in">server</span></span><br></pre></td></tr></table></figure><p><strong>查看docker日志</strong></p><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">docker logs -f -t nacos</span><br></pre></td></tr></table></figure><h3 id="六、浏览器登录"><a href="#六、浏览器登录" class="headerlink" title="六、浏览器登录"></a>六、浏览器登录</h3><p><em><a href="http://192.168.101.129:8848/nacos">http://192.168.101.129:8848/nacos</a>  用户名密码：nacos&#x2F;nacos</em></p><h1 id="docker安装Nginx"><a href="#docker安装Nginx" class="headerlink" title="docker安装Nginx"></a>docker安装Nginx</h1><h2 id="下载Nginx镜像"><a href="#下载Nginx镜像" class="headerlink" title="下载Nginx镜像"></a>下载Nginx镜像</h2><p>下载最新版本的nginx的镜像</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">pull nginx:latest</span></span><br></pre></td></tr></table></figure><h2 id="运行nginx镜像"><a href="#运行nginx镜像" class="headerlink" title="运行nginx镜像"></a>运行nginx镜像</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run --name nginx -p 80:80 -d nginx</span></span><br></pre></td></tr></table></figure><ul><li>参数详解<ul><li>–name nginx 指定容器的名称</li><li>-p 80:80 映射端口</li><li>-d 守护进程运行</li></ul></li></ul><h2 id="从nginx容器中映射核心文件"><a href="#从nginx容器中映射核心文件" class="headerlink" title="从nginx容器中映射核心文件"></a>从nginx容器中映射核心文件</h2><ul><li>1、本地创建文件目录</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建挂载目录</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/nginx/conf</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/nginx/log</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/nginx/html</span></span><br></pre></td></tr></table></figure><ul><li>2、拷贝nginx容器对应的文件默认配置</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将容器nginx.conf文件复制到宿主机</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp nginx:/etc/nginx/nginx.conf /docker/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="comment"># 将容器conf.d文件夹下内容复制到宿主机</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp nginx:/etc/nginx/conf.d /docker/nginx/conf/conf.d</span></span><br><span class="line"><span class="comment"># 将容器中的html文件夹复制到宿主机</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp nginx:/usr/share/nginx/html /docker/nginx/</span></span><br></pre></td></tr></table></figure><ul><li>3、停止并删除nginx容器</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">stop nginx </span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker</span> <span class="string">rm nginx</span></span><br></pre></td></tr></table></figure><p>删除正在运行的nginx容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm -f nginx</span><br></pre></td></tr></table></figure><h2 id="重新启动nginx镜像重新新容器"><a href="#重新启动nginx镜像重新新容器" class="headerlink" title="重新启动nginx镜像重新新容器"></a>重新启动nginx镜像重新新容器</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run \</span></span><br><span class="line"><span class="string">-p 80:80 \</span></span><br><span class="line"><span class="string">--name nginx \</span></span><br><span class="line"><span class="string">-v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span></span><br><span class="line"><span class="string">-v /docker/nginx/conf/conf.d:/etc/nginx/conf.d \</span></span><br><span class="line"><span class="string">-v /docker/nginx/log:/var/log/nginx \</span></span><br><span class="line"><span class="string">-v /docker/nginx/html:/usr/share/nginx/html \</span></span><br><span class="line"><span class="string">-d nginx:latest</span></span><br></pre></td></tr></table></figure><h1 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h1><h3 id="一、Docker搜索redis镜像"><a href="#一、Docker搜索redis镜像" class="headerlink" title="一、Docker搜索redis镜像"></a>一、Docker搜索redis镜像</h3><blockquote><p>命令：docker search &lt;镜像名称&gt;</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">search redis</span></span><br></pre></td></tr></table></figure><p>可以看到有很多redis的镜像，此处因没有指定版本，所以下载的就是默认的最新版本 。<strong>redis latest.</strong></p><h3 id="二、Docker拉取镜像"><a href="#二、Docker拉取镜像" class="headerlink" title="二、Docker拉取镜像"></a>二、Docker拉取镜像</h3><blockquote><p>命令：：docker pull &lt;镜像名称&gt;:&lt;版本号&gt;</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">pull redis</span></span><br></pre></td></tr></table></figure><h3 id="三、简单的启动一个Redis"><a href="#三、简单的启动一个Redis" class="headerlink" title="三、简单的启动一个Redis"></a>三、简单的启动一个Redis</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从docker仓库中拉取redis最新的镜像</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">pull redis</span></span><br><span class="line"><span class="comment"># 运行一个redis容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">run --name redis -p 6380:6379 -d redis</span></span><br><span class="line"><span class="comment"># 运行redis容器，并指定密码</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">run --name redis -p 6380:6379 -d redis --requirepass &quot;123456&quot;</span></span><br></pre></td></tr></table></figure><h3 id="四、查看docker容器中的redis版本"><a href="#四、查看docker容器中的redis版本" class="headerlink" title="四、查看docker容器中的redis版本"></a>四、查看docker容器中的redis版本</h3><p>在下载之前，先查看docker容器中的redis版本，打开redis-cli，通过info指令可以获取到版本号。</p><p><img src="/adanpro/adanblog/./../pic/20230624135155018.png" alt="img"></p><h3 id="五、redis-conf下载"><a href="#五、redis-conf下载" class="headerlink" title="五、redis.conf下载"></a>五、redis.conf下载</h3><p>redis的每个版本都有一个默认的<code>redis.conf</code>配置文件，这个配置文件可以在官网去下载，也可以下载对应版本的tar包，从tar包中获取。<br><a href="http://download.redis.io/releases/">附：Redis tar包下载地址</a></p><p><strong>注：redis.conf的版本需要和redis容器的版本一致，否则可能会启动失败。</strong></p><p>修改配置文件</p><p>主要配置的如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">bind</span> <span class="string">127.0.0.1  #注释掉这部分，使redis可以外部访问</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">no#用守护线程的方式启动</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123456 #密码 给redis设置密码</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes#redis持久化　　默认是no</span></span><br><span class="line"><span class="attr">tcp-keepalive</span> <span class="string">300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/data</span></span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/20230624140352616.png" alt="img"></p><h3 id="六、配置持久化策略"><a href="#六、配置持久化策略" class="headerlink" title="六、配置持久化策略"></a>六、配置持久化策略</h3><p><strong>创建目录</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/redis/data</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p /docker/redis/conf</span></span><br></pre></td></tr></table></figure><p>将<strong>redis.conf</strong>文件上传到conf目录下</p><h3 id="七、配置映射并启动"><a href="#七、配置映射并启动" class="headerlink" title="七、配置映射并启动"></a>七、配置映射并启动</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run --name redis -p 6379:6379 \</span></span><br><span class="line"><span class="string">-v /docker/redis/data:/data \</span></span><br><span class="line"><span class="string">-v /docker/redis/conf/redis.conf:/etc/redis/redis.conf --privileged=true -d redis \</span></span><br><span class="line"><span class="string">redis-server /etc/redis/redis.conf </span></span><br></pre></td></tr></table></figure><p><code>-p 6379:6379</code>:把容器内的6379端口映射到宿主机6379端口<br> <code>-v /data/redis/redis.conf:/etc/redis/redis.conf</code>：把宿主机配置好的redis.conf放到容器内的这个位置中<br> <code>-v /data/redis/data:/data</code>：把redis持久化的数据在宿主机内显示，做数据备份<br> <code>redis-server /etc/redis/redis.conf</code>：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动<br> <code>–appendonly yes</code>：redis启动后数据持久化</p><p>查看启动日志：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">logs -f redis</span></span><br></pre></td></tr></table></figure><h1 id="docker创建gogs容器"><a href="#docker创建gogs容器" class="headerlink" title="docker创建gogs容器"></a><strong>docker创建gogs容器</strong></h1><h2 id="1-创建新用户："><a href="#1-创建新用户：" class="headerlink" title="1. 创建新用户："></a><strong>1. 创建新用户：</strong></h2><p>MySql8有新的安全要求，不能像之前的版本那样一次性创建用户并授权需要先创建用户，再进行授权操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;gogs&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;gogs&#x27;</span>; </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;password&#x27;</span>; </span><br></pre></td></tr></table></figure><p>其中<code>username</code>为自定义的用户名；<code>host</code>为登录域名，<code>host</code>为<code>&#39;%&#39;</code>时表示为 任意IP，为<code>localhost</code>时表示本机，或者填写指定的IP地址；<code>paasword</code>为密码</p><h2 id="2-为用户授权："><a href="#2-为用户授权：" class="headerlink" title="2. 为用户授权："></a><strong>2. 为用户授权：</strong></h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> gogs.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;gogs&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option; </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option; </span><br></pre></td></tr></table></figure><h2 id="3-授权之后刷新权限："><a href="#3-授权之后刷新权限：" class="headerlink" title="3. 授权之后刷新权限："></a><strong>3. 授权之后刷新权限：</strong></h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush privileges; </span><br></pre></td></tr></table></figure><h2 id="4-撤销授权"><a href="#4-撤销授权" class="headerlink" title="4.撤销授权"></a><strong>4.撤销授权</strong></h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#收回权限(不包含赋权权限)</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> user_name;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> user_name.<span class="operator">*</span> <span class="keyword">FROM</span> user_name;</span><br><span class="line">#收回赋权权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">GRANT</span> OPTION <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> user_name;</span><br><span class="line"></span><br><span class="line">#操作完后重新刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="5、拉取镜像"><a href="#5、拉取镜像" class="headerlink" title="5、拉取镜像"></a>5、拉取镜像</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull gogs/gogs</span><br></pre></td></tr></table></figure><h2 id="6、运行镜像"><a href="#6、运行镜像" class="headerlink" title="6、运行镜像"></a>6、运行镜像</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name=gogs -p 10022:22 -p 10880:3000 -v /dockerData/xuecheng-data/gogs:/data gogs/gogs</span><br></pre></td></tr></table></figure><h2 id="7、配置环境"><a href="#7、配置环境" class="headerlink" title="7、配置环境"></a>7、配置环境</h2><p>登录页面: ****，修改以下标红的内容</p><p><img src="/adanpro/adanblog/./../pic/20230530205430247.png" alt="img"></p><p><img src="/adanpro/adanblog/./../pic/20230530210207014.png" alt="img"></p><p>禁止用户注册并设置gogs页面的管理员账号：</p><p><img src="/adanpro/adanblog/./../pic/20230530210410854.png" alt="image-20230530210410854"></p><p><img src="/adanpro/adanblog/./../pic/1687790038061-19.png" alt="img"></p><p><img src="/adanpro/adanblog/./../pic/20230530210607462.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：上图的应用基本设置</span><br><span class="line">    应用名称：可以换成自定义名称</span><br><span class="line">    仓库根目录：使用默认就行了，默认/data/git/gogs-repositories。如果采用了数据卷映射，比如我这里因为/server/docker/gogs/data映射/data，需要给这个目录777权限，负责会创建失败。</span><br><span class="line">    域名：使用ssh时使用的域名或者IP</span><br><span class="line">    SSH 端口号：gogs启用ssh时使用的端口号，默认22端口，如果修改了这个端口号，那么在上面创建容器时要对应的将10022端口映射到修改的端口号，如果不启用ssh，则置空</span><br><span class="line">    HTTP 端口号：gogs应用启动的http端口，默认3000，如果修改了这个端口号，那么在上面创建容器时要对应的将10080端口映射到修改的端口号</span><br><span class="line">    应用 URL：即打开应用的url地址，因为这里采用了docker，所以我们要修改成宿主机的地址转发去访问，比如这里我的宿主机地址：192.168.1.20，它的10080端口会转发到容器的3000端口，所以这里填：http://192.168.1.20:10080/</span><br><span class="line">    日志路径：gogs的日志保存路径，默认就行了</span><br><span class="line"></span><br><span class="line">##安装程序运行完成后，会生成一个app.ini文件，在宿主机映射目录/server/docker/gogs/data/gogs/conf/app.ini，其中有相关的配置信息，尽量不要修改此文件，可能导致服务无法访问。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dokcer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/adanpro/adanblog/2023/06/28/docker/"/>
      <url>/adanpro/adanblog/2023/06/28/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>docker译为容器。</p><p><strong>Docker 是一个</strong>开源的<strong>应用容器引擎</strong>，让<strong>开发者可以打包</strong>他们的<strong>应用以及依赖包到</strong>一个可移植的<strong>镜像</strong>中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux?fromModule=lemma_inlink">Linux</a>或<a href="https://baike.baidu.com/item/Windows/165458?fromModule=lemma_inlink">Windows</a>操作系统的机器上，也可以实现<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949?fromModule=lemma_inlink">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318?fromModule=lemma_inlink">沙箱</a>机制，相互之间不会有任何接口。 </p><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li><strong>分布式系统中，依赖的组件非常多</strong>，不同组件之间部署时往往会产生一些<strong>冲突</strong>。</li><li>在数百上千台服务中<strong>重复部署，环境</strong>不一定一致，会遇到各种问题</li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li>依赖关系复杂，容易出现兼容性问题</li><li>开发、测试、生产环境有差异</li></ul><p><img src="/adanpro/adanblog/./../pic/24d893c343cbdcabe3d52224a43e8287.png" alt="img"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而<strong>Docker巧妙的解决了这些问题</strong>，Docker是如何实现的呢？</p><p>Docker为了<strong>解决依赖的兼容问题</strong>的，采用了两个手段：</p><ul><li><strong>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</strong></li><li><strong>将每个应用放到一个隔离容器去运行，避免互相干扰</strong></li></ul><p><img src="/adanpro/adanblog/./../pic/5af77db58593fddf63f214e8855b984a.png" alt="image-20210731142219735"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><blockquote><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p></blockquote><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="/adanpro/adanblog/./../pic/30f79c1daec3d7adb2646e4f9642460f.png" alt="image-20210731143401460"></p><p>结构包括：</p><ul><li><strong>计算机硬件：</strong>例如CPU、内存、磁盘等</li><li><strong>系统内核：</strong>所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于<strong>操作计算机硬件</strong>。</li><li><strong>系统应用：</strong>操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用<strong>操作系统应用</strong>（函数库），实现各种功能</p><p><strong>2）系统函数库</strong>是对内核指令集的封装，会调用内核指令</p><p>3）<strong>内核指令</strong>操作计算机硬件</p><p><strong>Ubuntu和CentOSpringBoot</strong>都是基于Linux内核，无非是<strong>系统应用不同，提供的函数库有差异：</strong></p><p><img src="/adanpro/adanblog/./../pic/d199dc14b8d28fe1aab4edd6ca3b441f.png" alt="image-20210731144304990"></p><p>此时，<strong>如果</strong>将一个<strong>Ubuntu版本的MySQL</strong>应用<strong>安装到CentOS系统</strong>，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会<strong>报错</strong>了：</p><p><img src="/adanpro/adanblog/./../pic/c3fb69ef298349c408d3d87062f0e784.png" alt="image-20210731144458680"></p><p><strong>Docker如何解决不同系统环境的问题？</strong></p><p>Docker将<strong>用户程序与</strong>所需要调用的<strong>系统</strong>(比如Ubuntu)<strong>函数库一起打包</strong>，这样<strong>每个程序调用自己打包好的函数库</strong>就不会出现环境问题。Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行。</p><p>因此，<strong>docker打包好的程序包，可以运行在任何Linux内核的操作系统上。</strong></p><p>如图：</p><p><img src="/adanpro/adanblog/./../pic/83ec4eabd582aaa36a04948925606049.png" alt="image-20210731144820638"></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li><strong>Docker镜像中包含完整运行环境，包括系统函数库</strong>，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列<strong>优势：</strong></p><ul><li>可以将程序及其依赖、运行环境一起<strong>打包为一个镜像</strong>，可以<strong>迁移</strong>到<strong>任意Linux</strong>操作系统</li><li>运行时利用<strong>沙箱机制形成隔离容器</strong>，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的<strong>虚拟机</strong>，<strong>也能在一个操作系统中，运行另外一个操作系统</strong>，保护系统中的任何应用。</p><p>两者有什么<strong>差异</strong>呢？</p><ul><li><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟硬件设备</strong>，然后<strong>运行另一个操作系统</strong>，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</li><li><strong>Docker仅仅是封装函数库</strong>，并没有模拟完整的操作系统，如图：</li></ul><p><img src="/adanpro/adanblog/./../pic/cee7c7c8a6ecaa861def1b9417d2da57.png" alt="image-20210731145914960"></p><p>对比来看：</p><p><img src="/adanpro/adanblog/./../pic/f4853cbbb871f52edc3f19b89493005f.png" alt="image-20210731152243765"></p><p>小结：</p><p><strong>Docker和虚拟机的差异：</strong></p><ul><li><strong>docker是一个系统进程</strong>；<strong>虚拟机是</strong>在操作系统中的<strong>操作系统</strong></li><li><strong>docker体积小、启动速度快、性能好</strong>；虚拟机体积大、启动速度慢、性能一般</li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将<strong>应用程序</strong>及其所需的<strong>依赖、函数库、环境、配置</strong>等文件<strong>打包</strong>在一起，称为镜像。</p><p><strong>容器（Container）</strong>：<strong>镜像中的应用程序运行后形成的进程</strong>就是<strong>容器</strong>，只是Docker会给容器进程做隔离，<strong>对外不可见</strong>。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。</p><p><strong>每个文件包（镜像）是只读的，每个容器是可读写的，所以镜像不会被干扰。</strong>可以基于镜像去创建容器，然后在每个容器里记录日志等数据。</p><p><strong>容器</strong>，就是<strong>将这些文件中</strong>编写的<strong>程序、函数加载到内存中</strong>允许，形成进程，只不过要<strong>隔离</strong>起来。因此<strong>一个镜像可以启动多次</strong>，形成多个容器进程。</p><p><img src="/adanpro/adanblog/./../pic/599b120a3dde1ea4ee4128336a50f95b.png" alt="image-20210731153059464"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><strong>DockerHub：</strong>DockerHub是一个官方的<strong>Docker镜像的托管平台</strong>。<strong>这样的平台称为Docker注册Docker Registry。</strong></li><li>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="/adanpro/adanblog/./../pic/d4ee42033d315a5913163a3b3dc9830c.png" alt="image-20210731153743354"></p><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><strong>服务端(server)：</strong>Docker<strong>守护进程</strong>，负责<strong>处理Docker指令</strong>，管理镜像、容器等</li><li><strong>客户端(client)：</strong>通过命令或RestAPI<strong>向Docker服务端发送指令</strong>。可以在本地或远程向服务端发送指令。</li></ul><p>如图：</p><p><img src="/adanpro/adanblog/./../pic/1612e0f131e3431d1d6f239046115fe3.png" alt="image-20210731154257653"></p><p>docker build是构建镜像，被docker daemon接收处理构建成镜像images。</p><p>docker pull拉取镜像，docker daemon从接收指令后，从registry拉取镜像。</p><p>docker run创建容器。</p><h3 id="1-3-4-小结镜像、容器、结构、dockerhub"><a href="#1-3-4-小结镜像、容器、结构、dockerhub" class="headerlink" title="1.3.4.小结镜像、容器、结构、dockerhub"></a>1.3.4.小结镜像、容器、结构、dockerhub</h3><p><strong>镜像：</strong></p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p><strong>容器：</strong></p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p><strong>Docker结构：</strong></p><ul><li>服务端：接收命令或远程请求，操作镜像或容器</li><li>客户端：发送命令或者请求到Docker服务端</li></ul><p><strong>DockerHub：</strong></p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-CentOS安装Docker"><a href="#1-4-CentOS安装Docker" class="headerlink" title="1.4.CentOS安装Docker"></a>1.4.CentOS安装Docker</h2><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h3 id="1-4-1-卸载（可选）"><a href="#1-4-1-卸载（可选）" class="headerlink" title="1.4.1.卸载（可选）"></a>1.4.1.卸载（可选）</h3><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line"></span><br><span class="line">                  docker-client \</span><br><span class="line"></span><br><span class="line">                  docker-client-latest \</span><br><span class="line"></span><br><span class="line">                  docker-common \</span><br><span class="line"></span><br><span class="line">                  docker-latest \</span><br><span class="line"></span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line"></span><br><span class="line">                  docker-logrotate \</span><br><span class="line"></span><br><span class="line">                  docker-selinux \</span><br><span class="line"></span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line"></span><br><span class="line">                  docker-engine \</span><br><span class="line"></span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h3 id="1-4-2-安装docker"><a href="#1-4-2-安装docker" class="headerlink" title="1.4.2.安装docker"></a>1.4.2.安装docker</h3><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">yum</span> install -y yum-utils \</span><br><span class="line"></span><br><span class="line">           device-mapper-persistent-<span class="class"><span class="keyword">data</span> \</span></span><br><span class="line"></span><br><span class="line">           lvm2 <span class="comment">--skip-broken</span></span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.4.设置docker镜像源</span></span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line"></span><br><span class="line">    --add-repo \</span><br><span class="line"></span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h3 id="1-4-3-启动docker"><a href="#1-4-3-启动docker" class="headerlink" title="1.4.3.启动docker"></a>1.4.3.启动docker</h3><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，<strong>一定要关闭防火墙</strong>后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.4.关闭</span></span><br><span class="line"></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1.4.禁止开机启动防火墙</span></span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker  <span class="comment">## 1.4.启动docker服务</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment">## 1.4.停止docker服务</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment">## 1.4.重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h3 id="1-4-4-配置镜像加速"><a href="#1-4-4-配置镜像加速" class="headerlink" title="1.4.4.配置镜像加速"></a>1.4.4.配置镜像加速</h3><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台</a></p><p>通过修改daemon配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器。</p><p><strong>在ssh输入下面命令：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://tfa5975m.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>可以看见，多了个&#x2F;etc&#x2F;docker&#x2F;daemon.json文件：</p><p><img src="/adanpro/adanblog/./../pic/c2afff91209f4197a4a1f69e2382da7b.png" alt="img"></p><h3 id="1-4-5-设置开机启动docker"><a href="#1-4-5-设置开机启动docker" class="headerlink" title="1.4.5 设置开机启动docker"></a>1.4.5 设置开机启动docker</h3><p>1、查看已经启动的服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure><p>2、查看是否设置开机启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files | grep docker</span><br></pre></td></tr></table></figure><p>3、设置开机启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker.service</span><br></pre></td></tr></table></figure><p><strong>设置容器自启</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">update</span> <span class="comment">--restart=always 容器名称</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">update</span> <span class="comment">--restart=always mysql nginx</span></span><br></pre></td></tr></table></figure><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：**[repository]:[tag]**。</li><li>在没有指定<strong>tag</strong>时，<strong>默认是latest</strong>，代表<strong>最新版本</strong>的镜像</li></ul><p>如图：</p><p><img src="/adanpro/adanblog/./../pic/81650f1011f04db452bcac1108d3bc5b.png" alt="image-20210731155141362"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="/adanpro/adanblog/./../pic/a3b75dce42e579767d3561cf2d02da58.png" alt="image-20210731155649535"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> docker pull nginx</span><br><span class="line">docker images</span><br><span class="line">docker save -o nginx.tar nginx:latest</span><br><span class="line">docker rmi nginx:latest</span><br><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p><strong>需求：从DockerHub中拉取一个nginx镜像并查看</strong></p><p><strong>1）搜索镜像名称。</strong>首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="/adanpro/adanblog/./../pic/0f9a4c4206221d81554d7c89f25f9e2f.png" alt="image-20210731155844368"></p><p><strong>2）拉取镜像。</strong>根据查看到的镜像名称，这里拉取官方镜像，通过命令：docker pull nginx</p><p><img src="/adanpro/adanblog/./../pic/98f25176b9204f5aa2334405465fe5c8.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/d649a27ea735a7b3debf5fa706671878.png" alt="image-20210731155856199"></p><p><strong>3）查看镜像。</strong>通过命令：docker images 查看拉取到的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/310b73417a7f091a9861fbf3b40c7897.png" alt="image-20210731155903037"></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p><strong>需求：</strong>利用docker save将<strong>nginx镜像导出磁盘，然后再通过load加载回来</strong></p><p><strong>1）查看命令用法。</strong>利用<strong>docker xx –help</strong>命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker save <span class="comment">--help</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/adanpro/adanblog/./../pic/0765dc814c6297a78fd44c64ec74dbca.png" alt="image-20210731161104732"></p><p>命令格式：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">save</span> <span class="selector-tag">-o</span> <span class="selector-attr">[保存的目标文件名称]</span> <span class="selector-attr">[镜像名称]</span></span><br></pre></td></tr></table></figure><p><strong>2）保存镜像。</strong>使用docker save导出镜像到磁盘</p><p>运行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="/adanpro/adanblog/./../pic/52c8c30a0fed6a2eed73991e4927c384.png" alt="image-20210731161354344"></p><p><strong>3）导入镜像。</strong>使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure><blockquote><p>rmi是remove image的缩写。</p></blockquote><p>然后运行命令，加载本地文件：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">docker load -<span class="selector-tag">i</span> nginx<span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/adanpro/adanblog/./../pic/0326bb83ba5d028e1fbb1c7f444b4006.png" alt="image-20210731161746245"></p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="/adanpro/adanblog/./../pic/e9092a6c66c28cae4e0d6437e05a2086.png" alt="image-20210731161950495"></p><p>exec是execute的缩写。 </p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li><strong>暂停：</strong>进程暂停，CPU不再运行，<strong>并不释放内存</strong></li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><strong>docker run：创建并运行一个容器，处于运行状态</strong></li><li><strong>docker pause：让一个运行的容器暂停</strong></li><li><strong>docker unpause：让一个容器从暂停状态恢复运行</strong></li><li><strong>docker stop：停止一个运行的容器</strong></li><li><strong>docker start：让一个停止的容器再次运行</strong></li><li><strong>docker rm：删除一个容器</strong></li></ul><h3 id="2-2-2-案例-创建并运行容器，run"><a href="#2-2-2-案例-创建并运行容器，run" class="headerlink" title="2.2.2.案例-创建并运行容器，run"></a>2.2.2.案例-创建并运行容器，run</h3><p>可以看官方方法启动容器 </p><p><a href="https://hub.docker.com/_/nginx">Docker Hub</a></p><p><img src="/adanpro/adanblog/./../pic/05352092dbee49afa5d987e35b1e83d8.png" alt="img"></p><p><strong>创建并运行nginx容器的命令：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker run --name 容器名称 -p 主机端口:需要映射的容器端口 -d 镜像名称</span></span><br><span class="line"></span><br><span class="line">docker run --name mn -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn（my_nginx缩写）</li><li><strong>-p ：将宿主机端口给容器端口映射</strong>，冒号左侧是宿主机端口，右侧是容器端口</li><li><strong>-d：后台运行容器</strong></li><li>nginx：镜像名称，例如nginx</li></ul><blockquote><p><strong>端口映射详解：</strong></p><p>这里的**<code>-p</code><strong>参数，是</strong>将容器端口映射到宿主机端口**。</p><p>默认情况下，<strong>容器是隔离环境</strong>，我们<strong>不能直接访问到容器的80端口</strong>。</p><p>现在，将容器的80与宿主机的80关联起来，当我们<strong>访问宿主机的80端口时</strong>，就会被<strong>映射到容器的80</strong>，<strong>这样访问主机的80端口，就相当于访问容器的80端口</strong>。</p><p><img src="/adanpro/adanblog/./../pic/6add54eeba4f3ef19a5a4ef4d3fddd15.png" alt="image-20210731163255863"></p></blockquote><p><strong>启动容器后生成唯一ID ：</strong></p><p><img src="/adanpro/adanblog/./../pic/6aaa401ae95a4d6da0399deef2f70943.png" alt="img"></p><p><strong>访问主机80端口可以看到Nginx已经运行：</strong></p><p><img src="/adanpro/adanblog/./../pic/84079af20fa94eba9e43c781f6190908.png" alt="img"></p><h3 id="2-2-2-5-查看容器状态、日志"><a href="#2-2-2-5-查看容器状态、日志" class="headerlink" title="2.2.2.5. 查看容器状态、日志"></a>2.2.2.5. 查看容器状态、日志</h3><p><strong>查看所有容器运行状态：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/b68a315a3f8f41c29b36d4a6cf8b4614.png" alt="img"><strong>查看日志：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs mn</span><br></pre></td></tr></table></figure><p><strong>跟踪日志：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f mn</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/72f4d55abbea41fb89ef37062e647334.png" alt="img"></p><h3 id="2-2-3-案例-进入容器，修改文件（不建议）"><a href="#2-2-3-案例-进入容器，修改文件（不建议）" class="headerlink" title="2.2.3.案例-进入容器，修改文件（不建议）"></a>2.2.3.案例-进入容器，修改文件（不建议）</h3><blockquote><p><strong>不建议进入容器修改文件，建议用下面2.3的数据卷。</strong> </p></blockquote><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p><strong>1）进入容器。</strong>进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">exec</span> -it mn bash</span><br></pre></td></tr></table></figure><blockquote><p>exec是execute执行的缩写。 </p></blockquote><p> <strong>命令解读：</strong></p><ul><li>docker exec ：进入容器内部，执行一个命令</li><li><strong>-it :</strong> 给当前进入的<strong>容器创建一个标准输入、输出终端</strong>，允许我们与容器交互</li><li>mn ：要进入的容器的名称</li><li><strong>bash：进入容器后执行的命令</strong>，bash是一个linux终端交互命令</li></ul><p><img src="/adanpro/adanblog/./../pic/cb94c9a3a66d4facf80b95f3e28d0e7b.png" alt="image-20210731164159811"></p><blockquote><p> <strong>退出容器</strong></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p> docker容器里命令是阉割版Linux命令，没有ll和vim，有ls。</p></blockquote><p><strong>2）进入nginx的HTML所在目录</strong> &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p><img src="/adanpro/adanblog/./../pic/ee52d6d24fb543f0a1e8bf3c712f2f6f.png" alt="img"></p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/adanpro/adanblog/./../pic/cb94c9a3a66d4facf80b95f3e28d0e7b.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p><strong>进入html目录：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/share/nginx/html</span><br></pre></td></tr></table></figure><p>查看目录下文件：</p><p><img src="/adanpro/adanblog/./../pic/cb940c233c580197e7be7b5fb2dcb02e.png" alt="image-20210731164455818"></p><p><strong>3）修改index.html的内容</strong></p><p>容器内<strong>没有vi命令</strong>，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">sed -i -e &#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27; -e &#x27;s#<span class="tag">&lt;<span class="name">head</span>&gt;</span>#<span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>#g&#x27; index.html</span><br></pre></td></tr></table></figure><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="/adanpro/adanblog/./../pic/f339fc9f801acc6f4f2354d3c680b097.png" alt="image-20210731164717604"></p><p><strong>4）退出容器</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/e61ce79a377c4a96a6e5301c25784d7f.png" alt="img"></p><h3 id="2-2-4-停止、删除容器"><a href="#2-2-4-停止、删除容器" class="headerlink" title="2.2.4.停止、删除容器"></a>2.2.4.停止、删除容器</h3><p><strong>停止容器：</strong> </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker stop 容器名</span></span><br><span class="line"></span><br><span class="line">docker stop mn</span><br></pre></td></tr></table></figure><p><strong>查看所有容器（包括停止的） ：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/fa489505e5ad4e14962faeb2bd169d46.png" alt="img"></p><p><strong>强制删除容器</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f mn</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/454d9369f2004272a35e295a62bb889d.png" alt="img"></p><h3 id="2-2-5-创建redis容器"><a href="#2-2-5-创建redis容器" class="headerlink" title="2.2.5.创建redis容器"></a>2.2.5.创建redis容器</h3><p><a href="https://hub.docker.com/_/redis">Docker Hub</a></p><p><img src="/adanpro/adanblog/./../pic/3424d83d8db34e9994a20726c64fca7a.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mr -p 6379:6379 -d redis redis-server --appendonly <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it mr bash</span><br><span class="line"></span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure><h3 id="2-2-5-小结"><a href="#2-2-5-小结" class="headerlink" title="2.2.5.小结"></a>2.2.5.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为<strong>容器与数据（容器内文件）耦合</strong>带来的后果。</p><p><img src="/adanpro/adanblog/./../pic/ad0d022abb0b74bdaa47dfea38858a1c.png" alt="image-20210731172440275"></p><p>要解决这个问题，<strong>必须将数据与容器解耦</strong>，这就要用到<strong>数据卷</strong>了。</p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume译为卷，容积，音量）</strong>是一个<strong>虚拟目录，指向宿主机文件系统中的某个目录。</strong></p><p><img src="/adanpro/adanblog/./../pic/81feb2c90a6781e6fc6c0385b69094c0.png" alt="image-20210731173541846"></p><p>一旦完成数据卷挂载，<strong>对容器的一切操作都会作用在数据卷对应的宿主机目录了。</strong></p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了。只要数据卷对应的宿主机目录在，删除再创建容器，数据依然不变。</p><h3 id="2-3-2-数据卷操作命令"><a href="#2-3-2-数据卷操作命令" class="headerlink" title="2.3.2.数据卷操作命令"></a>2.3.2.数据卷操作命令</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">volume</span> <span class="selector-attr">[COMMAND]</span></span><br></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><p><img src="/adanpro/adanblog/./../pic/6ba7ca189ab24a3382e5dbd6f312dedf.png" alt="img"></p><h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p><strong>① 创建数据卷</strong></p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">volume</span> <span class="selector-tag">create</span> <span class="selector-tag">html</span></span><br></pre></td></tr></table></figure><p><strong>② 查看所有数据</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/adanpro/adanblog/./../pic/671e19178c41f8c8c2ed71092253587f.png" alt="image-20210731173746910"></p><p><strong>③ 查看数据卷详细信息卷</strong></p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">volume</span> <span class="selector-tag">inspect</span> <span class="selector-tag">html</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/adanpro/adanblog/./../pic/46516cc24a3e521bb272064ef127ef46.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><blockquote><p><strong>小结</strong>：</p><p><strong>数据卷的作用：</strong></p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p><strong>数据卷操作：</strong></p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul></blockquote><h3 id="2-3-4-挂载数据卷、宿主机目录，-v"><a href="#2-3-4-挂载数据卷、宿主机目录，-v" class="headerlink" title="2.3.4.挂载数据卷、宿主机目录，-v"></a>2.3.4.挂载数据卷、宿主机目录，-v</h3><p><strong>挂载宿主机目录：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mn -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p><strong>挂载数据卷</strong> </p><p>我们在创建容器时，可以通过 -v 参数来<strong>挂载一个数据卷到某个容器内目录</strong>，命令格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line"></span><br><span class="line">  --name mn \</span><br><span class="line"></span><br><span class="line">  -v html:/usr/share/nginx/html \</span><br><span class="line"></span><br><span class="line">  -p 8080:80 \</span><br><span class="line"></span><br><span class="line">  -d nginx </span><br><span class="line"></span><br><span class="line"><span class="comment">#docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span></span><br></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><strong><code>-v html:</code>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html：左边是数据卷名，右边是容器内目录。</strong>把html<strong>数据卷挂载到容器内</strong>的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html这个目录中</li></ul><p>可以看到容器内数据通过挂载数据卷指向的目录里，已经出现初始文件。</p><p><img src="/adanpro/adanblog/./../pic/ac63e13b4a84474f95bdce3fd4e2a530.png" alt="img"></p><p>数据卷挂载与目录直接挂载的</p><ul><li><strong>数据卷挂载耦合度低</strong>，由docker来管理目录，但是目录较深，<strong>不好找</strong></li><li><strong>目录挂载耦合度高</strong>，需要我们自己管理目录，不过目录容易<strong>寻找查看</strong></li></ul><blockquote><p><strong>查看数据卷html的信息 ：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/f748354c3c504eb3be3769e4dd2cfca8.png" alt="img"></p></blockquote><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p><strong>① 创建容器并挂载数据卷到容器内的HTML目录</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p><strong>② 进入html数据卷指向的宿主机位置，并修改HTML内容</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line"></span><br><span class="line">docker volume inspect html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line"></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/ae3311e3112d4ff38e2f7ed5dc58f0a5.png" alt="img"></p><h3 id="2-3-6-docker安装MySQL，挂载本地目录"><a href="#2-3-6-docker安装MySQL，挂载本地目录" class="headerlink" title="2.3.6.docker安装MySQL，挂载本地目录"></a>2.3.6.docker安装MySQL，挂载本地目录</h3><p><strong>docker安装mysql和直接安装的区别：</strong></p><p>1、docker安装快速，效率高;</p><p>2、docker隔离性好，<strong>可以安装无数个mysql实例</strong>，互相不干扰，只要映射主机端口不同即可;</p><p>3、占用资源少，MB级别，而服务器安装GB级别;</p><p>4、启动速度秒级，而服务器安装启动分钟级别;</p><p>5、性能接近原生，而服务器安装较低;</p><p>6、数据备份、迁移，docker更方便强大;</p><p>7、卸载管理更方便和干净，直接删除容器和镜像即可;</p><p>8、稳定性，只要保证docker环境没问题，mysql就没问题。</p><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li><strong>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</strong></li><li><strong>直接挂载模式：宿主机目录 —&gt; 容器内目录</strong></li></ul><p>如图：</p><p><img src="/adanpro/adanblog/./../pic/3c456a893baf504d51f32e331874dd54.png" alt="image-20210731175155453"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li><strong>-v [宿主机目录]:[容器内目录]</strong></li><li><strong>-v [宿主机文件]:[容器内文件]</strong></li></ul><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i mysql.tar</span><br></pre></td></tr></table></figure><p> 也可以拉取</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull mysql:5.7.25</span><br></pre></td></tr></table></figure><p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data 、&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> data</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> my.cnf</span><br><span class="line"></span><br><span class="line">vi my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line">character_set_server=utf8</span><br><span class="line"></span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line">server-id=1000</span><br></pre></td></tr></table></figure><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p><a href="https://hub.docker.com/_/mysql">Docker Hub</a></p><p><strong>注意端口3306占用问题。</strong> </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql -e MYSQL_ROOT_PASSWORD=1234 -p 3306:3306 -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf -v /tmp/mysql/data:/var/lib/mysql -d mysql:5.7.25</span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/6ba56c5e286b4c40b410d226d76a86c4.png" alt="img"></p><p> <img src="/adanpro/adanblog/./../pic/96f43a06810244198d7efb5681755931.png" alt="img"></p><p>使用Navicat可以连接：</p><p><img src="/adanpro/adanblog/./../pic/01d71f8dfb994192b66fb2eec062e9de.png" alt="img"></p><p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p><p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h3 id="Docker-配置Elasticsearch"><a href="#Docker-配置Elasticsearch" class="headerlink" title="Docker 配置Elasticsearch"></a>Docker 配置Elasticsearch</h3><p>Elasticsearch 可以通过命令行参数或者通过 Docker 卷来挂载配置、日志、数据和插件文件。以下是通过 Docker 卷挂载这些文件的步骤：</p><ol><li><p>首先创建一个目录来存储 Elasticsearch 的配置、日志、数据和插件文件，比如 <code>/opt/elasticsearch/data</code>。</p></li><li><p>将 Elasticsearch 的配置文件复制到该目录，如：<code>/opt/elasticsearch/data/elasticsearch.yml</code>。</p></li><li><p>创建一个子目录，用于存储 Elasticsearch 的日志文件，如：<code>/opt/elasticsearch/data/logs</code>。</p></li><li><p>创建另一个子目录，用于存储 Elasticsearch 的数据文件，如：<code>/opt/elasticsearch/data/data</code>。</p></li><li><p>创建另一个子目录，用于存储 Elasticsearch 的插件文件，如：<code>/opt/elasticsearch/data/plugins</code>。</p></li><li><p>运行以下命令来启动 Elasticsearch 容器，并将数据、日志、配置和插件目录都挂载到容器中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name es \</span><br><span class="line"> -p 9200:9200 \</span><br><span class="line"> -p 9300:9300 \</span><br><span class="line"> -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line"> -e ES_JAVA_OPTS=<span class="string">&quot;-Xms256m -Xmx256m&quot;</span> \</span><br><span class="line"> -v /docker/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line"> -v /docker/elasticsearch/data/:/usr/share/elasticsearch/data \</span><br><span class="line"> -v /docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line"> --privileged \</span><br><span class="line"> --network es-net \</span><br><span class="line"> -d elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><ul><li>-e “cluster.name&#x3D;es-docker-cluster”：设置集群名称</li><li>-e “http.host&#x3D;0.0.0.0”：监听的地址，可以外网访问</li><li>-e “ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m”：内存大小</li><li>-e “discovery.type&#x3D;single-node”：非集群模式</li><li>-v &#x2F;mydata&#x2F;elasticsearch&#x2F;data&#x2F;:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data：挂载逻辑卷，绑定es的数据目录</li><li>-v &#x2F;mydata&#x2F;elasticsearch&#x2F;logs&#x2F;:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;logs：挂载逻辑卷，绑定es的日志目录</li><li>-v &#x2F;mydata&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins：挂载逻辑卷，绑定es的插件目录</li><li>–privileged：授予逻辑卷访问权</li><li>–network es-net ：加入一个名为es-net的网络中</li><li>-p 9200:9200：端口映射配置，这里是9200是暴露的http协议端口，用于用户访问</li><li>-p 9300:9300：es各个容器之间互联的端口，暂时用不到，不暴露也行，</li></ul></li><li><p>运行命令 <code>docker ps</code> 来确认 Elasticsearch 容器已经启动。</p></li></ol><p>​docker以挂载配置文件启动elasticsearch的时候会报如下错误：</p><p><img src="/adanpro/adanblog/./../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDQyOTM1,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>看错误我们会以为是es容器里的&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data&#x2F;nodes文件夹目录没有读写权限，其实给提示误导了，实际是挂载的目录没有读写权限。比如我们宿主主机的配置目录为:&#x2F;usr&#x2F;local&#x2F;es&#x2F;data，那么我们需要赋予它读写权限：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">chmod</span> <span class="string">777 /usr/local/es/data</span></span><br></pre></td></tr></table></figure><p>重新启动，问题不再存在。</p><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana 可以使用命令行参数或者通过 Docker 卷来挂载配置文件。以下是通过 Docker 卷挂载配置文件的步骤：</p><ol><li><p>首先创建一个配置文件目录，如：<code>/docker/kibana/config</code>。</p></li><li><p>将 Kibana 的配置文件复制到该目录中，如：<code>/docker/kibana/config/kibana.yml</code>。</p></li><li><p>使用以下命令来运行 Kibana，同时将配置文件目录挂载到容器中：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run -d \</span></span><br><span class="line"><span class="string">--name kibana \</span></span><br><span class="line"><span class="string">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span></span><br><span class="line"><span class="string">--network=es-net \</span></span><br><span class="line"><span class="string">-p 5601:5601  \</span></span><br><span class="line"><span class="string">kibana:7.12.1</span></span><br></pre></td></tr></table></figure><p>上述命令会将本地目录 <code>/opt/kibana/config</code> 挂载到容器内的 <code>/usr/share/kibana/config</code>，以便 Kibana 能够访问该目录下的配置文件。</p><ul><li>–network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li>-e ELASTICSEARCH_HOSTS&#x3D;<a href="http://es:9200"：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch">http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</a></li><li>-p 5601:5601：端口映射配置</li><li>运行命令 <code>docker ps</code> 来确认 Kibana 容器已经启动。</li><li>访问 <code>http://localhost:5601</code> 来验证 Kibana 是否能够正常访问并加载配置文件。</li></ul></li></ol><h3 id="Kibana中文配置"><a href="#Kibana中文配置" class="headerlink" title="Kibana中文配置"></a>Kibana中文配置</h3><p>我们发现<code>Kibana</code>是英文面板，看起来不是很方便，但<code>Kibana</code>是支持中文配置，所以我们可以把<code>Kibana</code>配置成中文版，便于我们操作。</p><p>切换中文操作如下:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码#进入容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">exec -it kibana /bin/bash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#进入配置文件目录</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">/usr/share/kibana/config</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#编辑文件kibana.yml</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">kibana.yml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#在最后一行添加如下配置</span></span><br><span class="line"><span class="attr">i18n.locale</span>: <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保存退出</span></span><br><span class="line"><span class="attr">exit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#并重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart kibana</span></span><br></pre></td></tr></table></figure><h2 id="IK分词器安装"><a href="#IK分词器安装" class="headerlink" title="IK分词器安装"></a>IK分词器安装</h2><p>我们打开<code>Kibana</code>，点击开发工具，操作如下：</p><p><img src="/adanpro/adanblog/./../pic/mark4536000.png" alt="img"></p><p>输入如下操作，用于查询分词：</p><p><img src="/adanpro/adanblog/./../pic/25233542.png" alt="img"></p><p>上图测试代码如下:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;IT门徒，带你打开通往梦想的门！&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>表示使用<code>standard</code>对<code>IT门徒，带你打开通往梦想的门！</code>进行分词。</p><p><code>分词</code>：提取一句话或者一篇文章中的词语。</p><p>我们在使用<code>ElasticSearch</code>的时候，默认用<code>standard</code>分词器，但<code>standard</code>分词器使用的是按空格分词，这种分词操作方法不符合中文分词标准，我们需要额外安装中文分词器。</p><p> </p><h3 id="4-1-IK分词器介绍"><a href="#4-1-IK分词器介绍" class="headerlink" title="4.1 IK分词器介绍"></a>4.1 IK分词器介绍</h3><p><code>IK Analyzer</code>是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始， <code>IKAnalyzer</code>已经推出了多个大版本。最初，它是以开源项目<code>Luence</code>为应用主体的，结合词典分词和文法分析算法的中文分词组件。<code>IK Analyzer</code>则发展为面向<code>Java</code>的公用分词组件，独立于<code>Lucen</code>e项目，同时提供了对<code>Lucene</code>的默认优化实现。</p><p> </p><p><code>ElasticSearch</code>内核其实就是基于<code>Lucene</code>，所以我们可以直接在<code>ElasticSearch</code>中集成IK分词器，<code>IK</code>分词器集成<code>ElasticSearch</code>下载地址：<a href="https://link.juejin.cn/?target=https://github.com/medcl/elasticsearch-analysis-ik/releases">github.com&#x2F;medcl&#x2F;elast…</a></p><p><img src="/adanpro/adanblog/./../pic/mark4asda536000.png" alt="image-20220102125305738"></p><p> </p><h3 id="4-2-IK分词器配置"><a href="#4-2-IK分词器配置" class="headerlink" title="4.2 IK分词器配置"></a>4.2 IK分词器配置</h3><p>下载安装包<code>elasticsearch-analysis-ik-7.12.1.zip</code>后，并解压，目录如下：</p><p><img src="/adanpro/adanblog/./../pic/sdadadada.png" alt="img"></p><p>我们只需要将上面<code>elasticsearch-analysis-ik-7.12.1</code>拷贝到<code>ElasticSearch</code>的<code>plugins</code>目录中即可，但由于当前服务采用的是<code>docker</code>安装，所以需要将文件拷贝到<code>docker</code>容器的<code>plugins</code>目录才行。</p><p>操作如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码#为了方便配置，我们将elasticsearch-analysis-ik-7.12.1改成ik文件夹</span></span><br><span class="line"><span class="attr">mv</span> <span class="string">elasticsearch-analysis-ik-7.12.1 ik</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#将ik文件夹拷贝到elasticsearch容器中</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp ik elasticsearch:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br></pre></td></tr></table></figure><p>操作效果如下：</p><p><img src="/adanpro/adanblog/./../pic/adawadasd.png" alt="img"></p><p> </p><p>作者：bysecby<br>链接：<a href="https://juejin.cn/post/7074115690340286472">https://juejin.cn/post/7074115690340286472</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="分词测试"><a href="#分词测试" class="headerlink" title="分词测试"></a>分词测试</h3><p><code>IK</code>分词器包含两种模式：</p><ul><li><code>ik_smart</code>：最少切分</li><li><code>ik_max_word</code>：最细切分</li></ul><p> </p><p>前面使用默认的<code>standard</code>分词器，对中文分词非常难用，安装IK分词器后，我们可以使用IK分词器测试，测试代码如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;IT门徒，带你打开通往梦想的门！&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>测试效果如下：</p><p><img src="/adanpro/adanblog/./../pic/sadasffadsj.png" alt="img"></p><p>我们可以发现对中文的分词效果是比较不错的，但也存在一些不足，比如<code>梦想的门</code>我们希望它是一个词，而<code>带你</code>我们希望它不被识别一个词，又该如何实现呢？</p><p> </p><h3 id="4-4-IK自定义词典"><a href="#4-4-IK自定义词典" class="headerlink" title="4.4 IK自定义词典"></a>4.4 IK自定义词典</h3><p>IK分词器支持自定义词典，包括自定义分词，也包含自定义停用分词，操作起来也非常简单。我们接下来实现一下自定义词典和停用词典。</p><p> </p><h4 id="4-4-1-自定义词典"><a href="#4-4-1-自定义词典" class="headerlink" title="4.4.1 自定义词典"></a>4.4.1 自定义词典</h4><p>自定义词典，需要先创建自己的词典，再引用自己的词典即可。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码1</span>:<span class="string">创建词典</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">引用词典</span></span><br></pre></td></tr></table></figure><p> </p><p>1)创建词典</p><p>在<code>config</code>中创建自己的词典，例如叫<code>itmentu_ext.dic</code>，在文件中添加自定义的词语，操作如下：</p><p><img src="/adanpro/adanblog/./../pic/gsgdfgdas.png" alt="img"></p><p>我们把自定义的词典<code>梦想的门</code>添加到了<code>itmentu_ext.dic</code>中了，这就是创建词典，如果后多个自定义次，需要换行加入，这里一定要注意中文分词设置编码格式为<code>UTF-8</code>。</p><p> </p><p>2)引用词典</p><p>修改<code>config/IKAnalyzer.cfg.xml</code>引用自己创建的<code>itmentu_ext.dic</code>词典，配置如下:</p><p><img src="/adanpro/adanblog/./../pic/dsadasas.png" alt="img"></p><p>上图代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xml复制代码<span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>itmentu_ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们将改好的文件重新上传到<code>elasticsearch</code>容器的<code>/usr/share/elasticsearch/plugins</code>目录下，重启<code>elasticsearch</code>容器即可。</p><p>操作如下:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码#将上传的config拷贝到服务器</span></span><br><span class="line"><span class="comment">#将ik文件夹拷贝到elasticsearch容器中</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp ik elasticsearch:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br></pre></td></tr></table></figure><p> </p><p>在使用<code>Kibana</code>测试 <code>http://192.168.211.130:5601/app/dev_tools#/console</code> 效果如下：</p><p><img src="/adanpro/adanblog/./../pic/asdasd4536000.png" alt="img"></p><p> </p><h4 id="4-4-2-自定义停用词汇"><a href="#4-4-2-自定义停用词汇" class="headerlink" title="4.4.2 自定义停用词汇"></a>4.4.2 自定义停用词汇</h4><p>自定义停用词典和自定义词典一样，需要先创建自己的词典，再引用自己的词典即可。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码1</span>:<span class="string">创建词典</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">引用词典</span></span><br></pre></td></tr></table></figure><p> </p><p>1)创建词典</p><p>在<code>config</code>中创建自己的停用词典，例如叫<code>itmentu_stop.dic</code>，在文件中添加自定义的停用词语，操作如下：</p><p><img src="/adanpro/adanblog/./../pic/esgsgdgsd.png" alt="img"></p><p> </p><p>2)引用词典</p><p>修改<code>config/IKAnalyzer.cfg.xml</code>引用自己创建的<code>itmentu_stop.dic</code>停用词典，配置如下:</p><p><img src="/adanpro/adanblog/./../pic/dasfksjsbf.png" alt="img"></p><p>上图代码如下:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xml复制代码<span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>itmentu_ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>itmentu_stop.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们将改好的文件重新上传到<code>elasticsearch</code>容器的<code>/usr/share/elasticsearch/plugins</code>目录下，重启<code>elasticsearch</code>容器即可。</p><p>操作如下:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码#将上传的config拷贝到服务器</span></span><br><span class="line"><span class="comment">#将ik文件夹拷贝到elasticsearch容器中</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp ik elasticsearch:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br></pre></td></tr></table></figure><p> </p><p>在使用<code>Kibana</code>测试 <code>http://192.168.211.130:5601/app/dev_tools#/console</code> 效果如下：</p><p><img src="/adanpro/adanblog/./../pic/dasashdbasjd.png" alt="immg"></p><p>我们可以发现，不再有<code>带你</code>的分词了，说明停用分词也生效了。</p><p> 安装IK分词器</p><p><code>ElasticSearch</code>内核其实就是基于<code>Lucene</code>，所以我们可以直接在<code>ElasticSearch</code>中集成IK分词器，<code>IK</code>分词器集成<code>ElasticSearch</code>下载地址：<a href="https://link.juejin.cn/?target=https://github.com/medcl/elasticsearch-analysis-ik/releases">github.com&#x2F;medcl&#x2F;elast…</a></p><p><img src="/adanpro/adanblog/./../pic/image-20230628011926248.png" alt="img"></p><p> <strong>IK分词器配置</strong></p><p>下载安装包<code>elasticsearch-analysis-ik-7.12.1.zip</code>后，并解压，目录如下：</p><p><img src="/adanpro/adanblog/./../pic/image-20230628011943856.png" alt="img"></p><p>我们只需要将上面<code>elasticsearch-analysis-ik-7.12.1</code>拷贝到<code>ElasticSearch</code>的<code>plugins</code>目录中即可，但由于当前服务采用的是<code>docker</code>安装，所以需要将文件拷贝到<code>docker</code>容器的<code>plugins</code>目录才行。</p><p>操作如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties复制代码#为了方便配置，我们将elasticsearch-analysis-ik-7.12.1改成ik文件夹</span></span><br><span class="line"><span class="attr">mv</span> <span class="string">elasticsearch-analysis-ik-7.12.1 ik</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#将ik文件夹拷贝到elasticsearch容器中</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp ik elasticsearch:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br></pre></td></tr></table></figure><p>操作效果如下：</p><p><img src="/adanpro/adanblog/./../pic/image-20230628012039658.png" alt="img"></p><h2 id="5-ElasticSearch集群安装"><a href="#5-ElasticSearch集群安装" class="headerlink" title="5 ElasticSearch集群安装"></a>5 ElasticSearch集群安装</h2><p>部署es集群可以直接使用<code>docker-compose</code>来完成，不过要求你的Linux虚拟机至少有<strong>4G</strong>的内存空间。</p><p>首先我们需要创建docker-compose脚本，再运行脚本实现安装即可，集群配置脚本如下<code>elasticsearch.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">yaml复制代码version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=elasticsearch01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=elasticsearch01,elasticsearch01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=elasticsearch01,elasticsearch01,elasticsearch01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=elasticsearch02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=elasticsearch01,elasticsearch03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=elasticsearch01,elasticsearch02,elasticsearch03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=elasticsearch03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=elasticsearch01,elasticsearch02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=elasticsearch01,elasticsearch02,elasticsearch03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li><strong>数据卷挂载耦合度低</strong>，由docker来管理目录，但是目录较深，<strong>不好找</strong></li><li><strong>目录挂载耦合度高</strong>，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p><strong>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</strong></p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="/adanpro/adanblog/./../pic/af98495dfdbcdfd9a41b9cca4a46d432.png" alt="image-20210731175806273"></p><p><strong>分层操作可以提高更新版本时的复用性。</strong> </p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile就是一个文本文件</strong>，其中<strong>包含</strong>一个个的<strong>指令(Instruction)<strong>，用指令来说明要执行什么操作来构建镜像。</strong>每一个指令都会形成一层Layer</strong>。</p><p><img src="/adanpro/adanblog/./../pic/105e7226c9eb7bbb01424b1883e0b2aa.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-3-使用Dockerfile构建Java项目的镜像"><a href="#3-3-使用Dockerfile构建Java项目的镜像" class="headerlink" title="3.3.使用Dockerfile构建Java项目的镜像"></a>3.3.使用<strong>Dockerfile</strong>构建Java项目的镜像</h2><h3 id="3-3-1-基于Ubuntu构建Java项目（不推荐）"><a href="#3-3-1-基于Ubuntu构建Java项目（不推荐）" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目（不推荐）"></a>3.3.1.基于Ubuntu构建Java项目（不推荐）</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p><strong>步骤1：新建一个空文件夹docker-demo</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> docker-demo</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> docker-demo</span><br></pre></td></tr></table></figure></li><li><p><strong>步骤2：</strong>拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p><p><img src="/adanpro/adanblog/./../pic/dd947d11dd90e6dfd081211db622af21.png" alt="image-20210801101314816"></p></li><li><p><strong>步骤3：</strong>拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="/adanpro/adanblog/./../pic/984f3bac0236cc37f20fd17eac1b3382.png" alt="image-20210801101410200"></p></li><li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p><p><img src="/adanpro/adanblog/./../pic/bb3dc09bbf5c3206c9cff7f3e523a3d0.png" alt="image-20210801101455590"></p><p>其中的内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line">ENV JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line">COPY ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span><br><span class="line">COPY ./docker-demo.jar /tmp/app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line">RUN <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span><br><span class="line"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="line"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">ENV JAVA_HOME=<span class="variable">$JAVA_DIR</span>/java8</span><br><span class="line">ENV PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 8090</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最后面的空格点别忘了</span></span><br><span class="line"></span><br><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure></li></ul><p>创建容器 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name web -p 8090:8090 -d javaweb:1.0</span><br></pre></td></tr></table></figure><p>最后访问 http:&#x2F;&#x2F;虚拟机ip地址:8090&#x2F;hello&#x2F;count，其中的ip改成你的虚拟机ip</p><h3 id="3-3-2-基于java8构建Java项目（推荐）"><a href="#3-3-2-基于java8构建Java项目（推荐）" class="headerlink" title="3.3.2.基于java8构建Java项目（推荐）"></a>3.3.2.基于java8构建Java项目（推荐）</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p><strong>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</strong></p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM java:8-alpine</span><br><span class="line"></span><br><span class="line">COPY ./docker-demo.jar /tmp/app.jar</span><br><span class="line"></span><br><span class="line">EXPOSE 8090</span><br><span class="line"></span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure></li></ul></li><li><p>④ 使用docker build命令构建镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最后面的空格点别忘了，表示在当前目录下构建镜像</span></span><br><span class="line"></span><br><span class="line">docker build -t javaweb:2.0 .</span><br></pre></td></tr></table></figure></li><li><p>⑤ 使用docker run创建容器并运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name web -p 8090:8090 -d javaweb:2.0</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p><ol><li>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</li><li>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</li><li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</li></ol><h1 id="4-Docker-Compose，部署分布式项目"><a href="#4-Docker-Compose，部署分布式项目" class="headerlink" title="4.Docker-Compose，部署分布式项目"></a>4.Docker-Compose，部署分布式项目</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="/adanpro/adanblog/./../pic/91d040e2dd611dbfaba23ea33930edfd.png" alt="image-20210731180921742"></p><h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>compose译为生成，组成，写作。 </p><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7.25</span><br><span class="line">    environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: 123 </span><br><span class="line">    volumes:</span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#临时构建镜像并运行</span></span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录。这里不需要暴露端口，因为微服务集群部署，集群内部能访问即可，不用暴露。</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><h3 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1.下载"></a>4.2.1.下载</h3><p>Linux下需要通过命令下载：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.4.安装</span></span><br><span class="line"></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h3 id="4-2-2-修改文件权限"><a href="#4-2-2-修改文件权限" class="headerlink" title="4.2.2.修改文件权限"></a>4.2.2.修改文件权限</h3><p>修改文件权限，给执行权：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.4.修改权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="4-2-3-Base自动补全命令："><a href="#4-2-3-Base自动补全命令：" class="headerlink" title="4.2.3.Base自动补全命令："></a>4.2.3.Base自动补全命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.4.补全命令</span></span><br><span class="line"></span><br><span class="line">curl -L http://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件然后重启systemctl restart docke、新建shell窗口：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-初始compose、Dockerfile介绍"><a href="#4-3-1-初始compose、Dockerfile介绍" class="headerlink" title="4.3.1.初始compose、Dockerfile介绍"></a>4.3.1.初始compose、Dockerfile介绍</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="/adanpro/adanblog/./../pic/ec8040fddcea914ff71702ca0dd1fb41.png" alt="image-20210731181341330"></p><p><strong>docker-compose.yml</strong>内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3.2&quot;</span></span><br><span class="line">services:</span><br><span class="line">  nacos:</span><br><span class="line">    image: nacos/nacos-server</span><br><span class="line">    environment:</span><br><span class="line"><span class="comment">#nacos启动命令startup.cmd -m standalone</span></span><br><span class="line">      MODE: standalone</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7.25</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;<span class="variable">$PWD</span>/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      - <span class="string">&quot;<span class="variable">$PWD</span>/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line"></span><br><span class="line">  userservice:</span><br><span class="line">    build: ./user-service</span><br><span class="line">  orderservice:</span><br><span class="line">    build: ./order-service</span><br><span class="line">  gateway:</span><br><span class="line">    build: ./gateway</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><pre><code>nacos<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：作为注册中心和配置中心</span><br><span class="line"></span><br><span class="line">- `image: nacos/nacos-server`： 基于nacos/nacos-server镜像构建</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  environment</span><br></pre></td></tr></table></figure>  ：环境变量  - `MODE: standalone`：单点模式启动- `ports`：端口映射，这里暴露了8848端口</code></pre></li><li><pre><code>mysql<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：数据库</span><br><span class="line"></span><br><span class="line">- `image: mysql:5.7.25`：镜像版本是mysql:5.7.25</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  environment</span><br></pre></td></tr></table></figure>  ：环境变量  - `MYSQL_ROOT_PASSWORD: 123`：设置数据库root账户的密码为123- `volumes`：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</code></pre></li><li><p><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</p></li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="/adanpro/adanblog/./../pic/4def64fdcf493e420ad35f0b38eeb0d6.png" alt="image-20210801095205034"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="/adanpro/adanblog/./../pic/4e03d98a653a442c4165fe201913ad47.png" alt="image-20210801095320586"></p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM java:8-alpine</span><br><span class="line"></span><br><span class="line">COPY ./app.jar /tmp/app.jar</span><br><span class="line"></span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure><h3 id="4-3-2-修改微服务配置，localhost改服务名"><a href="#4-3-2-修改微服务配置，localhost改服务名" class="headerlink" title="4.3.2.修改微服务配置，localhost改服务名"></a>4.3.2.修改微服务配置，localhost改服务名</h3><p>用<strong>docker-compose</strong>部署微服务时，<strong>所有服务之间用服务名互相访问。</strong></p><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"></span><br><span class="line">  datasource:</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里mysql还是有端口的，仅用于服务内调用，docker-compose就不配置端口</span></span><br><span class="line"></span><br><span class="line">    url: jdbc:mysql://mysql:3306/cloud_order?useSSL=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    username: root</span><br><span class="line"></span><br><span class="line">    password: 123</span><br><span class="line"></span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">  application:</span><br><span class="line"></span><br><span class="line">    name: orderservice</span><br><span class="line"></span><br><span class="line">  cloud:</span><br><span class="line"></span><br><span class="line">    nacos:</span><br><span class="line"></span><br><span class="line">      server-addr: nacos:8848 <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure><h3 id="4-3-3-所有服务打包成app-jar"><a href="#4-3-3-所有服务打包成app-jar" class="headerlink" title="4.3.3.所有服务打包成app.jar"></a>4.3.3.所有服务打包成app.jar</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，<strong>除了父工程和feign-api每个微服务的pom都需要修改：</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打包后：</p><p><img src="/adanpro/adanblog/./../pic/f2ab239040d6197bea52444429f80bec.png" alt="image-20210801095951030"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="/adanpro/adanblog/./../pic/e67b8dfcab8bbcdad0eddecf91ff3b55.png" alt="image-20210801100201253"></p><p>order-service：</p><p><img src="/adanpro/adanblog/./../pic/758c9f270769e01c567e6428766273ab.png" alt="image-20210801100231495"></p><p>gateway：</p><p><img src="/adanpro/adanblog/./../pic/2053a906b10eb995ebaf071ba42e6415.png" alt="image-20210801100308102"></p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="/adanpro/adanblog/./../pic/d6f3eef975193a3917da2b5599652d74.png" alt="image-20210801100955653"></p><p><strong>部署：</strong></p><p>进入cloud-demo目录后，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>如果nacos没有第一个启动，会报错，此时要重启nacos外的服务 </p><p><img src="/adanpro/adanblog/./../pic/f17426acda5247fdb6b0189e24723dc6.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose restart gateway userservice orderservice</span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><p>查看命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>重启：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose restart -d</span><br></pre></td></tr></table></figure><p>终止：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">Docker Hub</a></p><h3 id="5-1-1-简化版镜像仓库"><a href="#5-1-1-简化版镜像仓库" class="headerlink" title="5.1.1.简化版镜像仓库"></a>5.1.1.简化版镜像仓库</h3><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line"></span><br><span class="line">    --restart=always \</span><br><span class="line"></span><br><span class="line">    --name registry\</span><br><span class="line"></span><br><span class="line">    -p 5000:5000 \</span><br><span class="line"></span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line"></span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h3 id="5-1-2-带有图形化界面版本"><a href="#5-1-2-带有图形化界面版本" class="headerlink" title="5.1.2.带有图形化界面版本"></a>5.1.2.带有图形化界面版本</h3><p><strong>1.配置Docker信任地址</strong></p><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.4.打开要修改的文件</span></span><br><span class="line"></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1.4.添加内容：</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1.4.重加载</span></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1.4.重启docker</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p><strong>2.启动</strong></p><p> 使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> registry-ui</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> registry-ui</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> docker-compose.yml</span><br><span class="line"></span><br><span class="line">vi docker-compose.yml</span><br></pre></td></tr></table></figure><p>将下面内容复制粘贴进去： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  registry:</span><br><span class="line"></span><br><span class="line">    image: registry</span><br><span class="line"></span><br><span class="line">    volumes:</span><br><span class="line"></span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line"></span><br><span class="line">  ui:</span><br><span class="line"></span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line"></span><br><span class="line">    ports:</span><br><span class="line"></span><br><span class="line">      - 8080:80</span><br><span class="line"></span><br><span class="line">    environment:</span><br><span class="line"></span><br><span class="line">      - REGISTRY_TITLE=传智教育私有仓库</span><br><span class="line"></span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line"></span><br><span class="line">    depends_on:</span><br><span class="line"></span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure><p>然后启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><strong>3.浏览器访问</strong></p><p><a href="http://centos的ip地址:8080/">http://centos的ip地址:8080</a></p><p><img src="/adanpro/adanblog/./../pic/42311c11e4f94ede895e58346845b86c.png" alt="img"></p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务**必须先tag重命名，给镜像前加”ip地址:8080&#x2F;“**，步骤如下：</p><p><strong>① 重新tag本地镜像</strong>，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p><strong>② 推送镜像（确保tag过）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p><strong>③ 拉取镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p><img src="/adanpro/adanblog/./../pic/image-20230628012704828.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证授权</title>
      <link href="/adanpro/adanblog/2023/06/28/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/"/>
      <url>/adanpro/adanblog/2023/06/28/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-模块需求分析"><a href="#1-模块需求分析" class="headerlink" title="1 模块需求分析"></a><strong>1 模块需求分析</strong></h1><h2 id="1-1-什么是认证授权"><a href="#1-1-什么是认证授权" class="headerlink" title="1.1 什么是认证授权"></a><strong>1.1 什么是认证授权</strong></h2><p>截至目前，项目已经完成了课程发布功能，课程发布后用户通过在线学习页面点播视频进行学习。如何去记录学生的学习过程呢？要想掌握学生的学习情况就需要知道用户的身份信息，记录哪个用户在什么时间学习什么课程，如果用户要购买课程也需要知道用户的身份信息。所以，去管理学生的学习过程最基本的要实现用户的身份认证。</p><p>认证授权模块实现平台所有用户的身份认证与用户授权功能。</p><p>什么是用户身份认证？</p><p>​    用户身份认证即用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问。常见的用户身份认证的表现形式有：用户名密码登录，微信扫码等方式。</p><p>项目包括学生、学习机构的老师、平台运营人员三类用户，不管哪一类用户在访问项目受保护资源时都需要进行身份认证。比如：发布课程操作，需要学习机构的老师首先登录系统成功，然后再执行发布课程操作。创建订单，需要学生用户首先登录系统，才可以创建订单。如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps74.jpg" alt="img"> </p><p>什么是用户授权？</p><p>​    用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的权限，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫用户授权。比如：用户去发布课程，系统首先进行用户身份认证，认证通过后继续判断用户是否有发布课程的权限，如果没有权限则拒绝继续访问系统，如果有权限则继续发布课程。如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps75.jpg" alt="img"> </p><h2 id="1-2-业务流程"><a href="#1-2-业务流程" class="headerlink" title="1.2 业务流程"></a><strong>1.2 业务流程</strong></h2><p><strong>1.2.1 统一认证</strong></p><p>项目包括学生、学习机构的老师、平台运营人员三类用户，三类用户将使用统一的认证入口，如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps76.jpg" alt="img"> </p><p>用户输入账号和密码提交认证，认证通过则继续操作。</p><p>项目由统一认证服务受理用户的认证请求，如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps77.jpg" alt="img"> </p><p>认证通过由认证服务向给用户颁发令牌，相当于访问系统的通行证，用户拿着令牌去访问系统的资源。</p><p><strong>1.2.2 单点登录</strong></p><p>本项目基于微服务架构构建，微服务包括：内容管理服务、媒资管理服务、学习中心服务、系统管理服务等，为了提高用户体验性，用户只需要认证一次便可以在多个拥有访问权限的系统中访问，这个功能叫做单点登录。</p><p>引用百度百科：单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><p>如下图，用户只需要认证一次，便可以在多个拥有访问权限的系统中访问。</p><p><img src="/adanpro/adanblog/./../pic/wps78.jpg" alt="img"> </p><p><strong>1.2.3 第三方认证</strong></p><p>为了提高用户体验，很多网站有扫码登录的功能，如：微信扫码登录、QQ扫码登录等。扫码登录的好处是用户不用输入账号和密码，操作简便，另外一个好处就是有利于用户信息的共享，互联网的优势就是资源共享，用户也是一种资源，对于一个新网站如果让用户去注册是很困难的，如果提供了微信扫码登录将省去用户注册的成本，是一种非常有效的推广手段。</p><p>微信扫码登录其中的原理正是使用了第三方认证，如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps79.jpg" alt="img"> </p><h1 id="2-Spring-Security-认证研究"><a href="#2-Spring-Security-认证研究" class="headerlink" title="2 Spring Security 认证研究"></a><strong>2 Spring Security 认证研究</strong></h1><h2 id="2-1-Spring-Security介绍"><a href="#2-1-Spring-Security介绍" class="headerlink" title="2.1 Spring Security介绍"></a><strong>2.1 Spring Security介绍</strong></h2><p>认证功能几乎是每个项目都要具备的功能，并且它与业务无关，市面上有很多认证框架，如：Apache Shiro、CAS、Spring Security等。由于本项目基于Spring Cloud技术构建，Spring Security是spring家族的一份子且和Spring Cloud集成的很好，所以本项目选用Spring Security作为认证服务的技术框架。</p><p>Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架，它是一个专注于为 Java 应用程序提供身份验证和授权的框架。</p><p>项目主页：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a></p><p>Spring cloud Security： <a href="https://spring.io/projects/spring-cloud-security">https://spring.io/projects/spring-cloud-security</a></p><h2 id="2-2-认证授权入门"><a href="#2-2-认证授权入门" class="headerlink" title="2.2 认证授权入门"></a><strong>2.2 认证授权入门</strong></h2><h3 id="2-2-1-创建认证服务工程"><a href="#2-2-1-创建认证服务工程" class="headerlink" title="2.2.1 创建认证服务工程"></a><strong>2.2.1 创建认证服务工程</strong></h3><p>下边我们使用Spring Security框架快速构建认证授权功能体系。</p><p>1、部署认证服务工程</p><p>从课程资料中拷贝xuecheng-plus-auth工程到自己的工程目录下。</p><p>此工程是一个普通的spring boot工程，可以连接数据库。</p><p>此工程不具备认证授权的功能。</p><p>2、创建数据库</p><p>创建xc_users数据库</p><p>导入课程资料中的xcplus_users.sql脚本。</p><p><img src="/adanpro/adanblog/./../pic/wps80.jpg" alt="img"> </p><p>在nacos中新增auth-service-dev.yaml：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">YAML</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">servlet</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">context-path</span>: <span class="string">/auth</span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">63070</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">jdbc:mysql://192.168.101.65:3306/xc1010_users?serverTimezone=UTC&amp;userUnicode=true&amp;useSSL=false&amp;</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">root</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p>初始工程自带了一个Controller类，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="keyword">package</span> com.xuecheng.auth.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/27 17:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  XcUserMapper userMapper;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/login-success&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">loginSuccess</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> XcUser <span class="title function_">getuser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span>&#123;</span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> userMapper.selectById(id);</span><br><span class="line">    <span class="keyword">return</span> xcUser;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/r/r1&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">r1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;访问r1资源&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/r/r2&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">r2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;访问r2资源&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动工程，尝试访问<a href="http://localhost:63070/auth/r/r1">http://localhost:63070/auth/r/r1</a> :</p><p><img src="/adanpro/adanblog/./../pic/wps81.jpg" alt="img"> </p><p>访问用户信息：<a href="http://localhost:63070/auth/user/52">http://localhost:63070/auth/user/52</a> </p><p><img src="/adanpro/adanblog/./../pic/wps82.jpg" alt="img"> </p><p>以上测试一切正常说明此工程部署成功。</p><h3 id="认证测试"><a href="#认证测试" class="headerlink" title="认证测试"></a><strong>认证测试</strong></h3><p>下边向auth认证工程集成Spring security，向pom.xml加入Spring Security所需要的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启工程，访问<a href="http://localhost:63070/auth/r/r1">http://localhost:63070/auth/r/r1</a></p><p>自动进入&#x2F;login登录页面，&#x2F;login是spring security提供的,此页面有几个css样式加载会稍微慢点，如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps83.jpg" alt="img"> </p><p>账号和密码是多少呢？下一步需要进行安全配置。</p><p>拷贝课程资料下的WebSecurityConfig.java到config下需要三部分内容：</p><p>1、用户信息</p><p>在内存配置两个用户：zhangsan、lisi</p><p>zhangsan用户拥有的权限为p1</p><p>lisi用户拥有的权限为p2</p><p>2、密码方式</p><p>暂时采用明文方式</p><p>3、安全拦截机制</p><p>&#x2F;r&#x2F;**开头的请求需要认证</p><p>登录成功到成功页面</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置用户信息服务</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">            manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;456&quot;</span>).authorities(<span class="string">&quot;p2&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//密码为明文方式</span></span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置安全拦截机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/**&quot;</span>).authenticated()<span class="comment">//访问/r开始的请求需要认证通过</span></span><br><span class="line">                .anyRequest().permitAll()<span class="comment">//其它请求全部放行</span></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().successForwardUrl(<span class="string">&quot;/login-success&quot;</span>);<span class="comment">//登录成功跳转到/login-success</span></span><br><span class="line">                http.logout().logoutUrl(<span class="string">&quot;/logout&quot;</span>);<span class="comment">//退出地址</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重启工程</p><p>1、访问<a href="http://localhost:63070/auth/user/52">http://localhost:63070/auth/user/52</a>  可以正常访问</p><p>2、访问<a href="http://localhost:63070/auth/r/r1">http://localhost:63070/auth/r/r1</a> 显示登录页面</p><p>账号zhangsan，密码为123，如果输入的密码不正确会认证失败，输入正确显示登录成功。</p><p>为什么<a href="http://localhost:63070/auth/user/52">http://localhost:63070/auth/user/52</a>  可以正常访问，访问<a href="http://localhost:63070/auth/r/r1">http://localhost:63070/auth/r/r1</a> 显示登录页面？</p><p>http.logout().logoutUrl(“&#x2F;logout”);配置了退出页面，认证成功后访问&#x2F;logout可退出登录。</p><h3 id="2-2-3-授权测试"><a href="#2-2-3-授权测试" class="headerlink" title="2.2.3 授权测试"></a><strong>2.2.3 授权测试</strong></h3><p>用户认证通过去访问系统资源时spring security进行授权控制，判断用户是否有该资源的访问权限，如果有则继续访问，如果没有则拒绝访问。</p><p>下边测试授权功能：</p><p>1、配置用户拥有哪些权限。</p><p>在WebSecurityConfig类配置zhangsan拥有p1权限，lisi拥有p2权限。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;456&quot;</span>).authorities(<span class="string">&quot;p2&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、指定资源与权限的关系。</p><p>什么是系统的资源？</p><p>比如：查询一个用户的信息，用户信息就是系统的资源，要访问资源需要通过URL，所以我们在controller中定义的每个http的接口就是访问资源的接口。</p><p>下边在controller中配置&#x2F;r&#x2F;r1需要p1权限，&#x2F;r&#x2F;r2需要p2权限。</p><p>hasAuthority(‘p1’)表示拥有p1权限方可访问。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/r/r1&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;p1&#x27;)&quot;)</span><span class="comment">//拥有p1权限方可访问</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">r1</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;访问r1资源&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/r/r2&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;p2&#x27;)&quot;)</span><span class="comment">//拥有p2权限方可访问</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">r2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;访问r2资源&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>现在重启工程。</p><p>当访问以&#x2F;r&#x2F;开头的url时会判断用户是否认证，如果没有认证则跳转到登录页面，如果已经认证则判断用户是否具有该URL的访问权限，如果具有该URL的访问权限则继续，否则拒绝访问。</p><p>例如：</p><p>访问&#x2F;r&#x2F;r1，使用zhangsan登录可以正常访问，因为在&#x2F;r&#x2F;r1的方法上指定了权限p1，zhangsan用户拥有权限p1,所以可以正常访问。</p><p>访问&#x2F;r&#x2F;r1，使用lisi登录则拒绝访问，由于lisi用户不具有权限p1需要拒绝访问</p><p>注意：如果访问上不加@PreAuthorize，此方法没有授权控制。</p><p>整理授权的过程见下图所示：</p><p><img src="/adanpro/adanblog/./../pic/wps84.jpg" alt="img"> </p><h3 id="2-2-4-工作原理"><a href="#2-2-4-工作原理" class="headerlink" title="2.2.4 工作原理"></a><strong>2.2.4 工作原理</strong></h3><p>通过测试认证和授权两个功能，我们了解了Spring Security的基本使用方法，下边了解它的工作流程。</p><p>Spring Security所解决的问题就是<strong>安全访问控制</strong>，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。根据前边知识的学习，可以通过Filter或AOP等技术来实现，Spring Security对Web资源的保护是靠Filter实现的，所以从这个Filter来入手，逐步深入Spring Security原理。</p><p>​    当初始化Spring Security时，会创建一个名为SpringSecurityFilterChain的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此类，下图是Spring Security过虑器链结构图：</p><p><img src="/adanpro/adanblog/./../pic/wps85.jpg" alt="img"> </p><p>FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的<strong>认证</strong>，也不直接处理用户的<strong>授权</strong>，而是把它们交给了认证管理器（AuthenticationManager）和决策管理器（AccessDecisionManager）进行处理。</p><p>spring Security功能的实现主要是由一系列过滤器链相互配合完成。</p><p><img src="/adanpro/adanblog/./../pic/wps86.jpg" alt="img"> </p><p>下面介绍过滤器链中主要的几个过滤器及其作用：</p><p><strong>SecurityContextPersistenceFilter</strong> 这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给 SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时清除 securityContextHolder 所持有的 SecurityContext；</p><p><strong>UsernamePasswordAuthenticationFilter</strong> 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；</p><p><strong>FilterSecurityInterceptor</strong> 是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问，前面已经详细介绍过了；</p><p><strong>ExceptionTranslationFilter</strong> 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。</p><p>Spring Security的执行流程如下：</p><p><img src="/adanpro/adanblog/./../pic/wps87.jpg" alt="img"> </p><ol><li>用户提交用户名、密码被SecurityFilterChain中的UsernamePasswordAuthenticationFilter过滤器获取到，封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。</li><li>然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证</li><li>认证成功后，AuthenticationManager身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）Authentication实例。</li><li>SecurityContextHolder安全上下文容器将第3步填充了信息的Authentication，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。</li><li>可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个List<AuthenticationProvider>列表，存放多种认证方式，最终实际的认证工作是由AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。</li></ol><h2 id="2-3-什么是OAuth2"><a href="#2-3-什么是OAuth2" class="headerlink" title="2.3 什么是OAuth2"></a><strong>2.3 什么是OAuth2</strong></h2><h3 id="2-3-1-OAuth2认证流程"><a href="#2-3-1-OAuth2认证流程" class="headerlink" title="2.3.1 OAuth2认证流程"></a><strong>2.3.1 OAuth2认证流程</strong></h3><p>在前边我们提到微信扫码认证，这是一种第三方认证的方式，这种认证方式是基于OAuth2协议实现，</p><p>OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。</p><p>​    Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。</p><p>参考：<a href="https://baike.baidu.com/item/oAuth/7153134?fr=aladdin">https://baike.baidu.com/item/oAuth/7153134?fr=aladdin</a></p><p>Oauth协议：<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p>下边分析一个Oauth2认证的例子，黑马程序员网站使用微信认证扫码登录的过程：</p><p><img src="/adanpro/adanblog/./../pic/wps88.jpg" alt="img"> </p><p>具体流程如下：</p><p>1、用户点击微信扫码</p><p>用户进入黑马程序的登录页面，点击微信的图标开打微信扫码界面。</p><p><img src="/adanpro/adanblog/./../pic/wps89.jpg" alt="img"> </p><p><img src="/adanpro/adanblog/./../pic/wps90.jpg" alt="img"> </p><p>微信扫码的目的是通过微信认证登录黑马程序员官网，黑马程序员网站需要从微信获取当前用户的身份信息才会让当前用户在黑马网站登录成功。</p><p>现在搞清楚几个概念：</p><p>资源：用户信息，在微信中存储。</p><p>资源拥有者：用户是用户信息资源的拥有者。</p><p>认证服务：微信负责认证当前用户的身份，负责为客户端颁发令牌。</p><p>客户端：客户端会携带令牌请求微信获取用户信息，黑马程序员网站即客户端，黑马网站需要在浏览器打开。</p><p>2、用户授权黑马网站访问用户信息</p><p>资源拥有者扫描二维码表示资源拥有者请求微信进行认证，微信认证通过向用户手机返回授权页面，如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps91.jpg" alt="img"> </p><p>询问用户是否授权黑马程序员访问自己在微信的用户信息，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码给黑马程序员的网站。</p><p>只有资源拥有者同意微信才允许黑马网站访问资源。</p><p>3、黑马程序员的网站获取到授权码</p><p>4、携带授权码请求微信认证服务器申请令牌</p><p>此交互过程用户看不到。</p><p>5、微信认证服务器向黑马程序员的网站响应令牌</p><p>此交互过程用户看不到。</p><p>6、黑马程序员网站请求微信资源服务器获取资源即用户信息。</p><p>黑马程序员网站携带令牌请求访问微信服务器获取用户的基本信息。</p><p>7、资源服务器返回受保护资源即用户信息</p><p>8、黑马网站接收到用户信息，此时用户在黑马网站登录成功。</p><p>理解了微信扫码登录黑马网站的流程，接下来认识Oauth2.0的认证流程，如下：</p><p>引自Oauth2.0协议rfc6749 <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p><img src="/adanpro/adanblog/./../pic/wps92.jpg" alt="img"> </p><p>Oauth2包括以下角色：</p><p>1、客户端</p><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：手机客户端、浏览器等。</p><p>上边示例中黑马网站即为客户端，它需要通过浏览器打开。</p><p>2、资源拥有者</p><p>通常为用户，也可以是应用程序，即该资源的拥有者。</p><p>A表示 客户端请求资源拥有者授权。</p><p>B表示 资源拥有者授权客户端即黑马网站访问自己的用户信息。</p><p>3、授权服务器（也称认证服务器）</p><p>认证服务器对资源拥有者进行认证，还会对客户端进行认证并颁发令牌。</p><p>C 客户端即黑马网站携带授权码请求认证。</p><p>D认证通过颁发令牌。</p><p>4、资源服务器</p><p>存储资源的服务器。</p><p>E表示客户端即黑马网站携带令牌请求资源服务器获取资源。</p><p>F表示资源服务器校验令牌通过后提供受保护资源。</p><h3 id="2-3-2-OAuth2在本项目的应用"><a href="#2-3-2-OAuth2在本项目的应用" class="headerlink" title="2.3.2 OAuth2在本项目的应用"></a><strong>2.3.2 OAuth2在本项目的应用</strong></h3><p>Oauth2是一个标准的开放的授权协议，应用程序可以根据自己的要求去使用Oauth2，本项目使用Oauth2实现如下目标：</p><p>1、学成在线访问第三方系统的资源。</p><p>本项目要接入微信扫码登录所以本项目要使用OAuth2协议访问微信中的用户信息。</p><p>2、外部系统访问学成在线的资源  。</p><p>同样当第三方系统想要访问学成在线网站的资源也可以基于OAuth2协议。</p><p>3、学成在线前端（客户端） 访问学成在线微服务的资源。</p><p>本项目是前后端分离架构，前端访问微服务资源也可以基于OAuth2协议进行认证。</p><h3 id="2-3-3-OAuth2的授权模式"><a href="#2-3-3-OAuth2的授权模式" class="headerlink" title="2.3.3 OAuth2的授权模式"></a><strong>2.3.3 OAuth2的授权模式</strong></h3><p>Spring Security支持OAuth2认证，OAuth2提供授权码模式、密码模式、简化模式、客户端模式等四种授权模式，前边举的微信扫码登录的例子就是基于授权码模式，这四种模式中授权码模式和密码模式应用较多，本节使用Spring Security演示授权码模式、密码模式，其余两种请自行查阅相关资料。</p><h4 id="2-3-3-1-授权码模式"><a href="#2-3-3-1-授权码模式" class="headerlink" title="2.3.3.1 授权码模式"></a><strong>2.3.3.1 授权码模式</strong></h4><p>OAuth2的几个授权模式是根据不同的应用场景以不同的方式去获取令牌，最终目的是要获取认证服务颁发的令牌，最终通过令牌去获取资源。</p><p>授权码模式简单理解是使用授权码去获取令牌，要想获取令牌先要获取授权码，授权码的获取需要资源拥有者亲自授权同意才可以获取。</p><p>下图是授权码模式的交互图：</p><p><img src="/adanpro/adanblog/./../pic/wps93.jpg" alt="img"> </p><p>还以黑马网站微信扫码登录为例进行说明：</p><p>1、用户打开浏览器。</p><p>2、通过浏览器访问客户端即黑马网站。</p><p>3、用户通过浏览器向认证服务请求授权，请求授权时会携带客户端的URL，此URL为下发授权码的重定向地址。</p><p>4、认证服务向资源拥有者返回授权页面。</p><p>5、资源拥有者亲自授权同意。</p><p>6、通过浏览器向认证服务发送授权同意。</p><p>7、认证服务向客户端地址重定向并携带授权码。</p><p>8、客户端即黑马网站收到授权码。</p><p>9、客户端携带授权码向认证服务申请令牌。</p><p>10、认证服务向客户端颁发令牌。</p><h4 id="2-3-3-2授权码模式测试"><a href="#2-3-3-2授权码模式测试" class="headerlink" title="2.3.3.2授权码模式测试"></a><strong>2.3.3.2授权码模式测试</strong></h4><p>要想测试授权模式首先要配置授权服务器即上图中的认证服务器，需要配置授权服务及令牌策略。</p><p>1、从课程资料中拷贝 AuthorizationServer.java、TokenConfig.java到认证服务的config包下。</p><p>说明“：AuthorizationServer用 @EnableAuthorizationServer 注解标识并继承AuthorizationServerConfigurerAdapter来配置OAuth2.0 授权服务器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line">*/</span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>AuthorizationServerConfigurerAdapter要求配置以下几个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationServerConfigurer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthorizationServerConfigurerAdapter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）ClientDetailsServiceConfigurer</strong>：用来配置客户端详情服务（ClientDetailsService），</p><p>随便一个客户端都可以随便接入到它的认证服务吗？答案是否定的，服务提供商会给批准接入的客户端一个身份，用于接入时的凭据，有客户端标识和客户端秘钥，在这里配置批准接入的客户端的详细信息。</p><p><strong>2）AuthorizationServerEndpointsConfigurer</strong>：用来配置令牌（token）的访问端点和令牌服务(token services)。</p><p><strong>3）AuthorizationServerSecurityConfigurer</strong>：用来配置令牌端点的安全约束.</p><p>2、TokenConfig为令牌策略配置类</p><p>暂时先使用InMemoryTokenStore在内存存储令牌，令牌的有效期等信息配置如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//令牌管理服务</span></span><br><span class="line"><span class="meta">@Bean(name=&quot;authorizationServerTokenServicesCustom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenService</span><span class="params">()</span> &#123;</span><br><span class="line">    DefaultTokenServices service=<span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">    service.setSupportRefreshToken(<span class="literal">true</span>);<span class="comment">//支持刷新令牌</span></span><br><span class="line">    service.setTokenStore(tokenStore);<span class="comment">//令牌存储策略</span></span><br><span class="line">    service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">    service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、配置认证管理bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>重启认证服务</p><p>1、get请求获取授权码</p><p>地址: <a href="http://localhost:63070/auth/oauth/authorize?client_id=XcWebApp&response_type=code&scope=all&redirect_uri=http://www.51xuecheng.cn">http://localhost:63070/auth/oauth/authorize?client_id=XcWebApp&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.51xuecheng.cn</a></p><p>参数列表如下：</p><p>• client_id：客户端准入标识。</p><p>• response_type：授权码模式固定为code。</p><p>• scope：客户端权限。</p><p>• redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码）。</p><p>输入账号zhangsan、密码123登录成功，输入&#x2F;oauth&#x2F;authorize?client_id&#x3D;XcWebApp&amp;response_type&#x3D;code&amp;scope&#x3D;all&amp;redirect_uri&#x3D;<a href="http://www.51xuecheng.cn/">http://www.51xuecheng.cn</a></p><p>显示授权页面</p><p><img src="/adanpro/adanblog/./../pic/wps94.jpg" alt="img"> </p><p>授权“XcWebApp”访问自己的受保护资源?</p><p>选择同意。</p><p>2、请求成功，重定向至<a href="http://www.51xuecheng.cn/?code=%E6%8E%88%E6%9D%83%E7%A0%81%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9Ahttp://www.51xuecheng.cn/?code=Wqjb5H">http://www.51xuecheng.cn/?code=授权码，比如：http://www.51xuecheng.cn/?code=Wqjb5H</a></p><p>3、使用httpclient工具post申请令牌</p><p>&#x2F;oauth&#x2F;token?client_id&#x3D;XcWebApp&amp;client_secret&#x3D;XcWebApp&amp;grant_type&#x3D;authorization_code&amp;code&#x3D;授权码&amp;redirect_uri&#x3D;<a href="http://www.51xuecheng.cn/">http://www.51xuecheng.cn/</a></p><p>参数列表如下</p><p>• client_id：客户端准入标识。</p><p>• client_secret：客户端秘钥。</p><p>• grant_type：授权类型，填写authorization_code，表示授权码模式</p><p>• code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。</p><p>• redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</p><p>httpclient脚本如下：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 授权码模式</span><br><span class="line">### 第一步申请授权码(浏览器请求)/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.51xuecheng.cn</span><br><span class="line">### 第二步申请令牌</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=authorization_code&amp;code=CTvCrB&amp;redirect_uri=http://www.51xuecheng.cn</span><br></pre></td></tr></table></figure><p>申请令牌成功如下所示：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;368b1ee7-a9ee-4e9a-aae6-0fcab243aad2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3d56e139-0ee6-4ace-8cbe-1311dfaa991f&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7199</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>1、access_token，访问令牌，用于访问资源使用。</p><p>2、token_type，bearer是在RFC6750中定义的一种token类型，在携带令牌访问资源时需要在head中加入bearer 空格 令牌内容</p><p>3、refresh_token，当令牌快过期时使用刷新令牌可以再次生成令牌。</p><p>4、expires_in：过期时间（秒）</p><p>5、scope，令牌的权限范围，服务端可以根据令牌的权限范围去对令牌授权。</p><h4 id="2-3-3-3-密码模式"><a href="#2-3-3-3-密码模式" class="headerlink" title="2.3.3.3 密码模式"></a><strong>2.3.3.3 密码模式</strong></h4><p>密码模式相对授权码模式简单，授权码模式需要借助浏览器供用户亲自授权，密码模式不用借助浏览器，如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps95.jpg" alt="img"> </p><p>1、资源拥有者提供账号和密码</p><p>2、客户端向认证服务申请令牌，请求中携带账号和密码</p><p>3、认证服务校验账号和密码正确颁发令牌。</p><p>开始测试：</p><p>1、POST请求获取令牌</p><p>&#x2F;oauth&#x2F;token?client_id&#x3D;XcWebApp&amp;client_secret&#x3D;XcWebApp&amp;grant_type&#x3D;password&amp;username&#x3D;shangsan&amp;password&#x3D;123</p><p>参数列表如下：</p><p>• client_id：客户端准入标识。</p><p>• client_secret：客户端秘钥。</p><p>• grant_type：授权类型，填写password表示密码模式</p><p>• username：资源拥有者用户名。</p><p>• password：资源拥有者密码。</p><p>2、授权服务器将令牌（access_token）发送给client</p><p><strong>使用httpclient进行测试</strong></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 密码模式</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=zhangsan&amp;password=123</span><br></pre></td></tr></table></figure><p>返回示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;368b1ee7-a9ee-4e9a-aae6-0fcab243aad2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3d56e139-0ee6-4ace-8cbe-1311dfaa991f&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">6806</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下。</p><h4 id="2-3-3-4-本项目的应用方式"><a href="#2-3-3-4-本项目的应用方式" class="headerlink" title="2.3.3.4 本项目的应用方式"></a><strong>2.3.3.4 本项目的应用方式</strong></h4><p>通过演示授权码模式和密码模式，授权码模式适合客户端和认证服务非同一个系统的情况，所以本项目使用授权码模式完成微信扫码认证。本项目采用密码模式作为前端请求微服务的认证方式。</p><h2 id="2-4-JWT"><a href="#2-4-JWT" class="headerlink" title="2.4 JWT"></a><strong>2.4 JWT</strong></h2><h3 id="2-4-1-普通令牌的问题"><a href="#2-4-1-普通令牌的问题" class="headerlink" title="2.4.1 普通令牌的问题"></a><strong>2.4.1 普通令牌的问题</strong></h3><p>客户端申请到令牌，接下来客户端携带令牌去访问资源，到资源服务器将会校验令牌的合法性。</p><p>资源服务器如何校验令牌的合法性？</p><p>我们以OAuth2的密码模式为例进行说明：</p><p><img src="/adanpro/adanblog/./../pic/wps96.jpg" alt="img"> </p><p>从第4步开始说明：</p><p>1、客户端携带令牌访问资源服务获取资源。</p><p>2、资源服务远程请求认证服务校验令牌的合法性</p><p>3、如果令牌合法资源服务向客户端返回资源。</p><p>这里存在一个问题：</p><p>就是校验令牌需要远程请求认证服务，客户端的每次访问都会远程校验，执行性能低。</p><p>如果能够让资源服务自己校验令牌的合法性将省去远程请求认证服务的成本，提高了性能。如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps97.jpg" alt="img"> </p><p>如何解决上边的问题，实现资源服务自行校验令牌。</p><p>令牌采用JWT格式即可解决上边的问题，用户认证通过后会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。</p><h3 id="2-4-2-什么是JWT"><a href="#2-4-2-什么是JWT" class="headerlink" title="2.4.2 什么是JWT"></a><strong>2.4.2 什么是JWT</strong></h3><p>什么是JWT？</p><p>JSON Web Token（JWT）是一种使用JSON格式传递数据的网络令牌技术，它是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任，它可以使用HMAC算法或使用RSA的公钥&#x2F;私钥对来签名，防止内容篡改。官网：<a href="https://jwt.io/">https://jwt.io/</a></p><p>使用JWT可以实现无状态认证，什么是无状态认证？</p><p>传统的基于session的方式是有状态认证，用户登录成功将用户的身份信息存储在服务端，这样加大了服务端的存储压力，并且这种方式不适合在分布式系统中应用。</p><p>如下图，当用户访问应用服务，每个应用服务都会去服务器查看session信息，如果session中没有该用户则说明用户没有登录，此时就会重新认证，而解决这个问题的方法是Session复制、Session黏贴。</p><p><img src="/adanpro/adanblog/./../pic/wps98.jpg" alt="img"> </p><p>如果是基于令牌技术在分布式系统中实现认证则服务端不用存储session，可以将用户身份信息存储在令牌中，用户认证通过后认证服务颁发令牌给用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从jwt解析出用户信息。这个过程就是无状态认证。</p><p><img src="/adanpro/adanblog/./../pic/wps99.jpg" alt="img"> </p><p>JWT令牌的优点：</p><p>1、jwt基于json，非常方便解析。</p><p>2、可以在令牌中自定义丰富的内容，易扩展。</p><p>3、通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</p><p>4、资源服务使用JWT可不依赖认证服务即可完成授权。</p><p>缺点：</p><p>１、JWT令牌较长，占存储空间比较大。</p><p>下边是一个JWT令牌的示例：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQyNTQ2NzIsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6Ijg4OTEyYjJkLTVkMDUtNGMxNC1iYmMzLWZkZTk5NzdmZWJjNiIsImNsaWVudF9pZCI6ImMxIn0.wkDBL7roLrvdBG2oGnXeoXq-zZRgE9IVV2nxd-ez_oA</span></span><br></pre></td></tr></table></figure><p>JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz</p><ol><li><strong>Header</strong></li></ol><p> <strong>头部</strong>包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）</p><p> 一个例子如下：</p><p> 下边是Header部分的内容</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。</p><ol start="2"><li><strong>Payload</strong></li></ol><p> <strong>第二部分是负载</strong>，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的信息字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。</p><p> 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。</p><p> 最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。</p><p> 一个例子：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;456&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>Signature</strong></li></ol><p> <strong>第三部分是签名</strong>，此部分用于防止jwt内容被篡改。</p><p> 这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明的签名算法进行签名。</p><p> 一个例子：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">    base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">    base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">    secret)</span><br></pre></td></tr></table></figure><p>base64UrlEncode(header)：jwt令牌的第一部分。</p><p>base64UrlEncode(payload)：jwt令牌的第二部分。</p><p>secret：签名所使用的密钥。</p><p><strong>为什么JWT可以防止篡改？</strong></p><p>第三部分使用签名算法对第一部分和第二部分的内容进行签名，常用的签名算法是 HS256，常见的还有md5,sha 等，签名算法需要使用密钥进行签名，密钥不对外公开，并且签名是不可逆的，如果第三方更改了内容那么服务器验证签名就会失败，要想保证验证签名正确必须保证内容、密钥与签名前一致。</p><p><img src="/adanpro/adanblog/./../pic/wps100.jpg" alt="img"> </p><p>从上图可以看出认证服务和资源服务使用相同的密钥，这叫对称加密，对称加密效率高，如果一旦密钥泄露可以伪造jwt令牌。</p><p>JWT还可以使用非对称加密，认证服务自己保留私钥，将公钥下发给受信任的客户端、资源服务，公钥和私钥是配对的，成对的公钥和私钥才可以正常加密和解密，非对称加密效率低但相比对称加密非对称加密更安全一些。</p><h3 id="2-4-3-测试生成JWT令牌"><a href="#2-4-3-测试生成JWT令牌" class="headerlink" title="2.4.3 测试生成JWT令牌"></a><strong>2.4.3 测试生成JWT令牌</strong></h3><p>在认证服务中配置jwt令牌服务，即可实现生成jwt格式的令牌,  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.DefaultTokenServices;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenEnhancerChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">SIGNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;mq123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">//        //使用内存存储令牌（普通令牌）</span></span><br><span class="line"><span class="comment">//        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">accessTokenConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//令牌管理服务</span></span><br><span class="line">    <span class="meta">@Bean(name=&quot;authorizationServerTokenServicesCustom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenService</span><span class="params">()</span> &#123;</span><br><span class="line">        DefaultTokenServices service=<span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">        service.setSupportRefreshToken(<span class="literal">true</span>);<span class="comment">//支持刷新令牌</span></span><br><span class="line">        service.setTokenStore(tokenStore);<span class="comment">//令牌存储策略</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TokenEnhancerChain</span> <span class="variable">tokenEnhancerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenEnhancerChain</span>();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        service.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line"></span><br><span class="line">        service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">        service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启认证服务。</p><p>使用httpclient通过密码模式申请令牌</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 密码模式</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=zhangsan&amp;password=123</span><br></pre></td></tr></table></figure><p>生成jwt的示例如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzMzE2OTUsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6ImU5ZDNkMGZkLTI0Y2ItNDRjOC04YzEwLTI1NmIzNGY4ZGZjYyIsImNsaWVudF9pZCI6ImMxIn0.-9SKI-qUqKhKcs8Gb80Rascx-JxqsNZxxXoPo82d8SM&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiJlOWQzZDBmZC0yNGNiLTQ0YzgtOGMxMC0yNTZiMzRmOGRmY2MiLCJleHAiOjE2NjQ1ODM2OTUsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6ImRjNTRjNTRkLTA0YTMtNDIzNS04MmY3LTFkOWZkMmFjM2VmNSIsImNsaWVudF9pZCI6ImMxIn0.Wsw1Jc-Kd_GFqEugzdfoSsMY6inC8OQsraA21WjWtT8&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7199</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e9d3d0fd-24cb-44c8-8c10-256b34f8dfcc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>1、access_token，生成的jwt令牌，用于访问资源使用。</p><p>2、token_type，bearer是在RFC6750中定义的一种token类型，在携带jwt访问资源时需要在head中加入bearer jwt令牌内容</p><p>3、refresh_token，当jwt令牌快过期时使用刷新令牌可以再次生成jwt令牌。</p><p>4、expires_in：过期时间（秒）</p><p>5、scope，令牌的权限范围，服务端可以根据令牌的权限范围去对令牌授权。</p><p>6、jti：令牌的唯一标识。</p><p>我们可以通过check_token接口校验jwt令牌</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">###校验jwt令牌</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/oauth/check_token?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJzdHUxIiwic2NvcGUiOlsiYWxsIl0sImV4cCI6MTY2NDM3MTc4MCwiYXV0aG9yaXRpZXMiOlsicDEiXSwianRpIjoiZjBhM2NkZWItMzk5ZC00OGYwLTg4MDQtZWNhNjM4YWQ4ODU3IiwiY2xpZW50X2lkIjoiYzEifQ.qy46CSCJsH3eXWTHgdcntZhzcSzfRQlBU0dxAjZcsUw</span><br></pre></td></tr></table></figure><p>响应示例如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;res1&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;user_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;all&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1664371780</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;p1&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f0a3cdeb-399d-48f0-8804-eca638ad8857&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;client_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-4-携带令牌访问资源服务"><a href="#2-4-4-携带令牌访问资源服务" class="headerlink" title="2.4.4 携带令牌访问资源服务"></a><strong>2.4.4 携带令牌访问资源服务</strong></h3><p>拿到了jwt令牌下一步就要携带令牌去访问资源服务中的资源，本项目各个微服务就是资源服务，比如：内容管理服务，客户端申请到jwt令牌，携带jwt去内容管理服务查询课程信息，此时内容管理服务要对jwt进行校验，只有jwt合法才可以继续访问。如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps101.jpg" alt="img"> </p><p>1、在内容管理服务的content-api工程中添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--认证相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、从资料中拷贝 资源服务配置类 中的 TokenConfig和ResouceServerConfig 到内容管理的api工程的config包下。</p><p>可以在ResouceServerConfig类中配置需要认证的url。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> http.csrf().disable()</span><br><span class="line">         .authorizeRequests()</span><br><span class="line">               .antMatchers(<span class="string">&quot;/r/**&quot;</span>,<span class="string">&quot;/course/**&quot;</span>).authenticated()<span class="comment">//所有/r/**的请求必须认证通过</span></span><br><span class="line">         .anyRequest().permitAll()</span><br><span class="line"> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启内容管理服务</p><p>使用httpclient测试：</p><p>1、访问根据课程id查询课程接口</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 查询课程信息</span><br><span class="line">GET http://localhost:63040/content/course/2</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unauthorized&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error_description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Full authentication is required to access this resource&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>从返回信息可知当前没有认证。</p><p>下边携带JWT令牌访问接口：</p><p>1、申请jwt令牌</p><p>采用密码模式申请令牌。</p><p>2、携带jwt令牌访问资源服务地址</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 携带token访问资源服务</span><br><span class="line">GET http://localhost:63040/content/course/2</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzMzM0OTgsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6IjhhM2M2OTk1LWU1ZGEtNDQ1Yy05ZDAyLTEwNDFlYzk3NTkwOSIsImNsaWVudF9pZCI6ImMxIn0.73eNDxTX5ifttGCjwc7xrd-Sbp_mCfcIerI3lGetZto</span><br></pre></td></tr></table></figure><p>在请求头中添加Authorization，内容为Bearer 令牌，Bearer用于通过oauth2.0协议访问资源。</p><p>如果携带jwt令牌且jwt正确则正常访问资源服务的内容。</p><p>如果不正确则报令牌无效的错误：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;invalid_token&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error_description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Cannot convert access token to JSON&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-5-测试获取用户身份"><a href="#2-4-5-测试获取用户身份" class="headerlink" title="2.4.5 测试获取用户身份"></a><strong>2.4.5 测试获取用户身份</strong></h3><p>jwt令牌中记录了用户身份信息，当客户端携带jwt访问资源服务，资源服务验签通过后将前两部分的内容还原即可取出用户的身份信息，并将用户身份信息放在了SecurityContextHolder上下文，SecurityContext与当前线程进行绑定，方便获取用户身份。</p><p>还以查询课程接口为例，进入查询课程接口的代码中，添加获取用户身份的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据课程id查询课程基础信息&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/course/&#123;courseId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">getCourseBaseById</span><span class="params">(<span class="meta">@PathVariable(&quot;courseId&quot;)</span> Long courseId)</span>&#123;</span><br><span class="line">    <span class="comment">//取出当前用户身份</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">    System.out.println(principal);</span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.getCourseBaseInfo(courseId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试时需要注意：</p><p>1、首先在资源服务配置中指定安全拦截机制 &#x2F;course&#x2F;开头的请求需要认证，即请求&#x2F;course&#x2F;{courseId}接口需要携带jwt令牌且签证通过。</p><p>2、认证服务生成jwt令牌将用户身份信息写入令牌，目前还是将用户信息硬编码并暂放在内存中。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;456&quot;</span>).authorities(<span class="string">&quot;p2&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、我们在使用密码模式生成jwt令牌时用的是zhangsan的信息，所以jwt令牌中存储了zhangsan的信息，那么在资源服务中应该取出zhangsan的信息才对。</p><p>清楚了以上内容，下边重启内容管理服务，跟踪取到的用户身份是否正确。</p><h2 id="2-5-网关认证"><a href="#2-5-网关认证" class="headerlink" title="2.5 网关认证"></a><strong>2.5 网关认证</strong></h2><h3 id="2-5-1-技术方案"><a href="#2-5-1-技术方案" class="headerlink" title="2.5.1 技术方案"></a><strong>2.5.1 技术方案</strong></h3><p>到目前为止，测试通过了认证服务颁发jwt令牌，客户端携带jwt访问资源服务，资源服务对jwt的合法性进行验证。如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps102.jpg" alt="img"> </p><p>仔细观察此图，遗漏了本项目架构中非常重要的组件：网关，加上网关并完善后如下图所示：</p><p><img src="/adanpro/adanblog/./../pic/wps103.jpg" alt="img"> </p><p>所有访问微服务的请求都要经过网关，在网关进行用户身份的认证可以将很多非法的请求拦截到微服务以外，这叫做网关认证。</p><p>下边需要明确网关的职责：</p><p>1、网站白名单维护</p><p>针对不用认证的URL全部放行。</p><p>2、校验jwt的合法性。</p><p>除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。</p><p>网关负责授权吗？</p><p>网关不负责授权，对请求的授权操作在各个微服务进行，因为微服务最清楚用户有哪些权限访问哪些接口。</p><h3 id="2-5-2-实现网关认证"><a href="#2-5-2-实现网关认证" class="headerlink" title="2.5.2 实现网关认证"></a><strong>2.5.2 实现网关认证</strong></h3><p>下边实现网关认证，实现以下职责：</p><p>1、网站白名单维护</p><p>针对不用认证的URL全部放行。</p><p>2、校验jwt的合法性。</p><p>除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。</p><p>1、在网关工程添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、拷贝课程资料下网关认证配置类到网关工程的config包下。</p><p>3、配置白名单文件security-whitelist.properties</p><p>内容如下（持续补充）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">/auth/**</span>=<span class="string">认证地址</span></span><br><span class="line"><span class="attr">/content/open/**</span>=<span class="string">内容管理公开访问接口</span></span><br><span class="line"><span class="attr">/media/open/**</span>=<span class="string">媒资管理公开访问接口</span></span><br></pre></td></tr></table></figure><p>重启网关工程，进行测试</p><p>1、申请令牌</p><p>2、通过网关访问资源服务</p><p>这里访问内容管理服务</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 通过网关访问资源服务</span><br><span class="line">GET http://localhost:63010/content/course/2</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzNjIzMTAsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6Ijc2OTkwMGNiLWM1ZjItNGRiNC1hZWJmLWY1MzgxZDQxZWMyZCIsImNsaWVudF9pZCI6ImMxIn0.lOITjUgYg2HCh5mDPK9EvJJqz-tIupKVfmP8yWJQIKs</span><br></pre></td></tr></table></figure><p>当token正确时可以正常访问资源服务，token验证失败返回token无效：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;errMessage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;认证令牌无效&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注意：网关鉴权功能调试通过后，由于目前还没有开发认证功能，前端请求网关的URL不在白名单中间时会“没有认证”的错误，暂时在白名单中添加 全部放行配置，待认证功能开发完成再屏蔽全部放行配置，</p><p><img src="/adanpro/adanblog/./../pic/wps104.jpg" alt="img"> </p><p>由于是在网关处进行令牌校验，所以在微服务处不再校验令牌的合法性，修改内容管理服务的ResouceServerConfig类，屏蔽authenticated()。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  http.csrf().disable()</span><br><span class="line">          .authorizeRequests()</span><br><span class="line"><span class="comment">//          .antMatchers(&quot;/r/**&quot;,&quot;/course/**&quot;).authenticated()//所有/r/**的请求必须认证通过</span></span><br><span class="line">          .anyRequest().permitAll()</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="3-用户认证"><a href="#3-用户认证" class="headerlink" title="3 用户认证"></a><strong>3 用户认证</strong></h1><h2 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a><strong>3.1 需求分析</strong></h2><p>至此我们了解了使用Spring Security进行认证授权的过程，本节实现用户认证功能。</p><p>目前各大网站的认证方式非常丰富：账号密码认证、手机验证码认证、扫码登录等。</p><p>本项目也要支持多种认证试。</p><h2 id="3-2-连接用户中心数据库"><a href="#3-2-连接用户中心数据库" class="headerlink" title="3.2 连接用户中心数据库"></a><strong>3.2 连接用户中心数据库</strong></h2><h3 id="3-2-1-连接数据库认证"><a href="#3-2-1-连接数据库认证" class="headerlink" title="3.2.1 连接数据库认证"></a><strong>3.2.1 连接数据库认证</strong></h3><p>基于的认证流程在研究Spring Security过程中已经测试通过，到目前为止用户认证流程如下：</p><p><img src="/adanpro/adanblog/./../pic/wps105.jpg" alt="img"> </p><p>认证所需要的用户信息存储在用户中心数据库，现在需要将认证服务连接数据库查询用户信息。</p><p>在研究Spring Security的过程中是将用户信息硬编码，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;456&quot;</span>).authorities(<span class="string">&quot;p2&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要认证服务中连接用户中心数据库查询用户信息。</p><p>如何使用Spring Security连接数据库认证吗？</p><p>前边学习Spring Security工作原理时有一张执行流程图，如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps106.jpg" alt="img"> </p><p>用户提交账号和密码由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息。</p><p>查询DaoAuthenticationProvider的源代码如下：</p><p><img src="/adanpro/adanblog/./../pic/wps107.jpg" alt="img"> </p><p>UserDetailsService是一个接口，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.security.core.userdetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String var1)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDetails是用户信息接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只要实现UserDetailsService 接口查询数据库得到用户信息返回UserDetails 类型的用户信息即可,框架调用loadUserByUsername()方法拿到用户信息之后是如何执行的，见下图：</p><p><img src="/adanpro/adanblog/./../pic/wps108.jpg" alt="img"> </p><p>首先屏蔽原来定义的UserDetailsService。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//配置用户信息服务</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public UserDetailsService userDetailsService() &#123;</span></span><br><span class="line"><span class="comment">//        //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line"><span class="comment">//        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();</span></span><br><span class="line"><span class="comment">//        manager.createUser(User.withUsername(&quot;zhangsan&quot;).password(&quot;123&quot;).authorities(&quot;p1&quot;).build());</span></span><br><span class="line"><span class="comment">//        manager.createUser(User.withUsername(&quot;lisi&quot;).password(&quot;456&quot;).authorities(&quot;p2&quot;).build());</span></span><br><span class="line"><span class="comment">//        return manager;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure><p>下边自定义UserDetailsService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 根据账号查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  账号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, s));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities= &#123;<span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建UserDetails对象,权限信息待实现授权功能时再向UserDetail中加入</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(user.getUsername()).password(password).authorities(authorities).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库中的密码加过密的，用户输入的密码是明文，我们需要修改密码格式器PasswordEncoder，原来使用的是NoOpPasswordEncoder，它是通过明文方式比较密码，现在我们修改为BCryptPasswordEncoder，它是将用户输入的密码编码为BCrypt格式与数据库中的密码进行比对。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        //密码为明文方式</span></span><br><span class="line"><span class="comment">//        return NoOpPasswordEncoder.getInstance();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们通过测试代码测试BCryptPasswordEncoder，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;111111&quot;</span>;</span><br><span class="line">    <span class="type">PasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        <span class="comment">//每个计算出的Hash值都不一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hashPass</span> <span class="operator">=</span> passwordEncoder.encode(password);</span><br><span class="line">        System.out.println(hashPass);</span><br><span class="line">        <span class="comment">//虽然每次计算的密码Hash值不一样但是校验是通过的</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">f</span> <span class="operator">=</span> passwordEncoder.matches(password, hashPass);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改数据库中的密码为Bcrypt格式，并且记录明文密码，稍后申请令牌时需要。</p><p>由于修改密码编码方式还需要将客户端的密钥更改为Bcrypt格式.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span></span><br><span class="line">          <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients.inMemory()<span class="comment">// 使用in-memory存储</span></span><br><span class="line">                .withClient(<span class="string">&quot;XcWebApp&quot;</span>)<span class="comment">// client_id</span></span><br><span class="line"><span class="comment">//                .secret(&quot;secret&quot;)//客户端密钥</span></span><br><span class="line">                .secret(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;XcWebApp&quot;</span>))<span class="comment">//客户端密钥</span></span><br><span class="line">                .resourceIds(<span class="string">&quot;xuecheng-plus&quot;</span>)<span class="comment">//资源列表</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>, <span class="string">&quot;password&quot;</span>,<span class="string">&quot;client_credentials&quot;</span>,<span class="string">&quot;implicit&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>)<span class="comment">// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)<span class="comment">// 允许的授权范围</span></span><br><span class="line">                .autoApprove(<span class="literal">false</span>)<span class="comment">//false跳转到授权页面</span></span><br><span class="line">                <span class="comment">//客户端接收授权码的重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.51xuecheng.cn&quot;</span>)</span><br><span class="line">   ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>现在重启认证服务。</p><p>下边使用httpclient进行测试：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 密码模式</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=stu1&amp;password=111111</span><br></pre></td></tr></table></figure><p>输入正确的账号和密码，申请令牌成功。</p><p>输入错误的密码，报错：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;invalid_grant&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error_description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;用户名或密码错误&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>输入错误的账号，报错：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unauthorized&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error_description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UserDetailsService returned null, which is an interface contract violation&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-2-扩展用户身份信息"><a href="#3-2-2-扩展用户身份信息" class="headerlink" title="3.2.2 扩展用户身份信息"></a><strong>3.2.2 扩展用户身份信息</strong></h3><p>用户表中存储了用户的账号、手机号、email，昵称、qq等信息，UserDetails接口只返回了username、密码等信息，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要扩展用户身份的信息，在jwt令牌中存储用户的昵称、头像、qq等信息。</p><p><strong>如何扩展Spring Security的用户身份信息呢？</strong></p><p>在认证阶段DaoAuthenticationProvider会调用UserDetailService查询用户的信息，这里是可以获取到齐全的用户信息的。由于JWT令牌中用户身份信息来源于UserDetails，UserDetails中仅定义了username为用户的身份信息，这里有两个思路：第一是可以扩展UserDetails，使之包括更多的自定义属性，第二也可以扩展username的内容 ，比如存入json数据内容作为username的内容。相比较而言，方案二比较简单还不用破坏UserDetails的结构，我们采用方案二。</p><p>修改UserServiceImpl如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 根据账号查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  账号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, s));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities = &#123;<span class="string">&quot;p1&quot;</span>&#125;;</span><br><span class="line">       <span class="comment">//为了安全在令牌中不放密码</span></span><br><span class="line">        user.setPassword(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//将user对象转json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        <span class="comment">//创建UserDetails对象</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password).authorities(authorities).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启认证服务，重新生成令牌，生成成功。</p><p>我们可以使用check_token查询jwt的内容</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">###校验jwt令牌</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/oauth/check_token?token=</span><br></pre></td></tr></table></figure><p>响应示例如下:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;res1&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;user_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\&quot;birthday\&quot;:\&quot;2022-09-28T19:28:46\&quot;,\&quot;createTime\&quot;:\&quot;2022-09-28T08:32:03\&quot;,\&quot;id\&quot;:\&quot;50\&quot;,\&quot;name\&quot;:\&quot;学生1\&quot;,\&quot;nickname\&quot;:\&quot;大水牛\&quot;,\&quot;password\&quot;:\&quot;$2a$10$0pt7WlfTbnPDTcWtp/.2Mu5CTXvohnNQhR628qq4RoKSc0dGAdEgm\&quot;,\&quot;sex\&quot;:\&quot;1\&quot;,\&quot;status\&quot;:\&quot;1\&quot;,\&quot;username\&quot;:\&quot;stu1\&quot;,\&quot;userpic\&quot;:\&quot;http://file.51xuecheng.cn/dddf\&quot;,\&quot;utype\&quot;:\&quot;101001\&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;all&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1664372184</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;p1&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;73da9f7b-bd8c-45ac-9add-46b711d11fb8&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;client_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>user_name存储了用户信息的json格式，在资源服务中就可以取出该json格式的内容转为用户对象去使用。</p><h3 id="3-2-3-资源服务获取用户身份"><a href="#3-2-3-资源服务获取用户身份" class="headerlink" title="3.2.3 资源服务获取用户身份"></a><strong>3.2.3 资源服务获取用户身份</strong></h3><p>下边编写一个工具类在各个微服务中去使用，获取当前登录用户的对象。</p><p>在content-api中定义此类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取当前用户身份工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/18 18:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> XcUser <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">principalObj</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">            <span class="keyword">if</span> (principalObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="comment">//取出用户身份信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> principalObj.toString();</span><br><span class="line">                <span class="comment">//将json转成对象</span></span><br><span class="line">                <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(principal, XcUser.class);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取当前登录用户身份出错:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">XcUser</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String nickname;</span><br><span class="line">        <span class="keyword">private</span> String wxUnionid;</span><br><span class="line">        <span class="keyword">private</span> String companyId;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 头像</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String userpic;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String utype;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LocalDateTime birthday;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String cellphone;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String qq;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用户状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边在内容管理服务中测试此工具类，以查询课程信息接口为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据课程id查询课程基础信息&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/course/&#123;courseId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">getCourseBaseById</span><span class="params">(<span class="meta">@PathVariable(&quot;courseId&quot;)</span> Long courseId)</span>&#123;</span><br><span class="line">    <span class="comment">//取出当前用户身份</span></span><br><span class="line"><span class="comment">//    Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span></span><br><span class="line">   SecurityUtil.<span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> SecurityUtil.getUser();</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.getCourseBaseInfo(courseId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启内容管理服务：</p><p>1、启动认证服务、网关、内容管理服务</p><p>2、生成新的令牌</p><p>3、携带令牌访问内容管理服务的查询课程接口</p><p><img src="/adanpro/adanblog/./../pic/wps109.jpg" alt="img"> </p><h2 id="3-3-支持认证方式多样"><a href="#3-3-支持认证方式多样" class="headerlink" title="3.3 支持认证方式多样"></a><strong>3.3 支持认证方式多样</strong></h2><h3 id="3-3-1-统一认证入口"><a href="#3-3-1-统一认证入口" class="headerlink" title="3.3.1 统一认证入口"></a><strong>3.3.1 统一认证入口</strong></h3><p>目前各大网站的认证方式非常丰富：账号密码认证、手机验证码认证、扫码登录等。基于当前研究的Spring Security认证流程如何支持多样化的认证方式呢？</p><p>1、支持账号和密码认证</p><p>采用OAuth2协议的密码模式即可实现。</p><p>2、支持手机号加验证码认证</p><p>用户认证提交的是手机号和验证码，并不是账号和密码。</p><p>3、微信扫码认证</p><p>基于OAuth2协议与微信交互，学成在线网站向微信服务器申请到一个令牌，然后携带令牌去微信查询用户信息，查询成功则用户在学成在线项目认证通过。</p><p>目前我们测试通过OAuth2的密码模式，用户认证会提交账号和密码，由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息。</p><p>在前边我们自定义了UserDetailsService接口实现类，通过loadUserByUsername()方法根据账号查询用户信息。</p><p>而不同的认证方式提交的数据不一样，比如：手机加验证码方式会提交手机号和验证码，账号密码方式会提交账号、密码、验证码。</p><p>我们可以在loadUserByUsername()方法上作文章，将用户原来提交的账号数据改为提交json数据，json数据可以扩展不同认证方式所提交的各种参数。</p><p>首先创建一个DTO类表示认证的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.model.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 认证用户请求参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthParamsDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//域  用于扩展</span></span><br><span class="line">    <span class="keyword">private</span> String cellphone;<span class="comment">//手机号</span></span><br><span class="line">    <span class="keyword">private</span> String checkcode;<span class="comment">//验证码</span></span><br><span class="line">    <span class="keyword">private</span> String checkcodekey;<span class="comment">//验证码key</span></span><br><span class="line">    <span class="keyword">private</span> String authType; <span class="comment">// 认证的类型   password:用户名密码模式类型    sms:短信模式类型</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; payload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//附加数据，作为扩展，不同认证类型可拥有不同的附加数据。如认证类型为短信时包含smsKey : sms:3d21042d054548b08477142bbca95cfa; 所有情况下都包含clientId</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时loadUserByUsername()方法可以修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义UserDetailsService用来对接Spring Security</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息组成用户身份信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities = &#123;<span class="string">&quot;p1&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//将user对象转json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        <span class="comment">//创建UserDetails对象</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password).authorities(authorities).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来的DaoAuthenticationProvider 会进行密码校验，现在重新定义DaoAuthenticationProviderCustom类，重写类的additionalAuthenticationChecks方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.dao.DaoAuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义DaoAuthenticationProvider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProviderCustom</span> <span class="keyword">extends</span> <span class="title class_">DaoAuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.setUserDetailsService(userDetailsService);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//屏蔽密码对比</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改WebSecurityConfig类指定daoAuthenticationProviderCustom</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DaoAuthenticationProviderCustom daoAuthenticationProviderCustom;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    auth.authenticationProvider(daoAuthenticationProviderCustom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以重启认证服务，测试申请令牌接口，传入的账号信息改为json数据，如下：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">################扩展认证请求参数后######################</span><br><span class="line">###密码模式</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=&#123;&quot;username&quot;:&quot;stu1&quot;,&quot;authType&quot;:&quot;password&quot;,&quot;password&quot;:&quot;111111&quot;&#125;</span><br></pre></td></tr></table></figure><p>经过测试发现loadUserByUsername()方法可以正常接收到认证请求中的json数据。</p><p>有了这些认证参数我们可以定义一个认证Service接口去进行各种方式的认证。</p><p>定义用户信息，为了扩展性让它继承XcUser</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XcUserExt</span> <span class="keyword">extends</span> <span class="title class_">XcUser</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义认证Service 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 认证service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@description</span> 认证方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> authParamsDto 认证参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.xuecheng.ucenter.model.po.XcUser 用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2022/9/29 12:11</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadUserByUsername()修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息组成用户身份信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始认证</span></span><br><span class="line">        authService.execute(authParamsDto);</span><br><span class="line">        .....</span><br></pre></td></tr></table></figure><p>到此我们基于Spring Security认证流程修改为如下：</p><p><img src="/adanpro/adanblog/./../pic/wps110.jpg" alt="img"> </p><h3 id="3-3-2-实现账号密码认证"><a href="#3-3-2-实现账号密码认证" class="headerlink" title="3.3.2 实现账号密码认证"></a><strong>3.3.2 实现账号密码认证</strong></h3><p>上节定义了AuthService认证接口，下边实现该接口实现账号密码认证</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.service.AuthService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 账号密码认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Service(&quot;password_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//账号</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">  <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">  <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号不存在&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">XcUserExt</span> <span class="variable">xcUserExt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserExt</span>();</span><br><span class="line">  BeanUtils.copyProperties(user,xcUserExt);</span><br><span class="line">  <span class="comment">//校验密码</span></span><br><span class="line">  <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">passwordDb</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">  <span class="type">String</span> <span class="variable">passwordForm</span> <span class="operator">=</span> authParamsDto.getPassword();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> passwordEncoder.matches(passwordForm, passwordDb);</span><br><span class="line">  <span class="keyword">if</span>(!matches)&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号或密码错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xcUserExt;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserServiceImpl类，根据认证方式使用不同的认证bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.service.AuthService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义UserDetailsService用来对接Spring Security</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    AuthService authService;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息组成用户身份信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authType</span> <span class="operator">=</span> authParamsDto.getAuthType();</span><br><span class="line">        <span class="type">AuthService</span> <span class="variable">authService</span> <span class="operator">=</span>  applicationContext.getBean(authType + <span class="string">&quot;_authservice&quot;</span>,AuthService.class);</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">user</span> <span class="operator">=</span> authService.execute(authParamsDto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getUserPrincipal(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user  用户id，主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> com.xuecheng.ucenter.model.po.XcUser 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/29 12:19</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">getUserPrincipal</span><span class="params">(XcUserExt user)</span>&#123;</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities = &#123;<span class="string">&quot;p1&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">        <span class="comment">//为了安全在令牌中不放密码</span></span><br><span class="line">        user.setPassword(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//将user对象转json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        <span class="comment">//创建UserDetails对象</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password ).authorities(authorities).build();</span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启认证服务，测试申请令牌接口。</p><p>1、测试账号和密码都正确的情况是否可以申请令牌成功。</p><p>2、测试密码错误的情况。</p><p>3、测试账号不存在情况。</p><h2 id="3-4-验证码服务"><a href="#3-4-验证码服务" class="headerlink" title="3.4 验证码服务"></a><strong>3.4 验证码服务</strong></h2><h3 id="3-4-1-部署验证码服务工程"><a href="#3-4-1-部署验证码服务工程" class="headerlink" title="3.4.1 部署验证码服务工程"></a><strong>3.4.1 部署验证码服务工程</strong></h3><p>在认证时一般都需要输入验证码，验证码有什么用？</p><p>验证码可以防止恶性攻击，比如：XSS跨站脚本攻击、CSRF跨站请求伪造攻击，一些比较复杂的图形验证码可以有效的防止恶性攻击。</p><p>为了保护系统的安全在一些比较重要的操作都需要验证码。</p><p><img src="/adanpro/adanblog/./../pic/wps111.jpg" alt="img"> </p><p>验证码的类型也有很多：图片、语音、手机短信验证码等。</p><p>本项目创建单独的验证码服务为各业务提供验证码的生成、校验等服务。</p><p>拷贝课程资料目录xuecheng-plus-checkcode验证码服务工程到自己的工程目录。</p><p><img src="/adanpro/adanblog/./../pic/wps112.jpg" alt="img"> </p><p>定义nacos配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/checkcode</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">63075</span></span><br></pre></td></tr></table></figure><p>注意修改bootstrap.yml中的命名空间为自己定义的命名空间。</p><p>配置redis-dev.yaml，保存redis服务启动</p><p><img src="/adanpro/adanblog/./../pic/wps113.jpg" alt="img"> </p><p>内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>: <span class="string"></span></span><br><span class="line">  <span class="attr">redis</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">192.168.101.65</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">6379</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">redis</span></span><br><span class="line">    <span class="attr">database</span>: <span class="string">0</span></span><br><span class="line">    <span class="attr">lettuce</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">pool</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">max-active</span>: <span class="string">20</span></span><br><span class="line">        <span class="attr">max-idle</span>: <span class="string">10</span></span><br><span class="line">        <span class="attr">min-idle</span>: <span class="string">0</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="string">10000</span></span><br><span class="line"><span class="comment">    #redisson:</span></span><br><span class="line"><span class="comment">      #配置文件目录</span></span><br><span class="line"><span class="comment">      #config: classpath:singleServerConfig.yaml</span></span><br></pre></td></tr></table></figure><h3 id="3-4-2-验证码接口测试"><a href="#3-4-2-验证码接口测试" class="headerlink" title="3.4.2 验证码接口测试"></a><strong>3.4.2 验证码接口测试</strong></h3><p>验证码服务对外提供的接口有：</p><p>1、生成验证码</p><p>2、校验验证码。</p><p>如下：</p><p><img src="/adanpro/adanblog/./../pic/wps114.jpg" alt="img"> </p><p>验证码服务如何生成并校验验证码？</p><p>拿图片验证码举例：</p><p>1、先生成一个指定位数的验证码，根据需要可能是数字、数字字母组合或文字。</p><p>2、根据生成的验证码生成一个图片并返回给页面</p><p>3、给生成的验证码分配一个key，将key和验证码一同存入缓存。这个key和图片一同返回给页面。</p><p>4、用户输入验证码，连同key一同提交至认证服务。</p><p>5、认证服务拿key和输入的验证码请求验证码服务去校验</p><p>6、验证码服务根据key从缓存取出正确的验证码和用户输入的验证码进行比对，如果相同则校验通过，否则不通过。</p><p><img src="/adanpro/adanblog/./../pic/wps115.jpg" alt="img"> </p><p>根据接口分析，验证码服务接口如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.checkcode.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.base.model.RestResponse;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.checkcode.model.CheckCodeParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.checkcode.model.CheckCodeResultDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.checkcode.service.CheckCodeService;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParams;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 验证码服务接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api(value = &quot;验证码服务接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckCodeController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;生成验证信息&quot;, notes=&quot;生成验证信息&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/pic&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CheckCodeResultDto <span class="title function_">generatePicCheckCode</span><span class="params">(CheckCodeParamsDto checkCodeParamsDto)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;校验&quot;, notes=&quot;校验&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;name&quot;, value = &quot;业务名称&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;key&quot;, value = &quot;验证key&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;code&quot;, value = &quot;验证码&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/verify&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">verify</span><span class="params">(String key, String code)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、生成验证码接口</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 申请验证码</span><br><span class="line">POST &#123;&#123;checkcode_host&#125;&#125;/checkcode/pic</span><br></pre></td></tr></table></figure><p>2、校验验证码接口</p><p>根据生成验证码返回的key以及日志中输出正确的验证码去测试。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### 校验验证码</span><br><span class="line">POST &#123;&#123;checkcode_host&#125;&#125;/checkcode/verify?key=checkcode4506b95bddbe46cdb0d56810b747db1b&amp;code=70dl</span><br></pre></td></tr></table></figure><h2 id="3-5-账号密码认证"><a href="#3-5-账号密码认证" class="headerlink" title="3.5 账号密码认证"></a><strong>3.5 账号密码认证</strong></h2><h3 id="3-5-1-需求分析"><a href="#3-5-1-需求分析" class="headerlink" title="3.5.1 需求分析"></a><strong>3.5.1 需求分析</strong></h3><p>到目前为止账号和密码认证所需要的技术、组件都已开发完毕，下边实现账号密码认证，输出如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps116.jpg" alt="img"> </p><p>执行流程如下：</p><p><img src="/adanpro/adanblog/./../pic/wps117.jpg" alt="img"> </p><h3 id="3-5-2-账号密码认证开发"><a href="#3-5-2-账号密码认证开发" class="headerlink" title="3.5.2 账号密码认证开发"></a><strong>3.5.2 账号密码认证开发</strong></h3><p>1、在认证服务定义远程调用验证码服务的接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.feignclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/20 20:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@FeignClient(value = &quot;checkcode&quot;,fallbackFactory = CheckCodeClientFactory.class)</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/checkcode&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckCodeClient</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@PostMapping(value = &quot;/verify&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> Boolean <span class="title function_">verify</span><span class="params">(<span class="meta">@RequestParam(&quot;key&quot;)</span> String key,<span class="meta">@RequestParam(&quot;code&quot;)</span> String code)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CheckCodeClientFactory:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckCodeClientFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;CheckCodeClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CheckCodeClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CheckCodeClient</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">verify</span><span class="params">(String key, String code)</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;调用验证码服务熔断异常:&#123;&#125;&quot;</span>, throwable.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类添加：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(basePackages=&#123;<span class="string">&quot;com.xuecheng.*.feignclient&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>配置文件引入feign-dev.yaml</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">-</span> <span class="string">data-id: feign-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">  <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">  <span class="attr">refresh</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><p>2、完善PasswordAuthServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.feignclient.CheckCodeClient;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.service.AuthService;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 账号密码认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Service(&quot;password_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> PasswordEncoder passwordEncoder;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> CheckCodeClient checkCodeClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> XcUser <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//校验验证码</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">checkcode</span> <span class="operator">=</span> authParamsDto.getCheckcode();</span><br><span class="line">  <span class="type">String</span> <span class="variable">checkcodekey</span> <span class="operator">=</span> authParamsDto.getCheckcodekey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(StringUtils.isBlank(checkcodekey) || StringUtils.isBlank(checkcode))&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Boolean</span> <span class="variable">verify</span> <span class="operator">=</span> checkCodeClient.verify(checkcodekey, checkcode);</span><br><span class="line">  <span class="keyword">if</span>(!verify)&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码输入错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//账号</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">  <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">  <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号不存在&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//校验密码</span></span><br><span class="line">  <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">passwordDb</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">  <span class="type">String</span> <span class="variable">passwordForm</span> <span class="operator">=</span> authParamsDto.getPassword();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> passwordEncoder.matches(passwordForm, passwordDb);</span><br><span class="line">  <span class="keyword">if</span>(!matches)&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号或密码错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小技巧：目前账号密码方式添加了验证码校验，为了后期获取令牌方便可以重新定义一个不需要验证码校验的认证类AuthService ，AuthService 中去掉验证码的校验，方便生成令牌。</p><h3 id="3-5-3-账号密码认证测试"><a href="#3-5-3-账号密码认证测试" class="headerlink" title="3.5.3 账号密码认证测试"></a><strong>3.5.3 账号密码认证测试</strong></h3><p>1、使用浏览器访问 <a href="http://www.51xuecheng.cn/sign.html">http://www.51xuecheng.cn/sign.html</a></p><p><img src="/adanpro/adanblog/./../pic/wps118.jpg" alt="img"> </p><p>2、首先测试验证码，分别输入正确的验证码和错误的验证码进行测试</p><p>3、输入正确的账号密码和错误的账号密码进行测试</p><p>登录成功将jwt令牌存储cookie.</p><p>4、测试自动登录</p><p>勾选自动登录cookie生成时间为30天，不勾选自动登录关闭浏览器窗口后自动删除cookie。</p><h1 id="4-微信扫码登录"><a href="#4-微信扫码登录" class="headerlink" title="4 微信扫码登录"></a><strong>4 微信扫码登录</strong></h1><h2 id="4-1-接入规范"><a href="#4-1-接入规范" class="headerlink" title="4.1 接入规范"></a><strong>4.1 接入规范</strong></h2><h3 id="4-1-1-接入流程"><a href="#4-1-1-接入流程" class="headerlink" title="4.1.1 接入流程"></a><strong>4.1.1 接入流程</strong></h3><p>微信扫码登录基于OAuth2协议的授权码模式，</p><p>接口文档：</p><p><a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</a></p><p>流程如下：</p><p><img src="/adanpro/adanblog/./../pic/D0wkkHSbtC6VUSHX4WsjP5ssg5mdnEmXO8NGVGF34dxS9N1WCcq6wvquR4K_Hcut.png" alt="img"></p><p>第三方应用获取access_token令牌后即可请求微信获取用户的信息，成功获取到用户的信息表示用户在第三方应用认证成功。</p><h3 id="4-1-2-请求获取授权码"><a href="#4-1-2-请求获取授权码" class="headerlink" title="4.1.2 请求获取授权码"></a><strong>4.1.2 请求获取授权码</strong></h3><p>第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope&#x3D;snsapi_login），则可以通过在PC端打开以下链接： <a href="https://open.weixin.qq.com/connect/qrconnect?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a> </p><p>若提示“该链接无法访问”，请检查参数是否填写错误，如redirect_uri的域名与审核时填写的授权域名不一致或scope不为snsapi_login。</p><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">appid</td><td align="left">是</td><td align="left">应用唯一标识</td></tr><tr><td align="left">redirect_uri</td><td align="left">是</td><td align="left">请使用urlEncode对链接进行处理</td></tr><tr><td align="left">response_type</td><td align="left">是</td><td align="left">填code</td></tr><tr><td align="left">scope</td><td align="left">是</td><td align="left">应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login</td></tr><tr><td align="left">state</td><td align="left">否</td><td align="left">用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验</td></tr><tr><td align="left">lang</td><td align="left">否</td><td align="left">界面语言，支持cn（中文简体）与en（英文），默认为cn</td></tr></tbody></table><p><strong>返回说明</strong></p><p>用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">redirect_uri?code=CODE&amp;state=STATE</span><br></pre></td></tr></table></figure><p>若用户禁止授权，则不会发生重定向。</p><p><strong>请求示例</strong></p><p>登录一号店网站应用 <a href="https://test.yhd.com/wechat/login.do">https://test.yhd.com/wechat/login.do</a> 打开后，一号店会生成 state 参数，</p><p>跳转到 <a href="https://open.weixin.qq.com/connect/qrconnect?appid=wxbdc5610cc59c1631&redirect_uri=https://passport.yhd.com/wechat/callback.do&response_type=code&scope=snsapi_login&state=3d6be0a4035d839573b04816624a415e#wechat_redirect">https://open.weixin.qq.com/connect/qrconnect?appid=wxbdc5610cc59c1631&amp;redirect_uri=https%3A%2F%2Fpassport.yhd.com%2Fwechat%2Fcallback.do&amp;response_type=code&amp;scope=snsapi_login&amp;state=3d6be0a4035d839573b04816624a415e#wechat_redirect</a> 微信用户使用微信扫描二维码并且确认登录后，</p><p>PC端会跳转到 <a href="https://test.yhd.com/wechat/callback.do?code=CODE&state=3d6be0a40sssssxxxxx6624a415e">https://test.yhd.com/wechat/callback.do?code=CODE&amp;state=3d6be0a40sssssxxxxx6624a415e</a> </p><p><strong>将微信登录二维码内嵌到自己页面</strong></p><p>为了满足网站更定制化的需求，我们还提供了第二种获取 code 的方式，支持网站将微信登录二维码内嵌到自己页面中，用户使用微信扫码授权后通过 JS 将code返回给网站。 JS微信登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到微信域下登录后再返回，提升微信登录的流畅性与成功率。 网站内嵌二维码微信登录 JS 实现办法：</p><p>步骤1：在页面中先引入如下JS文件（支持https）：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js</span><br></pre></td></tr></table></figure><p>步骤2：在需要使用微信登录的地方实例以下JS对象：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var obj = new WxLogin(&#123;</span><br><span class="line">self_redirect:true,</span><br><span class="line">id:&quot;login_container&quot;, </span><br><span class="line">appid: &quot;&quot;, </span><br><span class="line">scope: &quot;&quot;, </span><br><span class="line">redirect_uri: &quot;&quot;,</span><br><span class="line"> state: &quot;&quot;,</span><br><span class="line">style: &quot;&quot;,</span><br><span class="line">href: &quot;&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">self_redirect</td><td align="left">否</td><td align="left">true：手机点击确认登录后可以在 iframe 内跳转到 redirect_uri，false：手机点击确认登录后可以在 top window 跳转到 redirect_uri。默认为 false。</td></tr><tr><td align="left">id</td><td align="left">是</td><td align="left">第三方页面显示二维码的容器id</td></tr><tr><td align="left">appid</td><td align="left">是</td><td align="left">应用唯一标识，在微信开放平台提交应用审核通过后获得</td></tr><tr><td align="left">scope</td><td align="left">是</td><td align="left">应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即可</td></tr><tr><td align="left">redirect_uri</td><td align="left">是</td><td align="left">重定向地址，需要进行UrlEncode</td></tr><tr><td align="left">state</td><td align="left">否</td><td align="left">用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验</td></tr><tr><td align="left">style</td><td align="left">否</td><td align="left">提供”black”、”white”可选，默认为黑色文字描述。详见文档底部FAQ</td></tr><tr><td align="left">href</td><td align="left">否</td><td align="left">自定义样式链接，第三方可根据实际需求覆盖默认样式。详见文档底部FAQ</td></tr></tbody></table><h3 id="4-1-3-通过-code-获取access-token"><a href="#4-1-3-通过-code-获取access-token" class="headerlink" title="4.1.3 通过 code 获取access_token"></a><strong>4.1.3 通过 code 获取access_token</strong></h3><p><strong>接口说明</strong></p><p>通过code获取access_token的接口。</p><p><strong>请求说明</strong></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http请求方式: GET</span><br><span class="line">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">appid</td><td align="left">是</td><td align="left">应用唯一标识，在微信开放平台提交应用审核通过后获得</td></tr><tr><td align="left">secret</td><td align="left">是</td><td align="left">应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</td></tr><tr><td align="left">code</td><td align="left">是</td><td align="left">填写第一步获取的code参数</td></tr><tr><td align="left">grant_type</td><td align="left">是</td><td align="left">填authorization_code</td></tr></tbody></table><p><strong>返回说明</strong></p><p>正确的返回：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">&quot;expires_in&quot;:7200,</span><br><span class="line">&quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;scope&quot;:&quot;SCOPE&quot;,</span><br><span class="line">&quot;unionid&quot;: &quot;UNIONID&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">接口调用凭证</td></tr><tr><td align="left">expires_in</td><td align="left">access_token接口调用凭证超时时间，单位（秒）</td></tr><tr><td align="left">refresh_token</td><td align="left">用户刷新access_token</td></tr><tr><td align="left">openid</td><td align="left">授权用户唯一标识</td></tr><tr><td align="left">scope</td><td align="left">用户授权的作用域，使用逗号（,）分隔</td></tr><tr><td align="left">unionid</td><td align="left">用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的 unionid 是唯一的</td></tr></tbody></table><p>错误返回样例：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;errcode&quot;:40029,&quot;errmsg&quot;:&quot;invalid code&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-准备开发环境"><a href="#4-2-准备开发环境" class="headerlink" title="4.2 准备开发环境"></a><strong>4.2 准备开发环境</strong></h2><h3 id="4-2-1-添加应用"><a href="#4-2-1-添加应用" class="headerlink" title="4.2.1 添加应用"></a><strong>4.2.1 添加应用</strong></h3><p>1、注册微信开放平台</p><p><a href="https://open.weixin.qq.com/">https://open.weixin.qq.com/</a></p><p>2、添加应用</p><p>进入网站应用，添加应用</p><p><img src="/adanpro/adanblog/./../pic/wps127.jpg" alt="img"> </p><p>3、添加应用需要指定一个外网域名作为微信回调域名</p><p>审核通过后，生成app密钥。</p><p>最终获取appID和AppSecret</p><h3 id="4-2-2-内网穿透"><a href="#4-2-2-内网穿透" class="headerlink" title="4.2.2 内网穿透"></a><strong>4.2.2 内网穿透</strong></h3><p>我们的开发环境在局域网，微信回调指向一个公网域名。</p><p>如何让微信回调请求至我们的开发计算机上呢？</p><p>可以使用内网穿透技术，什么是内网穿透？</p><p>内网穿透简单来说就是将内网外网通过隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要内网穿透工具了。开启隧道之后，网穿透工具会分配一个专属域名&#x2F;端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了~~</p><p><img src="/adanpro/adanblog/./../pic/wps128.jpg" alt="img"> </p><p>1、在内网穿透服务器上开通隧道，配置外网域名，配置穿透内网的端口即本地电脑上的端口。</p><p><img src="/adanpro/adanblog/./../pic/wps129.jpg" alt="img"> </p><p>这里我们配置认证服务端口，最终实现通过外网域名访问本地认证服务。</p><p>2、在本地电脑上安装内网穿透的工具，工具上配置内网穿透服务器隧道token。</p><p>市面上做内网穿透的商家很多，需要时可以查阅资料了解下。</p><h2 id="4-3-接入微信登录"><a href="#4-3-接入微信登录" class="headerlink" title="4.3 接入微信登录"></a><strong>4.3 接入微信登录</strong></h2><h3 id="4-3-1-接入分析"><a href="#4-3-1-接入分析" class="headerlink" title="4.3.1 接入分析"></a><strong>4.3.1 接入分析</strong></h3><p>根据OAuth2协议授权码流程，结合本项目自身特点，分析接入微信扫码登录的流程如下：</p><p><img src="/adanpro/adanblog/./../pic/wps130.jpg" alt="img"> </p><p>本项目认证服务需要做哪些事？</p><p>1、需要定义接口接收微信下发的授权码。</p><p>2、收到授权码调用微信接口申请令牌。</p><p>3、申请到令牌调用微信获取用户信息</p><p>4、获取用户信息成功将其写入本项目用户中心数据库。</p><p>5、最后重定向到浏览器自动登录。</p><h3 id="4-3-2-定义接口"><a href="#4-3-2-定义接口" class="headerlink" title="4.3.2 定义接口"></a><strong>4.3.2 定义接口</strong></h3><p>参考接口规范中“请求获取授权码” 定义接收微信下发的授权码接口，</p><p>定义WxLoginController类，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxLoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/wxLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">wxLogin</span><span class="params">(String code, String state)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;微信扫码回调,code:&#123;&#125;,state:&#123;&#125;&quot;</span>,code,state);</span><br><span class="line">        <span class="comment">//请求微信申请令牌，拿到令牌查询用户信息，将用户信息写入本项目数据库</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUser</span>();</span><br><span class="line">        <span class="comment">//暂时硬编写，目的是调试环境</span></span><br><span class="line">        xcUser.setUsername(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(xcUser==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:http://www.51xuecheng.cn/error.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> xcUser.getUsername();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:http://www.51xuecheng.cn/sign.html?username=&quot;</span>+username+<span class="string">&quot;&amp;authType=wx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义微信认证的service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 微信扫码认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;wx_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">xcUserExt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserExt</span>();</span><br><span class="line">        BeanUtils.copyProperties(user,xcUserExt);</span><br><span class="line">        <span class="keyword">return</span> xcUserExt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.3.3 接口环境测试</strong></p><p>接口定义好下边进行测试下，主要目的是测试接口调度的环境。</p><p>1、启动内网穿透工具</p><p>2、在&#x2F;wxLogin接口中打断点</p><p>3、打开前端微信扫码页面</p><p><img src="/adanpro/adanblog/./../pic/wps131.jpg" alt="img"> </p><p>点击微信图标打开二维码</p><p><img src="/adanpro/adanblog/./../pic/wps132.jpg" alt="img"> </p><p>用户扫码，确认授权</p><p>此时正常进入 &#x2F;wxLogin  方法，最后跳转到<a href="http://www.51xuecheng.cn/sign.html?username=t1&authType=wx%E3%80%82">http://www.51xuecheng.cn/sign.html?username=t1&amp;authType=wx。</a></p><h3 id="4-3-4-接入微信认证"><a href="#4-3-4-接入微信认证" class="headerlink" title="4.3.4 接入微信认证"></a><strong>4.3.4 接入微信认证</strong></h3><p>接下来请求微信申请令牌。</p><p>1、使用restTemplate请求微信，配置RestTemplate bean</p><p>在启动类配置restTemplate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(<span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpRequestFactory</span>());</span><br><span class="line">    <span class="keyword">return</span>  restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义与微信认证的service接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 微信认证接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/21 22:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WxAuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> XcUser <span class="title function_">wxAuth</span><span class="params">(String code)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、下边在controller中调用wxAuth接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxLoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WxAuthService wxAuthService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/wxLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">wxLogin</span><span class="params">(String code, String state)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;微信扫码回调,code:&#123;&#125;,state:&#123;&#125;&quot;</span>,code,state);</span><br><span class="line">        <span class="comment">//请求微信申请令牌，拿到令牌查询用户信息，将用户信息写入本项目数据库</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> wxAuthService.wxAuth(code);</span><br><span class="line">        <span class="keyword">if</span>(xcUser==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:http://www.51xuecheng.cn/error.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> xcUser.getUsername();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:http://www.51xuecheng.cn/sign.html?username=&quot;</span>+username+<span class="string">&quot;&amp;authType=wx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在WxAuthService 的wxAuth方法中实现申请令牌、查询用户信息等内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;wx_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span>, WxAuthService &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">XcUserMapper xcUserMapper;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;weixin.appid&#125;&quot;)</span></span><br><span class="line">String appid;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;weixin.secret&#125;&quot;)</span></span><br><span class="line">String secret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> XcUser <span class="title function_">wxAuth</span><span class="params">(String code)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到code调用微信接口申请access_token</span></span><br><span class="line">    Map&lt;String, String&gt; access_token_map = getAccess_token(code);</span><br><span class="line">    <span class="keyword">if</span>(access_token_map==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(access_token_map);</span><br><span class="line">    <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">    <span class="comment">//拿access_token查询用户信息</span></span><br><span class="line">    Map&lt;String, String&gt; userinfo = getUserinfo(access_token, openid);</span><br><span class="line">    <span class="keyword">if</span>(userinfo==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加用户到数据库</span></span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> xcUser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请访问令牌,响应示例</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span></span><br><span class="line"><span class="comment"> &quot;expires_in&quot;:7200,</span></span><br><span class="line"><span class="comment"> &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span></span><br><span class="line"><span class="comment"> &quot;openid&quot;:&quot;OPENID&quot;,</span></span><br><span class="line"><span class="comment"> &quot;scope&quot;:&quot;SCOPE&quot;,</span></span><br><span class="line"><span class="comment"> &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getAccess_token</span><span class="params">(String code)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">wxUrl_template</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line">    <span class="comment">//请求微信地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">wxUrl</span> <span class="operator">=</span> String.format(wxUrl_template, appid, secret, code);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;调用微信接口申请access_token, url:&#123;&#125;&quot;</span>, wxUrl);</span><br><span class="line"></span><br><span class="line">    ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, <span class="literal">null</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> exchange.getBody();</span><br><span class="line">    log.info(<span class="string">&quot;调用微信接口申请access_token: 返回值:&#123;&#125;&quot;</span>, result);</span><br><span class="line">    Map&lt;String,String&gt; resultMap = JSON.parseObject(result, Map.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**获取用户信息，示例如下：</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> &quot;openid&quot;:&quot;OPENID&quot;,</span></span><br><span class="line"><span class="comment"> &quot;nickname&quot;:&quot;NICKNAME&quot;,</span></span><br><span class="line"><span class="comment"> &quot;sex&quot;:1,</span></span><br><span class="line"><span class="comment"> &quot;province&quot;:&quot;PROVINCE&quot;,</span></span><br><span class="line"><span class="comment"> &quot;city&quot;:&quot;CITY&quot;,</span></span><br><span class="line"><span class="comment"> &quot;country&quot;:&quot;COUNTRY&quot;,</span></span><br><span class="line"><span class="comment"> &quot;headimgurl&quot;: &quot;https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span></span><br><span class="line"><span class="comment"> &quot;privilege&quot;:[</span></span><br><span class="line"><span class="comment"> &quot;PRIVILEGE1&quot;,</span></span><br><span class="line"><span class="comment"> &quot;PRIVILEGE2&quot;</span></span><br><span class="line"><span class="comment"> ],</span></span><br><span class="line"><span class="comment"> &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getUserinfo</span><span class="params">(String access_token,String openid)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">wxUrl_template</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/userinfo?access_token=%s&amp;openid=%s&quot;</span>;</span><br><span class="line">    <span class="comment">//请求微信地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">wxUrl</span> <span class="operator">=</span> String.format(wxUrl_template, access_token,openid);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;调用微信接口申请access_token, url:&#123;&#125;&quot;</span>, wxUrl);</span><br><span class="line"></span><br><span class="line">    ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, <span class="literal">null</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止乱码进行转码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span>     <span class="title class_">String</span>(exchange.getBody().getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);</span><br><span class="line">    log.info(<span class="string">&quot;调用微信接口申请access_token: 返回值:&#123;&#125;&quot;</span>, result);</span><br><span class="line">    Map&lt;String,String&gt; resultMap = JSON.parseObject(result, Map.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>测试获取用户信息</p><p>1、在获取用户信息处打断点</p><p>2、进入<a href="http://www.51xuecheng.cn/wxsign.html">http://www.51xuecheng.cn/wxsign.html</a></p><p>3、手机扫码授权</p><h3 id="4-3-5-保存用户信息"><a href="#4-3-5-保存用户信息" class="headerlink" title="4.3.5 保存用户信息"></a><strong>4.3.5 保存用户信息</strong></h3><p>向数据库保存用户信息，如果用户不存在将其保存在数据库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">XcUserRoleMapper xcUserRoleMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> XcUser <span class="title function_">addWxUser</span><span class="params">(Map userInfo_map)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">unionid</span> <span class="operator">=</span> userInfo_map.get(<span class="string">&quot;unionid&quot;</span>).toString();</span><br><span class="line">    <span class="comment">//根据unionid查询数据库</span></span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getWxUnionid, unionid));</span><br><span class="line">    <span class="keyword">if</span>(xcUser!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> xcUser;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    xcUser = <span class="keyword">new</span> <span class="title class_">XcUser</span>();</span><br><span class="line">    xcUser.setId(userId);</span><br><span class="line">    xcUser.setWxUnionid(unionid);</span><br><span class="line">    <span class="comment">//记录从微信得到的昵称</span></span><br><span class="line">    xcUser.setNickname(userInfo_map.get(<span class="string">&quot;nickname&quot;</span>).toString());</span><br><span class="line">    xcUser.setUserpic(userInfo_map.get(<span class="string">&quot;headimgurl&quot;</span>).toString());</span><br><span class="line">    xcUser.setName(userInfo_map.get(<span class="string">&quot;nickname&quot;</span>).toString());</span><br><span class="line">    xcUser.setUsername(unionid);</span><br><span class="line">    xcUser.setPassword(unionid);</span><br><span class="line">    xcUser.setUtype(<span class="string">&quot;101001&quot;</span>);<span class="comment">//学生类型</span></span><br><span class="line">    xcUser.setStatus(<span class="string">&quot;1&quot;</span>);<span class="comment">//用户状态</span></span><br><span class="line">    xcUser.setCreateTime(LocalDateTime.now());</span><br><span class="line">    xcUserMapper.insert(xcUser);</span><br><span class="line">    <span class="type">XcUserRole</span> <span class="variable">xcUserRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserRole</span>();</span><br><span class="line">    xcUserRole.setId(UUID.randomUUID().toString());</span><br><span class="line">    xcUserRole.setUserId(userId);</span><br><span class="line">    xcUserRole.setRoleId(<span class="string">&quot;17&quot;</span>);<span class="comment">//学生角色</span></span><br><span class="line">    xcUserRoleMapper.insert(xcUserRole);</span><br><span class="line">    <span class="keyword">return</span> xcUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用保存用户信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">WxAuthServiceImpl currentProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> XcUser <span class="title function_">wxAuth</span><span class="params">(String code)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到code调用微信接口申请access_token</span></span><br><span class="line">    Map&lt;String, String&gt; access_token_map = getAccess_token(code);</span><br><span class="line">    <span class="keyword">if</span>(access_token_map==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(access_token_map);</span><br><span class="line">    <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">    <span class="comment">//拿access_token查询用户信息</span></span><br><span class="line">    Map&lt;String, String&gt; userinfo = getUserinfo(access_token, openid);</span><br><span class="line">    <span class="keyword">if</span>(userinfo==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户信息保存到数据库</span></span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> currentProxy.addWxUser(userinfo);</span><br><span class="line">    <span class="keyword">return</span> xcUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试保存用户信息</p><p>1、在保存用户信息处打断点</p><p>2、进入<a href="http://www.51xuecheng.cn/wxsign.html">http://www.51xuecheng.cn/wxsign.html</a></p><p>3、手机扫码授权</p><p>4、自动跳转到登录页面，提交认证成功。</p><h1 id="5-用户授权"><a href="#5-用户授权" class="headerlink" title="5 用户授权"></a><strong>5 用户授权</strong></h1><h2 id="5-1-RBAC"><a href="#5-1-RBAC" class="headerlink" title="5.1 RBAC"></a><strong>5.1 RBAC</strong></h2><p>如何实现授权？业界通常基于RBAC实现授权。</p><p>RBAC分为两种方式：</p><p>基于角色的访问控制（Role-Based Access Control）</p><p>基于资源的访问控制（Resource-Based Access Control）</p><p>角色的访问控制（Role-Based Access Control）是按角色进行授权，比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等，访问控制流程如下：</p><p><img src="/adanpro/adanblog/./../pic/image-20230625012435138.png" alt="img"></p><p>根据上图中的判断逻辑，授权代码可表示如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(主体.hasRole(<span class="string">&quot;总经理角色id&quot;</span>))&#123;</span><br><span class="line">查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上图中查询工资所需要的角色变化为总经理和部门经理，此时就需要修改判断逻辑为“判断用户的角色是否是总经理或部门经理”，修改代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(主体.hasRole(<span class="string">&quot;总经理角色id&quot;</span>) ||  主体.hasRole(<span class="string">&quot;部门经理角色id&quot;</span>))&#123;</span><br><span class="line">    查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上边的例子发现，当需要修改角色的权限时就需要修改授权的相关代码，系统可扩展性差。</p><p>基于资源的访问控制（Resource-Based Access</p><p>Control）是按资源（或权限）进行授权，比如：用户必须具有查询工资权限才可以查询员工工资信息等，访问控制流程如下：</p><p><img src="/adanpro/adanblog/./../pic/wps13.jpg" alt="img"> </p><p>根据上图中的判断，授权代码可以表示为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(主体.hasPermission(<span class="string">&quot;查询工资权限标识&quot;</span>))&#123;</span><br><span class="line">    查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-资源服务授权流程"><a href="#5-2-资源服务授权流程" class="headerlink" title="5.2 资源服务授权流程"></a><strong>5.2 资源服务授权流程</strong></h2><p>本项目在资源服务内部进行授权，基于资源的授权模式，因为接口在资源服务，通过在接口处添加授权注解实现授权。</p><p>1、首先配置nginx代理</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Java</span></span><br><span class="line">   <span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">server_names_hash_bucket_size</span> <span class="string">64;</span></span><br><span class="line">    <span class="attr">...</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   #前端开发服务</span></span><br><span class="line">  <span class="attr">upstream</span> <span class="string">uidevserver&#123;</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">127.0.0.1:8601 weight=10;</span></span><br><span class="line">  <span class="attr">&#125;</span> <span class="string"></span></span><br><span class="line">   <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">80;</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">teacher.51xuecheng.cn;</span></span><br><span class="line"><span class="comment">        #charset koi8-r;</span></span><br><span class="line">        <span class="attr">ssi</span> <span class="string">on;</span></span><br><span class="line">        <span class="attr">ssi_silent_errors</span> <span class="string">on;</span></span><br><span class="line"><span class="comment">        #access_log  logs/host.access.log  main;</span></span><br><span class="line"><span class="comment">        #location / &#123;</span></span><br><span class="line"><span class="comment">         #   alias   D:/itcast2022/xc_edu3.0/code_1/dist/;</span></span><br><span class="line"><span class="comment">         #   index  index.html index.htm;</span></span><br><span class="line"><span class="comment">        #&#125;</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">proxy_pass</span>   <span class="string">http://uidevserver;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/api/ &#123;</span></span><br><span class="line">                <span class="attr">proxy_pass</span> <span class="string">http://gatewayserver/;</span></span><br><span class="line">        <span class="attr">&#125;</span> <span class="string"></span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">   <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>加载nginx 配置。</p><p>2、在资源服务集成Spring Security</p><p>在需要授权的接口处使用@PreAuthorize(“hasAuthority(‘权限标识符’)”)进行控制</p><p>下边代码指定&#x2F;course&#x2F;list接口需要拥有xc_teachmanager_course_list 权限。</p><p><img src="/adanpro/adanblog/./../pic/wps14.jpg" alt="img"> </p><p>设置了@PreAuthorize表示执行此方法需要授权，如果当前用户请求接口没有权限则抛出异常</p><p>org.springframework.security.access.AccessDeniedException: 不允许访问</p><p>3、在统一异常处理处解析此异常信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line"><span class="keyword">public</span> RestErrorResponse <span class="title function_">exception</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">   log.error(<span class="string">&quot;【系统异常】&#123;&#125;&quot;</span>,e.getMessage(),e);</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   <span class="keyword">if</span>(e.getMessage().equals(<span class="string">&quot;不允许访问&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(<span class="string">&quot;没有操作此功能的权限&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(CommonError.UNKOWN_ERROR.getErrMessage());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、重启资源服务进行测试</p><p>使用教学机构用户登录系统</p><p>这里使用t1用户登录，账号:t1、密码：111111</p><p>登录成功，点击“教学机构”</p><p><img src="/adanpro/adanblog/./../pic/wps15.jpg" alt="img"> </p><p>当用户没有权限时页面提示：没有操作此功能的权限。</p><p><img src="/adanpro/adanblog/./../pic/wps16.jpg" alt="img"> </p><h2 id="5-3-授权相关的数据模型"><a href="#5-3-授权相关的数据模型" class="headerlink" title="5.3 授权相关的数据模型"></a><strong>5.3 授权相关的数据模型</strong></h2><p>如何给用户分配权限呢？</p><p>首先要学习数据模型，本项目授权相关的数据表如下：</p><p><img src="/adanpro/adanblog/./../pic/image-20230625012701680.png" alt="image-20230625012701680"></p><p>说明如下：</p><p>xc_user：用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等</p><p>xc_role：角色表，存储了系统的角色信息，学生、老师、教学管理员、系统管理员等。</p><p>xc_user_role：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有</p><p>xc_menu:模块表，记录了菜单及菜单下的权限</p><p>xc_permission:角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有</p><p>本项目教学阶段不再实现权限定义及用户权限分配的功能，权限分配的界面原型如下图所示：</p><p><img src="/adanpro/adanblog/./../pic/wps17.jpg" alt="img"> </p><p>本项目要求掌握基于权限数据模型（5张数据表），要求在数据库中操作完成给用户分配权限、查询用户权限等需求。</p><p>1、查询用户所拥有的权限</p><p>步骤：</p><p>查询用户的id</p><p>查询用户所拥有的角色</p><p>查询用户所拥有的权限</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> xc_menu <span class="keyword">WHERE</span> id <span class="keyword">IN</span>(</span><br><span class="line">  <span class="keyword">SELECT</span> menu_id <span class="keyword">FROM</span> xc_permission <span class="keyword">WHERE</span> role_id <span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> xc_user_role <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;49&#x27;</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2、给用户分配权限</p><p>1）添加权限</p><p>查询用户的id</p><p>查询权限的id</p><p>查询用户的角色，如果没有角色需要先给用户指定角色</p><p>向角色权限表添加记录</p><p>2）删除用户权限</p><p>本项目是基于角色分配权限，如果要删除用户的权限可以给用户换角色，那么新角色下的权限就是用户的权限；如果不换用户的角色可以删除角色下的权限即删除角色权限关系表相应记录，这样操作是将角色下的权限删除，属于该角色的用户都将删除此权限。</p><h2 id="5-4-查询用户权限"><a href="#5-4-查询用户权限" class="headerlink" title="5.4 查询用户权限"></a><strong>5.4 查询用户权限</strong></h2><p>使用Spring Security进行授权，首先在生成jwt前会查询用户的权限，如下图：</p><p><img src="/adanpro/adanblog/./../pic/wps18.jpg" alt="img"> </p><p>接下来需要修改UserServiceImpl和PasswordAuthServiceImpl从数据库查询用户的权限。</p><p>1、定义mapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">XcMenuMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;XcMenu&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT    * FROM xc_menu WHERE id IN (SELECT menu_id FROM xc_permission WHERE role_id IN ( SELECT role_id FROM xc_user_role WHERE user_id = #&#123;userId&#125; ))&quot;)</span></span><br><span class="line">    List&lt;XcMenu&gt; <span class="title function_">selectPermissionByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> String userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、修改PasswordAuthServiceImpl</p><p>修改UserServiceImpl类的getUserPrincipal方法，查询权限信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询用户身份</span></span><br><span class="line"><span class="keyword">public</span> UserDetails <span class="title function_">getUserPrincipal</span><span class="params">(XcUserExt user)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">    <span class="comment">//查询用户权限</span></span><br><span class="line">    List&lt;XcMenu&gt; xcMenus = menuMapper.selectPermissionByUserId(user.getId());</span><br><span class="line">    List&lt;String&gt; permissions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(xcMenus.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//用户权限,如果不加则报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        permissions.add(<span class="string">&quot;p1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xcMenus.forEach(menu-&gt;&#123;</span><br><span class="line">            permissions.add(menu.getCode());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户权限放在XcUserExt中</span></span><br><span class="line">    user.setPermissions(permissions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了安全在令牌中不放密码</span></span><br><span class="line">    user.setPassword(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//将user对象转json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">    String[] authorities = permissions.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password).authorities(authorities).build();</span><br><span class="line">    <span class="keyword">return</span> userDetails;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-授权测试"><a href="#5-5-授权测试" class="headerlink" title="5.5 授权测试"></a><strong>5.5 授权测试</strong></h2><p>以上实现了认证时从数据库查询用户的权限，下边进行用户授权测试。</p><p>重启认证服务，使用内容管理课程列表查询为例，代码如下：</p><p><img src="/adanpro/adanblog/./../pic/wps19.jpg" alt="img"> </p><p>用户拥有xc_teachmanager_course_list权限方可访问课程查询接口。</p><p>以用户stu1为例，当它没有此权限时页面报“没有此操作的权限”错误</p><p><img src="/adanpro/adanblog/./../pic/wps20.jpg" alt="img"> </p><p>将xc_teachmanager_course_list权限分配给用户。</p><p>1）首先找到当前用户的角色</p><p>2）找到xc_teachmanager_course_list权限的主键</p><p>3）在角色权限关系表中添加记录</p><p>分配完权限需要重新登录</p><p>由于用户分配了xc_teachmanager_course_list权限，用户具有访问课程查询接口的权限。</p><h2 id="5-6-细粒度授权"><a href="#5-6-细粒度授权" class="headerlink" title="5.6 细粒度授权"></a><strong>5.6 细粒度授权</strong></h2><h3 id="5-6-1-什么是细粒度授权"><a href="#5-6-1-什么是细粒度授权" class="headerlink" title="5.6.1 什么是细粒度授权"></a><strong>5.6.1 什么是细粒度授权</strong></h3><p>什么是细粒度授权？</p><p>细粒度授权也叫数据范围授权，即不同的用户所拥有的操作权限相同，但是能够操作的数据范围是不一样的。一个例子：用户A和用户B都是教学机构，他们都拥有“我的课程”权限，但是两个用户所查询到的数据是不一样的。</p><p>本项目有哪些细粒度授权？</p><p>比如：</p><p>我的课程，教学机构只允许查询本教学机构下的课程信息。</p><p>我的选课，学生只允许查询自己所选课。</p><p>如何实现细粒度授权？</p><p>细粒度授权涉及到不同的业务逻辑，通常在service层实现，根据不同的用户进行校验，根据不同的参数查询不同的数据或操作不同的数据。</p><h3 id="5-6-2-教学机构细粒度授权"><a href="#5-6-2-教学机构细粒度授权" class="headerlink" title="5.6.2 教学机构细粒度授权"></a><strong>5.6.2 教学机构细粒度授权</strong></h3><p>教学机构在维护课程时只允许维护本机构的课程，教学机构细粒度授权过程如下：</p><p>1）获取当前登录的用户身份</p><p>2）得到用户所属教育机构的Id</p><p>3）查询该教学机构下的课程信息</p><p>最终实现了用户只允许查询自己机构的课程信息。</p><p>根据公司Id查询课程，流程如下：</p><p>1）教学机构用户登录系统，从用户身份中取出所属机构的id</p><p>在用户表中设计了company_id字段存储该用户所属的机构id.</p><p>2）接口层取出当前登录用户的身份，取出机构id</p><ol start="3"><li>将机构id传入service方法。</li><li>service方法将机构id传入Dao方法，最终查询出本机构的课程信息。</li></ol><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="meta">@ApiOperation(&quot;课程查询接口&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;xc_teachmanager_course_list&#x27;)&quot;)</span><span class="comment">//拥有课程列表查询的权限方可访问</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/course/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;CourseBase&gt; <span class="title function_">list</span><span class="params">(PageParams pageParams, <span class="meta">@RequestBody</span> QueryCourseParamsDto queryCourseParams)</span>&#123;</span><br><span class="line">    <span class="comment">//取出用户身份</span></span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> SecurityUtil.getUser();</span><br><span class="line">    <span class="comment">//机构id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> user.getCompanyId();</span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.queryCourseBaseList(Long.parseLong(companyId),pageParams,queryCourseParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;CourseBase&gt; <span class="title function_">queryCourseBaseList</span><span class="params">(Long companyId,PageParams pageParams, QueryCourseParamsDto queryCourseParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//构建查询条件对象</span></span><br><span class="line"> LambdaQueryWrapper&lt;CourseBase&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">//机构id</span></span><br><span class="line"> queryWrapper.eq(CourseBase::getCompanyId,companyId);</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure><p><strong>5.6.3 教学机构细粒度授权测试</strong></p><p>使用一个教学机构的用户登录项目，并且此用户具有查询课程的权限。</p><p>手机修改数据库指定用户归属到一个机构中，涉及以下数据表：</p><p>xc_company为机构表</p><p>xc_company_user为机构用户关系表</p><p>xc_user表中有company_id字段。</p><p>我们准备了t1 用户作为此次测试的用户，使用此用户登录系统：</p><p>提前在查询课程列表接口处打上断点。</p><p>经过测试可以正常取出用户所属的机构id</p><p><img src="/adanpro/adanblog/./../pic/wps21.jpg" alt="img"> </p><p>跟踪持久层日志发现已将机构id传入dao方法，拼装sql语句，查询本机构的课程信息</p><p><img src="/adanpro/adanblog/./../pic/wps22.jpg" alt="img"> </p><h1 id="6-找回密码-实战"><a href="#6-找回密码-实战" class="headerlink" title="6 找回密码(实战)"></a><strong>6 找回密码(实战)</strong></h1><p>需求：忘记密码需要找回，可以通过手机号找回密码，通过邮箱找回密码以及人工通道。</p><p>界面访问地址：<a href="http://www.51xuecheng.cn/findpassword.html">http://www.51xuecheng.cn/findpassword.html</a></p><p><img src="/adanpro/adanblog/./../pic/wps23.jpg" alt="img"> </p><p>接口：</p><p>手机验证码：&#x2F;api&#x2F;checkcode&#x2F;phone?param1&#x3D;手机号</p><p>邮箱验证码：&#x2F;api&#x2F;checkcode&#x2F;phone?param1&#x3D;电子邮箱地址</p><p>找回密码：&#x2F;api&#x2F;auth&#x2F;findpassword</p><p>请求：</p><p>JSON {    cellphone:’’,    email:’’,    checkcodekey:’’,    checkcode:’’,    confirmpwd:’’,    password:’’  }</p><p>响应：</p><p>200: 找回成功</p><p>其它：找回失败，失败原因使用统一异常处理返回的信息格式</p><p>执行流程<br>1、校验验证码，不一致则抛出异常</p><p>2、判断两次密码是否一致，不一致则抛出异常</p><p>3、根据手机号和邮箱查询用户</p><p>4、如果找到用户更新为新密码</p><h2 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h2><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><p>在验证模块CheckCodeController中定义发送验证码接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;发送手机/邮箱验证码&quot;, tags = &quot;发送手机/邮箱验证码&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/phone&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEMail</span><span class="params">(<span class="meta">@RequestParam(&quot;param1&quot;)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// String code = MailUtil.achieveCode();</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">randObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="comment">// 生成6位随机验证码</span></span><br><span class="line">    <span class="comment">// String code = Integer.toString(100000 + randObj.nextInt(900000));</span></span><br><span class="line">    <span class="comment">// 生成4位随机验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Integer.toString(<span class="number">1000</span> + randObj.nextInt(<span class="number">9000</span>));</span><br><span class="line">    sendCodeService.sendEMail(param, code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引入工具类</strong></p><p><img src="/adanpro/adanblog/./../pic/image-20230625013523200.png" alt="img"></p><h3 id="service实现"><a href="#service实现" class="headerlink" title="service实现"></a>service实现</h3><p>新建service</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface SendCodeService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向目标手机/邮箱发送验证码</span><br><span class="line">     * @param param 目标邮箱</span><br><span class="line">     * @param code  我们发送的验证码</span><br><span class="line">     */</span><br><span class="line">    void sendEMail(String param, String code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SendCodeServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: adan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 发送邮箱/手机验证码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-06-24 23:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SendCodeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;SMS.signName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String signName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;SMS.templateCode&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String templateCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">CODE_TTL</span> <span class="operator">=</span> <span class="number">120L</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEMail</span><span class="params">(String param, String code)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 向用户发送验证码</span></span><br><span class="line">        <span class="keyword">if</span> (isEmail(param)) &#123;</span><br><span class="line">            <span class="comment">// 发送邮箱</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MailUtil.sendTestMail(param, code);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.error(<span class="string">&quot;发送邮箱到:&#123;&#125;失败&quot;</span>, param);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;发送邮箱失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPhone(param)) &#123;</span><br><span class="line">            <span class="comment">// 发送手机短信</span></span><br><span class="line">            SMSUtils.sendMessage(signName, templateCode, param, code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 字符串既不是邮箱也不是手机</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;格式出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 将验证码缓存到redis，TTL设置为2分钟</span></span><br><span class="line">        redisTemplate.opsForValue().set(code, param, CODE_TTL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmail</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\w+@(\\w+\\.)+[a-z]&#123;2,3&#125;$&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPhone</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^1[0-9]&#123;10&#125;$&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引入redis依赖</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line"><span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="attr">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line"><span class="attr">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span></span><br><span class="line"><span class="attr">&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;version&gt;2.6.2&lt;/version&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><p> bootstrap.yml配置reids配置信息</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">checkcode</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">192.168.101.129:8848</span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">dev</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">dev</span></span><br><span class="line">        <span class="attr">group</span>: <span class="string">xuecheng-plus-project</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">shared-configs</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: swagger-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">          <span class="attr">-</span> <span class="string">data-id: redis-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">            <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">            <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure><h2 id="校验验证码"><a href="#校验验证码" class="headerlink" title="校验验证码"></a>校验验证码</h2><p>校验验证码进行更改密码操作</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>新建VerifyCodeController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerifyCodeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> VerifyCodeService verifyCodeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;找回密码&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/findpassword&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findpassword</span><span class="params">(<span class="meta">@RequestBody</span> CheckCodeDto checkCode)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> verifyCodeService.updatePassword(checkCode);</span><br><span class="line">        <span class="keyword">if</span> (update)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;修改成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;修改失败&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service实现-1"><a href="#service实现-1" class="headerlink" title="service实现"></a>service实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VerifyCodeService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">updatePassword</span><span class="params">(CheckCodeDto checkCode)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerifyCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">VerifyCodeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> XcUserMapper xcUserMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> VerifyCodeServiceImpl currentProxy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updatePassword</span><span class="params">(CheckCodeDto checkCodeDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">checkcode</span> <span class="operator">=</span> checkCodeDto.getCheckcode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">check</span> <span class="operator">=</span> redisTemplate.opsForValue().get(checkcode);</span><br><span class="line">        <span class="keyword">if</span> (check == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验两次输入密码是否一致</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> checkCodeDto.getPassword();</span><br><span class="line">        <span class="type">String</span> <span class="variable">confirmpwd</span> <span class="operator">=</span> checkCodeDto.getConfirmpwd();</span><br><span class="line">        <span class="keyword">if</span> (!password.equals(confirmpwd)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入密码不一致出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验手机/邮箱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> checkCodeDto.getEmail();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cellphone</span> <span class="operator">=</span> checkCodeDto.getCellphone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmail(check)) &#123;</span><br><span class="line">            <span class="comment">// 处理邮箱</span></span><br><span class="line">            <span class="keyword">if</span> (!email.equals(check)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;邮箱信息出错&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据邮箱查询数据库，修改密码</span></span><br><span class="line">            <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;()</span><br><span class="line">                    .eq(XcUser::getEmail, email));</span><br><span class="line">            currentProxy.updatePassword(password, user);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPhone(check)) &#123;</span><br><span class="line">            <span class="comment">// 处理手机</span></span><br><span class="line">            <span class="keyword">if</span> (!cellphone.equals(check)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;手机信息出错&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据手机号查询数据库，修改密码</span></span><br><span class="line">            <span class="comment">// 根据邮箱查询数据库，修改密码</span></span><br><span class="line">            <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;()</span><br><span class="line">                    .eq(XcUser::getCellphone, cellphone));</span><br><span class="line">            currentProxy.updatePassword(password, user);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 字符串既不是邮箱也不是手机</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;手机/邮箱格式信息出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePassword</span><span class="params">(String password, XcUser user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        user.setPassword(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(password));</span><br><span class="line">        xcUserMapper.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmail</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\w+@(\\w+\\.)+[a-z]&#123;2,3&#125;$&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPhone</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^1[0-9]&#123;10&#125;$&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入redis依赖</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line"><span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="attr">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line"><span class="attr">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span></span><br><span class="line"><span class="attr">&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;version&gt;2.6.2&lt;/version&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><p> bootstrap.yml配置reids配置信息</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">...</span></span><br><span class="line">      <span class="attr">shared-configs</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">-</span> <span class="string">data-id: swagger-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">          <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">          <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">-</span> <span class="string">data-id: redis-$&#123;spring.profiles.active&#125;.yaml</span></span><br><span class="line">          <span class="attr">group</span>: <span class="string">xuecheng-plus-common</span></span><br><span class="line">          <span class="attr">refresh</span>: <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">active</span>: <span class="string">dev</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xcplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实战 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
